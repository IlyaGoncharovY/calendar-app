var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var require_index_001 = __commonJS({
  "assets/index-a55cd85e.js"(exports) {
    function _mergeNamespaces(n2, m2) {
      for (var i2 = 0; i2 < m2.length; i2++) {
        const e2 = m2[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity)
          fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy)
          fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$5 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$7 = Symbol.for("react.fragment"), q$6 = Symbol.for("react.strict_mode"), r$6 = Symbol.for("react.profiler"), t$5 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
    function A$3(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = z$3 && a2[z$3] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var B$2 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$2 = {};
    function E$2(a2, b2, e2) {
      this.props = a2;
      this.context = b2;
      this.refs = D$2;
      this.updater = e2 || B$2;
    }
    E$2.prototype.isReactComponent = {};
    E$2.prototype.setState = function(a2, b2) {
      if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a2, b2, "setState");
    };
    E$2.prototype.forceUpdate = function(a2) {
      this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
    };
    function F$1() {
    }
    F$1.prototype = E$2.prototype;
    function G$2(a2, b2, e2) {
      this.props = a2;
      this.context = b2;
      this.refs = D$2;
      this.updater = e2 || B$2;
    }
    var H$2 = G$2.prototype = new F$1();
    H$2.constructor = G$2;
    C$1(H$2, E$2.prototype);
    H$2.isPureReactComponent = true;
    var I$2 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
    function M$2(a2, b2, e2) {
      var d2, c2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          J.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a2 && a2.defaultProps)
        for (d2 in g2 = a2.defaultProps, g2)
          void 0 === c2[d2] && (c2[d2] = g2[d2]);
      return { $$typeof: l$5, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
    }
    function N$2(a2, b2) {
      return { $$typeof: l$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
    }
    function O$2(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$5;
    }
    function escape(a2) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a2.replace(/[=:]/g, function(a3) {
        return b2[a3];
      });
    }
    var P$2 = /\/+/g;
    function Q$2(a2, b2) {
      return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
    }
    function R$2(a2, b2, e2, d2, c2) {
      var k2 = typeof a2;
      if ("undefined" === k2 || "boolean" === k2)
        a2 = null;
      var h2 = false;
      if (null === a2)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a2.$$typeof) {
              case l$5:
              case n$6:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$2(h2, 0) : d2, I$2(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e2, "", function(a3) {
          return a3;
        })) : null != c2 && (O$2(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
      h2 = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I$2(a2))
        for (var g2 = 0; g2 < a2.length; g2++) {
          k2 = a2[g2];
          var f2 = d2 + Q$2(k2, g2);
          h2 += R$2(k2, b2, e2, f2, c2);
        }
      else if (f2 = A$3(a2), "function" === typeof f2)
        for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
          k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$2(k2, b2, e2, f2, c2);
      else if ("object" === k2)
        throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$2(a2, b2, e2) {
      if (null == a2)
        return a2;
      var d2 = [], c2 = 0;
      R$2(a2, d2, "", "", function(a3) {
        return b2.call(e2, a3, c2++);
      });
      return d2;
    }
    function T$1(a2) {
      if (-1 === a2._status) {
        var b2 = a2._result;
        b2 = b2();
        b2.then(function(b3) {
          if (0 === a2._status || -1 === a2._status)
            a2._status = 1, a2._result = b3;
        }, function(b3) {
          if (0 === a2._status || -1 === a2._status)
            a2._status = 2, a2._result = b3;
        });
        -1 === a2._status && (a2._status = 0, a2._result = b2);
      }
      if (1 === a2._status)
        return a2._result.default;
      throw a2._result;
    }
    var U$2 = { current: null }, V$1 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
      S$2(a2, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a2) {
      var b2 = 0;
      S$2(a2, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a2) {
      return S$2(a2, function(a3) {
        return a3;
      }) || [];
    }, only: function(a2) {
      if (!O$2(a2))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a2;
    } };
    react_production_min.Component = E$2;
    react_production_min.Fragment = p$7;
    react_production_min.Profiler = r$6;
    react_production_min.PureComponent = G$2;
    react_production_min.StrictMode = q$6;
    react_production_min.Suspense = w$3;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
    react_production_min.cloneElement = function(a2, b2, e2) {
      if (null === a2 || void 0 === a2)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
      var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a2.type && a2.type.defaultProps)
          var g2 = a2.type.defaultProps;
        for (f2 in b2)
          J.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d2.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d2.children = g2;
      }
      return { $$typeof: l$5, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a2) {
      a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a2.Provider = { $$typeof: t$5, _context: a2 };
      return a2.Consumer = a2;
    };
    react_production_min.createElement = M$2;
    react_production_min.createFactory = function(a2) {
      var b2 = M$2.bind(null, a2);
      b2.type = a2;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a2) {
      return { $$typeof: v$5, render: a2 };
    };
    react_production_min.isValidElement = O$2;
    react_production_min.lazy = function(a2) {
      return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$1 };
    };
    react_production_min.memo = function(a2, b2) {
      return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a2) {
      var b2 = V$1.transition;
      V$1.transition = {};
      try {
        a2();
      } finally {
        V$1.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a2, b2) {
      return U$2.current.useCallback(a2, b2);
    };
    react_production_min.useContext = function(a2) {
      return U$2.current.useContext(a2);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a2) {
      return U$2.current.useDeferredValue(a2);
    };
    react_production_min.useEffect = function(a2, b2) {
      return U$2.current.useEffect(a2, b2);
    };
    react_production_min.useId = function() {
      return U$2.current.useId();
    };
    react_production_min.useImperativeHandle = function(a2, b2, e2) {
      return U$2.current.useImperativeHandle(a2, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a2, b2) {
      return U$2.current.useInsertionEffect(a2, b2);
    };
    react_production_min.useLayoutEffect = function(a2, b2) {
      return U$2.current.useLayoutEffect(a2, b2);
    };
    react_production_min.useMemo = function(a2, b2) {
      return U$2.current.useMemo(a2, b2);
    };
    react_production_min.useReducer = function(a2, b2, e2) {
      return U$2.current.useReducer(a2, b2, e2);
    };
    react_production_min.useRef = function(a2) {
      return U$2.current.useRef(a2);
    };
    react_production_min.useState = function(a2) {
      return U$2.current.useState(a2);
    };
    react_production_min.useSyncExternalStore = function(a2, b2, e2) {
      return U$2.current.useSyncExternalStore(a2, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$2.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    {
      react.exports = react_production_min;
    }
    var reactExports = react.exports;
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$3 = reactExports, k$4 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$5 = Object.prototype.hasOwnProperty, n$5 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$6 = { key: true, ref: true, __self: true, __source: true };
    function q$5(c2, a2, g2) {
      var b2, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a2.key && (e2 = "" + a2.key);
      void 0 !== a2.ref && (h2 = a2.ref);
      for (b2 in a2)
        m$5.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a2 = c2.defaultProps, a2)
          void 0 === d2[b2] && (d2[b2] = a2[b2]);
      return { $$typeof: k$4, type: c2, key: e2, ref: h2, props: d2, _owner: n$5.current };
    }
    reactJsxRuntime_production_min.Fragment = l$4;
    reactJsxRuntime_production_min.jsx = q$5;
    reactJsxRuntime_production_min.jsxs = q$5;
    {
      jsxRuntime.exports = reactJsxRuntime_production_min;
    }
    var jsxRuntimeExports = jsxRuntime.exports;
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a2, b2) {
        var c2 = a2.length;
        a2.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a2[d2];
            if (0 < g2(e2, b2))
              a2[d2] = b2, a2[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a2) {
        return 0 === a2.length ? null : a2[0];
      }
      function k2(a2) {
        if (0 === a2.length)
          return null;
        var b2 = a2[0], c2 = a2.pop();
        if (c2 !== b2) {
          a2[0] = c2;
          a:
            for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
              var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a2[d2] = x2, a2[n2] = c2, d2 = n2;
              else
                break a;
            }
        }
        return b2;
      }
      function g2(a2, b2) {
        var c2 = a2.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a2.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a2) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback)
            k2(t2);
          else if (b2.startTime <= a2)
            k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
          else
            break;
          b2 = h2(t2);
        }
      }
      function H2(a2) {
        B2 = false;
        G2(a2);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b2 = h2(t2);
            null !== b2 && K2(H2, b2.startTime - a2);
          }
      }
      function J2(a2, b2) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b2);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b2);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a2 = exports2.unstable_now();
          Q2 = a2;
          var b2 = true;
          try {
            b2 = O2(true, a2);
          } finally {
            b2 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a2) {
        O2 = a2;
        N2 || (N2 = true, S2());
      }
      function K2(a2, b2) {
        L2 = D2(function() {
          a2(exports2.unstable_now());
        }, b2);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a2) {
        0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a2) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a2, b2) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c2 = y2;
        y2 = a2;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a2, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a2) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
        return a2;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a2) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a2.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    var schedulerExports = scheduler.exports;
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p$5(a2) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a2, b2) {
      ha(a2, b2);
      ha(a2 + "Capture", b2);
    }
    function ha(a2, b2) {
      ea[a2] = b2;
      for (a2 = 0; a2 < b2.length; a2++)
        da.add(b2[a2]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a2) {
      if (ja.call(ma, a2))
        return true;
      if (ja.call(la, a2))
        return false;
      if (ka.test(a2))
        return ma[a2] = true;
      la[a2] = true;
      return false;
    }
    function pa(a2, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a2 = a2.toLowerCase().slice(0, 5);
          return "data-" !== a2 && "aria-" !== a2;
        default:
          return false;
      }
    }
    function qa(a2, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function v$4(a2, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a2;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z$2 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      z$2[a2] = new v$4(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b2 = a2[0];
      z$2[b2] = new v$4(b2, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      z$2[a2] = new v$4(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a2) {
      return a2[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b2 = a2.replace(
        ra,
        sa
      );
      z$2[b2] = new v$4(b2, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b2 = a2.replace(ra, sa);
      z$2[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b2 = a2.replace(ra, sa);
      z$2[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    z$2.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      z$2[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    function ta(a2, b2, c2, d2) {
      var e2 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
      if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
        qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = Ja && a2[Ja] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var A$2 = Object.assign, La;
    function Ma(a2) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La = b2 && b2[1] || "";
        }
      return "\n" + La + a2;
    }
    var Na = false;
    function Oa(a2, b2) {
      if (!a2 || Na)
        return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a2, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a2.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d2 = l2;
          }
          a2();
        }
      } catch (l2) {
        if (l2 && d2 && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
    }
    function Pa(a2) {
      switch (a2.tag) {
        case 5:
          return Ma(a2.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Oa(a2.type, false), a2;
        case 11:
          return a2 = Oa(a2.type.render, false), a2;
        case 1:
          return a2 = Oa(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Qa(a2) {
      if (null == a2)
        return null;
      if ("function" === typeof a2)
        return a2.displayName || a2.name || null;
      if ("string" === typeof a2)
        return a2;
      switch (a2) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a2)
        switch (a2.$$typeof) {
          case Ca:
            return (a2.displayName || "Context") + ".Consumer";
          case Ba:
            return (a2._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a2.render;
            a2 = a2.displayName;
            a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
            return a2;
          case Ga:
            return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
          case Ha:
            b2 = a2._payload;
            a2 = a2._init;
            try {
              return Qa(a2(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra(a2) {
      var b2 = a2.type;
      switch (a2.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b2.displayName || "Context") + ".Consumer";
        case 10:
          return (b2._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b2;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b2);
        case 8:
          return b2 === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b2)
            return b2.displayName || b2.name || null;
          if ("string" === typeof b2)
            return b2;
      }
      return null;
    }
    function Sa(a2) {
      switch (typeof a2) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a2;
        case "object":
          return a2;
        default:
          return "";
      }
    }
    function Ta(a2) {
      var b2 = a2.type;
      return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua(a2) {
      var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
      if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a2, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a3) {
          d2 = "" + a3;
          f2.call(this, a3);
        } });
        Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a3) {
          d2 = "" + a3;
        }, stopTracking: function() {
          a2._valueTracker = null;
          delete a2[b2];
        } };
      }
    }
    function Va(a2) {
      a2._valueTracker || (a2._valueTracker = Ua(a2));
    }
    function Wa(a2) {
      if (!a2)
        return false;
      var b2 = a2._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
      a2 = d2;
      return a2 !== c2 ? (b2.setValue(a2), true) : false;
    }
    function Xa(a2) {
      a2 = a2 || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a2)
        return null;
      try {
        return a2.activeElement || a2.body;
      } catch (b2) {
        return a2.body;
      }
    }
    function Ya(a2, b2) {
      var c2 = b2.checked;
      return A$2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
    }
    function Za(a2, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa(null != b2.value ? b2.value : c2);
      a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function ab(a2, b2) {
      b2 = b2.checked;
      null != b2 && ta(a2, "checked", b2, false);
    }
    function bb(a2, b2) {
      ab(a2, b2);
      var c2 = Sa(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a2.value || a2.value != c2)
            a2.value = "" + c2;
        } else
          a2.value !== "" + c2 && (a2.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a2.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
    }
    function db(a2, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a2._wrapperState.initialValue;
        c2 || b2 === a2.value || (a2.value = b2);
        a2.defaultValue = b2;
      }
      c2 = a2.name;
      "" !== c2 && (a2.name = "");
      a2.defaultChecked = !!a2._wrapperState.initialChecked;
      "" !== c2 && (a2.name = c2);
    }
    function cb(a2, b2, c2) {
      if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
        null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a2, b2, c2, d2) {
      a2 = a2.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a2.length; c2++)
          e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b2 = null;
        for (e2 = 0; e2 < a2.length; e2++) {
          if (a2[e2].value === c2) {
            a2[e2].selected = true;
            d2 && (a2[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a2, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(p$5(91));
      return A$2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
    }
    function hb(a2, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(p$5(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$5(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a2._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a2, b2) {
      var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
      null != d2 && (a2.defaultValue = "" + d2);
    }
    function jb(a2) {
      var b2 = a2.textContent;
      b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
    }
    function kb(a2) {
      switch (a2) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a2, b2) {
      return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
    }
    var mb, nb = function(a2) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a2(b2, c2, d2, e2);
        });
      } : a2;
    }(function(a2, b2) {
      if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
        a2.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a2.firstChild; )
          a2.removeChild(a2.firstChild);
        for (; b2.firstChild; )
          a2.appendChild(b2.firstChild);
      }
    });
    function ob(a2, b2) {
      if (b2) {
        var c2 = a2.firstChild;
        if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a2.textContent = b2;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a2) {
      qb.forEach(function(b2) {
        b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
        pb[b2] = pb[a2];
      });
    });
    function rb(a2, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
    }
    function sb(a2, b2) {
      a2 = a2.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
        }
    }
    var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a2, b2) {
      if (b2) {
        if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(p$5(137, a2));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(p$5(60));
          if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
            throw Error(p$5(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(p$5(62));
      }
    }
    function vb(a2, b2) {
      if (-1 === a2.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a2) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a2) {
      a2 = a2.target || a2.srcElement || window;
      a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
      return 3 === a2.nodeType ? a2.parentNode : a2;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a2) {
      if (a2 = Cb(a2)) {
        if ("function" !== typeof yb)
          throw Error(p$5(280));
        var b2 = a2.stateNode;
        b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
      }
    }
    function Eb(a2) {
      zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
    }
    function Fb() {
      if (zb) {
        var a2 = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a2);
        if (b2)
          for (a2 = 0; a2 < b2.length; a2++)
            Bb(b2[a2]);
      }
    }
    function Gb(a2, b2) {
      return a2(b2);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a2, b2, c2) {
      if (Ib)
        return a2(b2, c2);
      Ib = true;
      try {
        return Gb(a2, b2, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a2, b2) {
      var c2 = a2.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
            a2 = !d2;
            break a;
          default:
            a2 = false;
        }
      if (a2)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$5(231, b2, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a2) {
        Lb = false;
      }
    function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
      Ob = true;
      Pb = a2;
    } };
    function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$5(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a2) {
      var b2 = a2, c2 = a2;
      if (a2.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a2 = b2;
        do
          b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
        while (a2);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function Wb(a2) {
      if (13 === a2.tag) {
        var b2 = a2.memoizedState;
        null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function Xb(a2) {
      if (Vb(a2) !== a2)
        throw Error(p$5(188));
    }
    function Yb(a2) {
      var b2 = a2.alternate;
      if (!b2) {
        b2 = Vb(a2);
        if (null === b2)
          throw Error(p$5(188));
        return b2 !== a2 ? null : a2;
      }
      for (var c2 = a2, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a2;
            if (f2 === d2)
              return Xb(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(p$5(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$5(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(p$5(190));
      }
      if (3 !== c2.tag)
        throw Error(p$5(188));
      return c2.stateNode.current === c2 ? a2 : b2;
    }
    function Zb(a2) {
      a2 = Yb(a2);
      return null !== a2 ? $b(a2) : null;
    }
    function $b(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2;
      for (a2 = a2.child; null !== a2; ) {
        var b2 = $b(a2);
        if (null !== b2)
          return b2;
        a2 = a2.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a2) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
        } catch (b2) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a2) {
      a2 >>>= 0;
      return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a2) {
      switch (a2 & -a2) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a2 & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a2 & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a2;
      }
    }
    function uc(a2, b2) {
      var c2 = a2.pendingLanes;
      if (0 === c2)
        return 0;
      var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
      if (0 === d2)
        return 0;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b2;
      0 !== (d2 & 4) && (d2 |= c2 & 16);
      b2 = a2.entangledLanes;
      if (0 !== b2)
        for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
      return d2;
    }
    function vc(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 4:
          return b2 + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b2 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a2, b2) {
      for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d2))
            e2[g2] = vc(h2, b2);
        } else
          k2 <= b2 && (a2.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a2 = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a2;
    }
    function zc(a2) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a2);
      return b2;
    }
    function Ac(a2, b2, c2) {
      a2.pendingLanes |= b2;
      536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
      a2 = a2.eventTimes;
      b2 = 31 - oc(b2);
      a2[b2] = c2;
    }
    function Bc(a2, b2) {
      var c2 = a2.pendingLanes & ~b2;
      a2.pendingLanes = b2;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= b2;
      a2.mutableReadLanes &= b2;
      a2.entangledLanes &= b2;
      b2 = a2.entanglements;
      var d2 = a2.eventTimes;
      for (a2 = a2.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b2[e2] = 0;
        d2[e2] = -1;
        a2[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a2, b2) {
      var c2 = a2.entangledLanes |= b2;
      for (a2 = a2.entanglements; c2; ) {
        var d2 = 31 - oc(c2), e2 = 1 << d2;
        e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
        c2 &= ~e2;
      }
    }
    var C = 0;
    function Dc(a2) {
      a2 &= -a2;
      return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a2, b2) {
      switch (a2) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b2.pointerId);
      }
    }
    function Tc(a2, b2, c2, d2, e2, f2) {
      if (null === a2 || a2.nativeEvent !== f2)
        return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
      a2.eventSystemFlags |= d2;
      b2 = a2.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a2;
    }
    function Uc(a2, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function Vc(a2) {
      var b2 = Wc(a2.target);
      if (null !== b2) {
        var c2 = Vb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = Wb(c2), null !== b2) {
              a2.blockedOn = b2;
              Ic(a2.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
            a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a2.blockedOn = null;
    }
    function Xc(a2) {
      if (null !== a2.blockedOn)
        return false;
      for (var b2 = a2.targetContainers; 0 < b2.length; ) {
        var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
        if (null === c2) {
          c2 = a2.nativeEvent;
          var d2 = new c2.constructor(c2.type, c2);
          wb = d2;
          c2.target.dispatchEvent(d2);
          wb = null;
        } else
          return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function Zc(a2, b2, c2) {
      Xc(a2) && c2.delete(b2);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a2, b2) {
      a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a2) {
      function b2(b3) {
        return ad(b3, a2);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a2);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d2 = Kc[c2];
          d2.blockedOn === a2 && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a2);
      null !== Mc && ad(Mc, a2);
      null !== Nc && ad(Nc, a2);
      Oc.forEach(b2);
      Pc.forEach(b2);
      for (c2 = 0; c2 < Qc.length; c2++)
        d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a2, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a2, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function gd(a2, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a2, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function fd(a2, b2, c2, d2) {
      if (dd) {
        var e2 = Yc(a2, b2, c2, d2);
        if (null === e2)
          hd(a2, b2, d2, id, c2), Sc(a2, d2);
        else if (Uc(e2, a2, b2, c2, d2))
          d2.stopPropagation();
        else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a2, b2, c2, d2);
            null === f2 && hd(a2, b2, d2, id, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d2.stopPropagation();
        } else
          hd(a2, b2, d2, null, c2);
      }
    }
    var id = null;
    function Yc(a2, b2, c2, d2) {
      id = null;
      a2 = xb(d2);
      a2 = Wc(a2);
      if (null !== a2)
        if (b2 = Vb(a2), null === b2)
          a2 = null;
        else if (c2 = b2.tag, 13 === c2) {
          a2 = Wb(b2);
          if (null !== a2)
            return a2;
          a2 = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated)
            return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a2 = null;
        } else
          b2 !== a2 && (a2 = null);
      id = a2;
      return null;
    }
    function jd(a2) {
      switch (a2) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
        ;
      var g2 = c2 - a2;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a2) {
      var b2 = a2.keyCode;
      "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
      10 === a2 && (a2 = 13);
      return 32 <= a2 || 13 === a2 ? a2 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a2) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a2)
          a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A$2(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a3 = this.nativeEvent;
        a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a3 = this.nativeEvent;
        a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
      return a2.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
      return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
    }, movementX: function(a2) {
      if ("movementX" in a2)
        return a2.movementX;
      a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
      return wd;
    }, movementY: function(a2) {
      return "movementY" in a2 ? a2.movementY : xd;
    } }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$2({}, sd, { clipboardData: function(a2) {
      return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a2) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A$2({}, ud, { key: function(a2) {
      if (a2.key) {
        var b2 = Md[a2.key] || a2.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
      return "keypress" === a2.type ? od(a2) : 0;
    }, keyCode: function(a2) {
      return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    }, which: function(a2) {
      return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
      deltaX: function(a2) {
        return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
      },
      deltaY: function(a2) {
        return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a2, b2) {
      switch (a2) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a2) {
      a2 = a2.detail;
      return "object" === typeof a2 && "data" in a2 ? a2.data : null;
    }
    var ie = false;
    function je(a2, b2) {
      switch (a2) {
        case "compositionend":
          return he(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a2 = b2.data, a2 === ee && fe ? null : a2;
        default:
          return null;
      }
    }
    function ke(a2, b2) {
      if (ie)
        return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
      switch (a2) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a2) {
      var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
    }
    function ne(a2, b2, c2, d2) {
      Eb(d2);
      b2 = oe(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
    }
    var pe = null, qe = null;
    function re(a2) {
      se(a2, 0);
    }
    function te(a2) {
      var b2 = ue(a2);
      if (Wa(b2))
        return a2;
    }
    function ve(a2, b2) {
      if ("change" === a2)
        return b2;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a2) {
      if ("value" === a2.propertyName && te(qe)) {
        var b2 = [];
        ne(b2, qe, a2, xb(a2));
        Jb(re, b2);
      }
    }
    function Ce(a2, b2, c2) {
      "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
    }
    function De(a2) {
      if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
        return te(qe);
    }
    function Ee(a2, b2) {
      if ("click" === a2)
        return te(b2);
    }
    function Fe(a2, b2) {
      if ("input" === a2 || "change" === a2)
        return te(b2);
    }
    function Ge(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a2, b2) {
      if (He(a2, b2))
        return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a2), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
          return false;
      }
      return true;
    }
    function Je(a2) {
      for (; a2 && a2.firstChild; )
        a2 = a2.firstChild;
      return a2;
    }
    function Ke(a2, b2) {
      var c2 = Je(a2);
      a2 = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a2 + c2.textContent.length;
          if (a2 <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a2 };
          a2 = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le(a2, b2) {
      return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Me() {
      for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a2 = b2.contentWindow;
        else
          break;
        b2 = Xa(a2.document);
      }
      return b2;
    }
    function Ne(a2) {
      var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
    }
    function Oe(a2) {
      var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
      if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
        if (null !== d2 && Ne(c2)) {
          if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
            c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
          else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
            a2 = a2.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
            d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
            !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
            e2 = Ke(c2, f2);
            var g2 = Ke(
              c2,
              d2
            );
            e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
          }
        }
        b2 = [];
        for (a2 = c2; a2 = a2.parentNode; )
          1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b2.length; c2++)
          a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a2, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
    }
    function Ve(a2, b2) {
      var c2 = {};
      c2[a2.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a2] = "webkit" + b2;
      c2["Moz" + a2] = "moz" + b2;
      return c2;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a2) {
      if (Xe[a2])
        return Xe[a2];
      if (!We[a2])
        return a2;
      var b2 = We[a2], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Ye)
          return Xe[a2] = b2[c2];
      return a2;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a2, b2) {
      df.set(a2, b2);
      fa(b2, [a2]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a2, b2, c2) {
      var d2 = a2.type || "unknown-event";
      a2.currentTarget = c2;
      Ub(d2, b2, void 0, a2);
      a2.currentTarget = null;
    }
    function se(a2, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a2.length; c2++) {
        var d2 = a2[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a2 = Rb, Qb = false, Rb = null, a2;
    }
    function D$1(a2, b2) {
      var c2 = b2[of];
      void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
      var d2 = a2 + "__bubble";
      c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
    }
    function qf(a2, b2, c2) {
      var d2 = 0;
      b2 && (d2 |= 4);
      pf(c2, a2, d2, b2);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a2) {
      if (!a2[rf]) {
        a2[rf] = true;
        da.forEach(function(b3) {
          "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
        });
        var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
        null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
      }
    }
    function pf(a2, b2, c2, d2) {
      switch (jd(b2)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b2, c2, a2);
      e2 = void 0;
      !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
    }
    function hd(a2, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Jb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a2);
          if (void 0 !== h3) {
            var k3 = td, n2 = a2;
            switch (a2) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d3, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a2 || "pointerover" === a2;
            k3 = "mouseout" === a2 || "pointerout" === a2;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d3;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a2 || "pointerover" === a2)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue(k3);
                u2 = null == n2 ? h3 : ue(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a2, d3))) {
              ne(g3, na, c2, e3);
              break a;
            }
            xa && xa(a2, h3, d3);
            "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d3 ? ue(d3) : window;
          switch (a2) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe = xa, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c2, e3);
          }
          var $a;
          if (ae)
            b: {
              switch (a2) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a2, c2) : ke(a2, c2))
            d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
        }
        se(g3, b2);
      });
    }
    function tf(a2, b2, c2) {
      return { instance: a2, listener: b2, currentTarget: c2 };
    }
    function oe(a2, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
        var e2 = a2, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
        a2 = a2.return;
      }
      return d2;
    }
    function vf(a2) {
      if (null === a2)
        return null;
      do
        a2 = a2.return;
      while (a2 && 5 !== a2.tag);
      return a2 ? a2 : null;
    }
    function wf(a2, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a2.push({ event: b2, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a2) {
      return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
    }
    function Af(a2, b2, c2) {
      b2 = zf(b2);
      if (zf(a2) !== b2 && c2)
        throw Error(p$5(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a2, b2) {
      return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
      return Hf.resolve(null).then(a2).catch(If);
    } : Ff;
    function If(a2) {
      setTimeout(function() {
        throw a2;
      });
    }
    function Kf(a2, b2) {
      var c2 = b2, d2 = 0;
      do {
        var e2 = c2.nextSibling;
        a2.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a2.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
        c2 = e2;
      } while (c2);
      bd(b2);
    }
    function Lf(a2) {
      for (; null != a2; a2 = a2.nextSibling) {
        var b2 = a2.nodeType;
        if (1 === b2 || 3 === b2)
          break;
        if (8 === b2) {
          b2 = a2.data;
          if ("$" === b2 || "$!" === b2 || "$?" === b2)
            break;
          if ("/$" === b2)
            return null;
        }
      }
      return a2;
    }
    function Mf(a2) {
      a2 = a2.previousSibling;
      for (var b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a2;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a2 = a2.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a2) {
      var b2 = a2[Of];
      if (b2)
        return b2;
      for (var c2 = a2.parentNode; c2; ) {
        if (b2 = c2[uf] || c2[Of]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a2 = Mf(a2); null !== a2; ) {
              if (c2 = a2[Of])
                return c2;
              a2 = Mf(a2);
            }
          return b2;
        }
        a2 = c2;
        c2 = a2.parentNode;
      }
      return null;
    }
    function Cb(a2) {
      a2 = a2[Of] || a2[uf];
      return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
    }
    function ue(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2.stateNode;
      throw Error(p$5(33));
    }
    function Db(a2) {
      return a2[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a2) {
      return { current: a2 };
    }
    function E$1(a2) {
      0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G$1(a2, b2) {
      Tf++;
      Sf[Tf] = a2.current;
      a2.current = b2;
    }
    var Vf = {}, H$1 = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a2, b2) {
      var c2 = a2.type.contextTypes;
      if (!c2)
        return Vf;
      var d2 = a2.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function $f() {
      E$1(Wf);
      E$1(H$1);
    }
    function ag(a2, b2, c2) {
      if (H$1.current !== Vf)
        throw Error(p$5(168));
      G$1(H$1, b2);
      G$1(Wf, c2);
    }
    function bg(a2, b2, c2) {
      var d2 = a2.stateNode;
      b2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in b2))
          throw Error(p$5(108, Ra(a2) || "Unknown", e2));
      return A$2({}, c2, d2);
    }
    function cg(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H$1.current;
      G$1(H$1, a2);
      G$1(Wf, Wf.current);
      return true;
    }
    function dg(a2, b2, c2) {
      var d2 = a2.stateNode;
      if (!d2)
        throw Error(p$5(169));
      c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$1), G$1(H$1, a2)) : E$1(Wf);
      G$1(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a2) {
      null === eg ? eg = [a2] : eg.push(a2);
    }
    function ig(a2) {
      fg = true;
      hg(a2);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a2 = 0, b2 = C;
        try {
          var c2 = eg;
          for (C = 1; a2 < c2.length; a2++) {
            var d2 = c2[a2];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
        } finally {
          C = b2, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a2, b2) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a2;
      ng = b2;
    }
    function ug(a2, b2, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a2;
      var d2 = rg;
      a2 = sg;
      var e2 = 32 - oc(d2) - 1;
      d2 &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b2) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d2 & (1 << g2) - 1).toString(32);
        d2 >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
        sg = f2 + a2;
      } else
        rg = 1 << f2 | c2 << e2 | d2, sg = a2;
    }
    function vg(a2) {
      null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
    }
    function wg(a2) {
      for (; a2 === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a2 === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I$1 = false, zg = null;
    function Ag(a2, b2) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b2;
      c2.return = a2;
      b2 = a2.deletions;
      null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
    }
    function Cg(a2, b2) {
      switch (a2.tag) {
        case 5:
          var c2 = a2.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
        case 6:
          return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
        case 13:
          return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a2) {
      return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
    }
    function Eg(a2) {
      if (I$1) {
        var b2 = yg;
        if (b2) {
          var c2 = b2;
          if (!Cg(a2, b2)) {
            if (Dg(a2))
              throw Error(p$5(418));
            b2 = Lf(c2.nextSibling);
            var d2 = xg;
            b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
          }
        } else {
          if (Dg(a2))
            throw Error(p$5(418));
          a2.flags = a2.flags & -4097 | 2;
          I$1 = false;
          xg = a2;
        }
      }
    }
    function Fg(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
        a2 = a2.return;
      xg = a2;
    }
    function Gg(a2) {
      if (a2 !== xg)
        return false;
      if (!I$1)
        return Fg(a2), I$1 = true, false;
      var b2;
      (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
      if (b2 && (b2 = yg)) {
        if (Dg(a2))
          throw Hg(), Error(p$5(418));
        for (; b2; )
          Ag(a2, b2), b2 = Lf(b2.nextSibling);
      }
      Fg(a2);
      if (13 === a2.tag) {
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2)
          throw Error(p$5(317));
        a: {
          a2 = a2.nextSibling;
          for (b2 = 0; a2; ) {
            if (8 === a2.nodeType) {
              var c2 = a2.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  yg = Lf(a2.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a2 = a2.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a2.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a2 = yg; a2; )
        a2 = Lf(a2.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I$1 = false;
    }
    function Jg(a2) {
      null === zg ? zg = [a2] : zg.push(a2);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a2, b2) {
      if (a2 && a2.defaultProps) {
        b2 = A$2({}, b2);
        a2 = a2.defaultProps;
        for (var c2 in a2)
          void 0 === b2[c2] && (b2[c2] = a2[c2]);
        return b2;
      }
      return b2;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a2) {
      var b2 = Mg.current;
      E$1(Mg);
      a2._currentValue = b2;
    }
    function Sg(a2, b2, c2) {
      for (; null !== a2; ) {
        var d2 = a2.alternate;
        (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
        if (a2 === c2)
          break;
        a2 = a2.return;
      }
    }
    function Tg(a2, b2) {
      Ng = a2;
      Pg = Og = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
    }
    function Vg(a2) {
      var b2 = a2._currentValue;
      if (Pg !== a2)
        if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p$5(308));
          Og = a2;
          Ng.dependencies = { lanes: 0, firstContext: a2 };
        } else
          Og = Og.next = a2;
      return b2;
    }
    var Wg = null;
    function Xg(a2) {
      null === Wg ? Wg = [a2] : Wg.push(a2);
    }
    function Yg(a2, b2, c2, d2) {
      var e2 = b2.interleaved;
      null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
      b2.interleaved = c2;
      return Zg(a2, d2);
    }
    function Zg(a2, b2) {
      a2.lanes |= b2;
      var c2 = a2.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a2;
      for (a2 = a2.return; null !== a2; )
        a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var $g = false;
    function ah(a2) {
      a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a2, b2) {
      a2 = a2.updateQueue;
      b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
    }
    function ch(a2, b2) {
      return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a2, b2, c2) {
      var d2 = a2.updateQueue;
      if (null === d2)
        return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e2 = d2.pending;
        null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
        d2.pending = b2;
        return Zg(a2, c2);
      }
      e2 = d2.interleaved;
      null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
      d2.interleaved = b2;
      return Zg(a2, c2);
    }
    function eh(a2, b2, c2) {
      b2 = b2.updateQueue;
      if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
        var d2 = b2.lanes;
        d2 &= a2.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a2, c2);
      }
    }
    function fh(a2, b2) {
      var c2 = a2.updateQueue, d2 = a2.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a2.updateQueue = c2;
        return;
      }
      a2 = c2.lastBaseUpdate;
      null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function gh(a2, b2, c2, d2) {
      var e2 = a2.updateQueue;
      $g = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a2.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d2 & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a2, t2 = h2;
              r2 = b2;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A$2({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b2 = e2.shared.interleaved;
        if (null !== b2) {
          e2 = b2;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b2);
        } else
          null === f2 && (e2.shared.lanes = 0);
        hh |= g2;
        a2.lanes = g2;
        a2.memoizedState = q2;
      }
    }
    function ih(a2, b2, c2) {
      a2 = b2.effects;
      b2.effects = null;
      if (null !== a2)
        for (b2 = 0; b2 < a2.length; b2++) {
          var d2 = a2[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(p$5(191, e2));
            e2.call(d2);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a2, b2, c2, d2) {
      b2 = a2.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : A$2({}, b2, c2);
      a2.memoizedState = c2;
      0 === a2.lanes && (a2.updateQueue.baseState = c2);
    }
    var nh = { isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
    }, enqueueSetState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = L$1(), e2 = lh(a2), f2 = ch(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a2, f2, e2);
      null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
    }, enqueueReplaceState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = L$1(), e2 = lh(a2), f2 = ch(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a2, f2, e2);
      null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
    }, enqueueForceUpdate: function(a2, b2) {
      a2 = a2._reactInternals;
      var c2 = L$1(), d2 = lh(a2), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a2, e2, d2);
      null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
    } };
    function oh(a2, b2, c2, d2, e2, f2, g2) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
    }
    function ph(a2, b2, c2) {
      var d2 = false, e2 = Vf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
      b2 = new b2(c2, f2);
      a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = nh;
      a2.stateNode = b2;
      b2._reactInternals = a2;
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function qh(a2, b2, c2, d2) {
      a2 = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
    }
    function rh(a2, b2, c2, d2) {
      var e2 = a2.stateNode;
      e2.props = c2;
      e2.state = a2.memoizedState;
      e2.refs = jh;
      ah(a2);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$1.current, e2.context = Yf(a2, f2));
      e2.state = a2.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
      "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
    }
    function sh(a2, b2, c2) {
      a2 = c2.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$5(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(p$5(147, a2));
          var e2 = d2, f2 = "" + a2;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
            return b2.ref;
          b2 = function(a3) {
            var b3 = e2.refs;
            b3 === jh && (b3 = e2.refs = {});
            null === a3 ? delete b3[f2] : b3[f2] = a3;
          };
          b2._stringRef = f2;
          return b2;
        }
        if ("string" !== typeof a2)
          throw Error(p$5(284));
        if (!c2._owner)
          throw Error(p$5(290, a2));
      }
      return a2;
    }
    function th(a2, b2) {
      a2 = Object.prototype.toString.call(b2);
      throw Error(p$5(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
    }
    function uh(a2) {
      var b2 = a2._init;
      return b2(a2._payload);
    }
    function vh(a2) {
      function b2(b3, c3) {
        if (a2) {
          var d3 = b3.deletions;
          null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
        }
      }
      function c2(c3, d3) {
        if (!a2)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a3, b3) {
        for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
        return a3;
      }
      function e2(a3, b3) {
        a3 = wh(a3, b3);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a2)
          return b3.flags |= 1048576, c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
        b3.flags |= 2;
        return c3;
      }
      function g2(b3) {
        a2 && null === b3.alternate && (b3.flags |= 2);
        return b3;
      }
      function h2(a3, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function k2(a3, b3, c3, d3) {
        var f3 = c3.type;
        if (f3 === ya)
          return m2(a3, b3, c3.props.children, d3, c3.key);
        if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
          return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
        d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
        d3.ref = sh(a3, b3, c3);
        d3.return = a3;
        return d3;
      }
      function l2(a3, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a3;
        return b3;
      }
      function m2(a3, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function q2(a3, b3, c3) {
        if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
          return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case va:
              return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
            case wa:
              return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
            case Ha:
              var d3 = b3._init;
              return q2(a3, d3(b3._payload), c3);
          }
          if (eb(b3) || Ka(b3))
            return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
          th(a3, b3);
        }
        return null;
      }
      function r2(a3, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
            case wa:
              return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
            case Ha:
              return e3 = c3._init, r2(
                a3,
                b3,
                e3(c3._payload),
                d3
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a3, b3, c3, d3, null);
          th(a3, c3);
        }
        return null;
      }
      function y2(a3, b3, c3, d3, e3) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
          return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
            case wa:
              return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
            case Ha:
              var f3 = d3._init;
              return y2(a3, b3, c3, f3(d3._payload), e3);
          }
          if (eb(d3) || Ka(d3))
            return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
          th(b3, d3);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a2 && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I$1 && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I$1 && tg(e3, w2);
          return l3;
        }
        for (u2 = d2(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a2 && u2.forEach(function(a3) {
          return b2(e3, a3);
        });
        I$1 && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$5(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$5(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a2 && m3 && null === t3.alternate && b2(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I$1 && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I$1 && tg(e3, w2);
          return l3;
        }
        for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a2 && m3.forEach(function(a3) {
          return b2(e3, a3);
        });
        I$1 && tg(e3, w2);
        return l3;
      }
      function J2(a3, d3, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a3, l3.sibling);
                        d3 = e2(l3, f3.props.children);
                        d3.return = a3;
                        a3 = d3;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                      c2(a3, l3.sibling);
                      d3 = e2(l3, f3.props);
                      d3.ref = sh(a3, l3, f3);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                    c2(a3, l3);
                    break;
                  } else
                    b2(a3, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
              }
              return g2(a3);
            case wa:
              a: {
                for (l3 = f3.key; null !== d3; ) {
                  if (d3.key === l3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a3, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    } else {
                      c2(a3, d3);
                      break;
                    }
                  else
                    b2(a3, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f3, a3.mode, h3);
                d3.return = a3;
                a3 = d3;
              }
              return g2(a3);
            case Ha:
              return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a3, d3, f3, h3);
          if (Ka(f3))
            return t2(a3, d3, f3, h3);
          th(a3, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
      }
      return J2;
    }
    var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a2) {
      if (a2 === Dh)
        throw Error(p$5(174));
      return a2;
    }
    function Ih(a2, b2) {
      G$1(Gh, b2);
      G$1(Fh, a2);
      G$1(Eh, Dh);
      a2 = b2.nodeType;
      switch (a2) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
          break;
        default:
          a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
      }
      E$1(Eh);
      G$1(Eh, b2);
    }
    function Jh() {
      E$1(Eh);
      E$1(Fh);
      E$1(Gh);
    }
    function Kh(a2) {
      Hh(Gh.current);
      var b2 = Hh(Eh.current);
      var c2 = lb(b2, a2.type);
      b2 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
    }
    function Lh(a2) {
      Fh.current === a2 && (E$1(Eh), E$1(Fh));
    }
    var M$1 = Uf(0);
    function Mh(a2) {
      for (var b2 = a2; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 128))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a2)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a2 = 0; a2 < Nh.length; a2++)
        Nh[a2]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O$1 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q$1() {
      throw Error(p$5(321));
    }
    function Wh(a2, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
        if (!He(a2[c2], b2[c2]))
          return false;
      return true;
    }
    function Xh(a2, b2, c2, d2, e2, f2) {
      Rh = f2;
      N$1 = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
      a2 = c2(d2, e2);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p$5(301));
          f2 += 1;
          P$1 = O$1 = null;
          b2.updateQueue = null;
          Ph.current = $h;
          a2 = c2(d2, e2);
        } while (Th);
      }
      Ph.current = ai;
      b2 = null !== O$1 && null !== O$1.next;
      Rh = 0;
      P$1 = O$1 = N$1 = null;
      Sh = false;
      if (b2)
        throw Error(p$5(300));
      return a2;
    }
    function bi() {
      var a2 = 0 !== Uh;
      Uh = 0;
      return a2;
    }
    function ci() {
      var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P$1 ? N$1.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
      return P$1;
    }
    function di() {
      if (null === O$1) {
        var a2 = N$1.alternate;
        a2 = null !== a2 ? a2.memoizedState : null;
      } else
        a2 = O$1.next;
      var b2 = null === P$1 ? N$1.memoizedState : P$1.next;
      if (null !== b2)
        P$1 = b2, O$1 = a2;
      else {
        if (null === a2)
          throw Error(p$5(310));
        O$1 = a2;
        a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
        null === P$1 ? N$1.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
      }
      return P$1;
    }
    function ei(a2, b2) {
      return "function" === typeof b2 ? b2(a2) : b2;
    }
    function fi(a2) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$5(311));
      c2.lastRenderedReducer = a2;
      var d2 = O$1, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
            N$1.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d2 : k2.next = h2;
        He(d2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = d2;
        b2.baseState = g2;
        b2.baseQueue = k2;
        c2.lastRenderedState = d2;
      }
      a2 = c2.interleaved;
      if (null !== a2) {
        e2 = a2;
        do
          f2 = e2.lane, N$1.lanes |= f2, hh |= f2, e2 = e2.next;
        while (e2 !== a2);
      } else
        null === e2 && (c2.lanes = 0);
      return [b2.memoizedState, c2.dispatch];
    }
    function gi(a2) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$5(311));
      c2.lastRenderedReducer = a2;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a2(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function hi() {
    }
    function ii(a2, b2) {
      var c2 = N$1, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
      f2 && (d2.memoizedState = e2, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c2, d2, a2), [a2]);
      if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
        c2.flags |= 2048;
        li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
        if (null === R$1)
          throw Error(p$5(349));
        0 !== (Rh & 30) || ni(c2, b2, e2);
      }
      return e2;
    }
    function ni(a2, b2, c2) {
      a2.flags |= 16384;
      a2 = { getSnapshot: b2, value: c2 };
      b2 = N$1.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
    }
    function mi(a2, b2, c2, d2) {
      b2.value = c2;
      b2.getSnapshot = d2;
      oi(b2) && pi(a2);
    }
    function ki(a2, b2, c2) {
      return c2(function() {
        oi(b2) && pi(a2);
      });
    }
    function oi(a2) {
      var b2 = a2.getSnapshot;
      a2 = a2.value;
      try {
        var c2 = b2();
        return !He(a2, c2);
      } catch (d2) {
        return true;
      }
    }
    function pi(a2) {
      var b2 = Zg(a2, 1);
      null !== b2 && mh(b2, a2, 1, -1);
    }
    function qi(a2) {
      var b2 = ci();
      "function" === typeof a2 && (a2 = a2());
      b2.memoizedState = b2.baseState = a2;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
      b2.queue = a2;
      a2 = a2.dispatch = ri.bind(null, N$1, a2);
      return [b2.memoizedState, a2];
    }
    function li(a2, b2, c2, d2) {
      a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
      b2 = N$1.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
      return a2;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a2, b2, c2, d2) {
      var e2 = ci();
      N$1.flags |= a2;
      e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function ui(a2, b2, c2, d2) {
      var e2 = di();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== O$1) {
        var g2 = O$1.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Wh(d2, g2.deps)) {
          e2.memoizedState = li(b2, c2, f2, d2);
          return;
        }
      }
      N$1.flags |= a2;
      e2.memoizedState = li(1 | b2, c2, f2, d2);
    }
    function vi(a2, b2) {
      return ti(8390656, 8, a2, b2);
    }
    function ji(a2, b2) {
      return ui(2048, 8, a2, b2);
    }
    function wi(a2, b2) {
      return ui(4, 2, a2, b2);
    }
    function xi(a2, b2) {
      return ui(4, 4, a2, b2);
    }
    function yi(a2, b2) {
      if ("function" === typeof b2)
        return a2 = a2(), b2(a2), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a2 = a2(), b2.current = a2, function() {
          b2.current = null;
        };
    }
    function zi(a2, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return ui(4, 4, yi.bind(null, b2, a2), c2);
    }
    function Ai() {
    }
    function Bi(a2, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function Ci(a2, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function Di(a2, b2, c2) {
      if (0 === (Rh & 21))
        return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
      He(c2, b2) || (c2 = yc(), N$1.lanes |= c2, hh |= c2, a2.baseState = true);
      return b2;
    }
    function Ei(a2, b2) {
      var c2 = C;
      C = 0 !== c2 && 4 > c2 ? c2 : 4;
      a2(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a2(false), b2();
      } finally {
        C = c2, Qh.transition = d2;
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a2, b2, c2) {
      var d2 = lh(a2);
      c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a2))
        Ii(b2, c2);
      else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
        var e2 = L$1();
        mh(c2, a2, d2, e2);
        Ji(c2, b2, d2);
      }
    }
    function ri(a2, b2, c2) {
      var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a2))
        Ii(b2, e2);
      else {
        var f2 = a2.alternate;
        if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
          try {
            var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k2 = b2.interleaved;
              null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = Yg(a2, b2, e2, d2);
        null !== c2 && (e2 = L$1(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
      }
    }
    function Hi(a2) {
      var b2 = a2.alternate;
      return a2 === N$1 || null !== b2 && b2 === N$1;
    }
    function Ii(a2, b2) {
      Th = Sh = true;
      var c2 = a2.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a2.pending = b2;
    }
    function Ji(a2, b2, c2) {
      if (0 !== (c2 & 4194240)) {
        var d2 = b2.lanes;
        d2 &= a2.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a2, c2);
      }
    }
    var ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
      ci().memoizedState = [a2, void 0 === b2 ? null : b2];
      return a2;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b2, a2),
        c2
      );
    }, useLayoutEffect: function(a2, b2) {
      return ti(4194308, 4, a2, b2);
    }, useInsertionEffect: function(a2, b2) {
      return ti(4, 2, a2, b2);
    }, useMemo: function(a2, b2) {
      var c2 = ci();
      b2 = void 0 === b2 ? null : b2;
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }, useReducer: function(a2, b2, c2) {
      var d2 = ci();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
      d2.queue = a2;
      a2 = a2.dispatch = Gi.bind(null, N$1, a2);
      return [d2.memoizedState, a2];
    }, useRef: function(a2) {
      var b2 = ci();
      a2 = { current: a2 };
      return b2.memoizedState = a2;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
      return ci().memoizedState = a2;
    }, useTransition: function() {
      var a2 = qi(false), b2 = a2[0];
      a2 = Ei.bind(null, a2[1]);
      ci().memoizedState = a2;
      return [b2, a2];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a2, b2, c2) {
      var d2 = N$1, e2 = ci();
      if (I$1) {
        if (void 0 === c2)
          throw Error(p$5(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R$1)
          throw Error(p$5(349));
        0 !== (Rh & 30) || ni(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b2 };
      e2.queue = f2;
      vi(ki.bind(
        null,
        d2,
        f2,
        a2
      ), [a2]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a2 = ci(), b2 = R$1.identifierPrefix;
      if (I$1) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a2.memoizedState = b2;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a2) {
        var b2 = di();
        return Di(b2, O$1.memoizedState, a2);
      },
      useTransition: function() {
        var a2 = fi(ei)[0], b2 = di().memoizedState;
        return [a2, b2];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a2) {
      var b2 = di();
      return null === O$1 ? b2.memoizedState = a2 : Di(b2, O$1.memoizedState, a2);
    }, useTransition: function() {
      var a2 = gi(ei)[0], b2 = di().memoizedState;
      return [a2, b2];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a2, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Pa(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a2, source: b2, stack: e2, digest: null };
    }
    function Li(a2, b2, c2) {
      return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
    }
    function Mi(a2, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a2, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a2, b2);
      };
      return c2;
    }
    function Ri(a2, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      var d2 = a2.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          return d2(e2);
        };
        c2.callback = function() {
          Mi(a2, b2);
        };
      }
      var f2 = a2.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Mi(a2, b2);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Ti(a2, b2, c2) {
      var d2 = a2.pingCache;
      if (null === d2) {
        d2 = a2.pingCache = new Ni();
        var e2 = /* @__PURE__ */ new Set();
        d2.set(b2, e2);
      } else
        e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
      e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
    }
    function Vi(a2) {
      do {
        var b2;
        if (b2 = 13 === a2.tag)
          b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
        if (b2)
          return a2;
        a2 = a2.return;
      } while (null !== a2);
      return null;
    }
    function Wi(a2, b2, c2, d2, e2) {
      if (0 === (a2.mode & 1))
        return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
      a2.flags |= 65536;
      a2.lanes = e2;
      return a2;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a2, b2, c2, d2) {
      b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
    }
    function Zi(a2, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      Tg(b2, e2);
      d2 = Xh(a2, b2, c2, d2, f2, e2);
      c2 = bi();
      if (null !== a2 && !Ug)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
      I$1 && c2 && vg(b2);
      b2.flags |= 1;
      Yi(a2, b2, d2, e2);
      return b2.child;
    }
    function aj(a2, b2, c2, d2, e2) {
      if (null === a2) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
        a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
        a2.ref = b2.ref;
        a2.return = b2;
        return b2.child = a2;
      }
      f2 = a2.child;
      if (0 === (a2.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie;
        if (c2(g2, d2) && a2.ref === b2.ref)
          return $i(a2, b2, e2);
      }
      b2.flags |= 1;
      a2 = wh(f2, d2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    function cj(a2, b2, c2, d2, e2) {
      if (null !== a2) {
        var f2 = a2.memoizedProps;
        if (Ie(f2, d2) && a2.ref === b2.ref)
          if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
            0 !== (a2.flags & 131072) && (Ug = true);
          else
            return b2.lanes = a2.lanes, $i(a2, b2, e2);
      }
      return dj(a2, b2, c2, d2, e2);
    }
    function ej(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
      if ("hidden" === d2.mode)
        if (0 === (b2.mode & 1))
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a2, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f2 ? f2.baseLanes : c2;
          G$1(fj, gj);
          gj |= d2;
        }
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
      Yi(a2, b2, e2, c2);
      return b2.child;
    }
    function hj(a2, b2) {
      var c2 = b2.ref;
      if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
        b2.flags |= 512, b2.flags |= 2097152;
    }
    function dj(a2, b2, c2, d2, e2) {
      var f2 = Zf(c2) ? Xf : H$1.current;
      f2 = Yf(b2, f2);
      Tg(b2, e2);
      c2 = Xh(a2, b2, c2, d2, f2, e2);
      d2 = bi();
      if (null !== a2 && !Ug)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
      I$1 && d2 && vg(b2);
      b2.flags |= 1;
      Yi(a2, b2, c2, e2);
      return b2.child;
    }
    function ij(a2, b2, c2, d2, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b2);
      } else
        f2 = false;
      Tg(b2, e2);
      if (null === b2.stateNode)
        jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
      else if (null === a2) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$1.current, l2 = Yf(b2, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
        $g = false;
        var r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
      } else {
        g2 = b2.stateNode;
        bh(a2, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
        g2.props = l2;
        q2 = b2.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$1.current, k2 = Yf(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
        $g = false;
        r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        var n2 = b2.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
      }
      return kj(a2, b2, c2, d2, f2, e2);
    }
    function kj(a2, b2, c2, d2, e2, f2) {
      hj(a2, b2);
      var g2 = 0 !== (b2.flags & 128);
      if (!d2 && !g2)
        return e2 && dg(b2, c2, false), $i(a2, b2, f2);
      d2 = b2.stateNode;
      Xi.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dg(b2, c2, true);
      return b2.child;
    }
    function lj(a2) {
      var b2 = a2.stateNode;
      b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
      Ih(a2, b2.containerInfo);
    }
    function mj(a2, b2, c2, d2, e2) {
      Ig();
      Jg(e2);
      b2.flags |= 256;
      Yi(a2, b2, c2, d2);
      return b2.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a2) {
      return { baseLanes: a2, cachePool: null, transitions: null };
    }
    function pj(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b2.flags &= -129;
      else if (null === a2 || null !== a2.memoizedState)
        e2 |= 1;
      G$1(M$1, e2 & 1);
      if (null === a2) {
        Eg(b2);
        a2 = b2.memoizedState;
        if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
          return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
        g2 = d2.children;
        a2 = d2.fallback;
        return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
      }
      e2 = a2.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return sj(a2, b2, g2, d2, h2, e2, c2);
      if (f2) {
        f2 = d2.fallback;
        g2 = b2.mode;
        e2 = a2.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d2.children };
        0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b2;
        d2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        d2 = f2;
        f2 = b2.child;
        g2 = a2.child.memoizedState;
        g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a2.childLanes & ~c2;
        b2.memoizedState = nj;
        return d2;
      }
      f2 = a2.child;
      a2 = f2.sibling;
      d2 = wh(f2, { mode: "visible", children: d2.children });
      0 === (b2.mode & 1) && (d2.lanes = c2);
      d2.return = b2;
      d2.sibling = null;
      null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
      b2.child = d2;
      b2.memoizedState = null;
      return d2;
    }
    function rj(a2, b2) {
      b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
      b2.return = a2;
      return a2.child = b2;
    }
    function tj(a2, b2, c2, d2) {
      null !== d2 && Jg(d2);
      Bh(b2, a2.child, null, c2);
      a2 = rj(b2, b2.pendingProps.children);
      a2.flags |= 2;
      b2.memoizedState = null;
      return a2;
    }
    function sj(a2, b2, c2, d2, e2, f2, g2) {
      if (c2) {
        if (b2.flags & 256)
          return b2.flags &= -257, d2 = Li(Error(p$5(422))), tj(a2, b2, g2, d2);
        if (null !== b2.memoizedState)
          return b2.child = a2.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = Ah(f2, e2, g2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
        b2.child.memoizedState = oj(g2);
        b2.memoizedState = nj;
        return f2;
      }
      if (0 === (b2.mode & 1))
        return tj(a2, b2, g2, null);
      if ("$!" === e2.data) {
        d2 = e2.nextSibling && e2.nextSibling.dataset;
        if (d2)
          var h2 = d2.dgst;
        d2 = h2;
        f2 = Error(p$5(419));
        d2 = Li(f2, d2, void 0);
        return tj(a2, b2, g2, d2);
      }
      h2 = 0 !== (g2 & a2.childLanes);
      if (Ug || h2) {
        d2 = R$1;
        if (null !== d2) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
        }
        uj();
        d2 = Li(Error(p$5(421)));
        return tj(a2, b2, g2, d2);
      }
      if ("$?" === e2.data)
        return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
      a2 = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b2;
      I$1 = true;
      zg = null;
      null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
      b2 = rj(b2, d2.children);
      b2.flags |= 4096;
      return b2;
    }
    function wj(a2, b2, c2) {
      a2.lanes |= b2;
      var d2 = a2.alternate;
      null !== d2 && (d2.lanes |= b2);
      Sg(a2.return, b2, c2);
    }
    function xj(a2, b2, c2, d2, e2) {
      var f2 = a2.memoizedState;
      null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
    }
    function yj(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      Yi(a2, b2, d2.children, c2);
      d2 = M$1.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 128;
      else {
        if (null !== a2 && 0 !== (a2.flags & 128))
          a:
            for (a2 = b2.child; null !== a2; ) {
              if (13 === a2.tag)
                null !== a2.memoizedState && wj(a2, c2, b2);
              else if (19 === a2.tag)
                wj(a2, c2, b2);
              else if (null !== a2.child) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b2)
                break a;
              for (; null === a2.sibling; ) {
                if (null === a2.return || a2.return === b2)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d2 &= 1;
      }
      G$1(M$1, d2);
      if (0 === (b2.mode & 1))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a2 = e2.alternate;
              if (null !== a2 && null === Mh(a2)) {
                b2.child = e2;
                break;
              }
              a2 = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a2;
            }
            xj(b2, true, c2, null, f2);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function jj(a2, b2) {
      0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
    }
    function $i(a2, b2, c2) {
      null !== a2 && (b2.dependencies = a2.dependencies);
      hh |= b2.lanes;
      if (0 === (c2 & b2.childLanes))
        return null;
      if (null !== a2 && b2.child !== a2.child)
        throw Error(p$5(153));
      if (null !== b2.child) {
        a2 = b2.child;
        c2 = wh(a2, a2.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a2.sibling; )
          a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    function zj(a2, b2, c2) {
      switch (b2.tag) {
        case 3:
          lj(b2);
          Ig();
          break;
        case 5:
          Kh(b2);
          break;
        case 1:
          Zf(b2.type) && cg(b2);
          break;
        case 4:
          Ih(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b2.type._context, e2 = b2.memoizedProps.value;
          G$1(Mg, d2._currentValue);
          d2._currentValue = e2;
          break;
        case 13:
          d2 = b2.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated)
              return G$1(M$1, M$1.current & 1), b2.flags |= 128, null;
            if (0 !== (c2 & b2.child.childLanes))
              return pj(a2, b2, c2);
            G$1(M$1, M$1.current & 1);
            a2 = $i(a2, b2, c2);
            return null !== a2 ? a2.sibling : null;
          }
          G$1(M$1, M$1.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a2.flags & 128)) {
            if (d2)
              return yj(a2, b2, c2);
            b2.flags |= 128;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G$1(M$1, M$1.current);
          if (d2)
            break;
          else
            return null;
        case 22:
        case 23:
          return b2.lanes = 0, ej(a2, b2, c2);
      }
      return $i(a2, b2, c2);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a2, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a2.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a2, b2, c2, d2) {
      var e2 = a2.memoizedProps;
      if (e2 !== d2) {
        a2 = b2.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a2, e2);
            d2 = Ya(a2, d2);
            f2 = [];
            break;
          case "select":
            e2 = A$2({}, e2, { value: void 0 });
            d2 = A$2({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a2, e2);
            d2 = gb(a2, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
        }
        ub(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Dj = function(a2, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Ej(a2, b2) {
      if (!I$1)
        switch (a2.tailMode) {
          case "hidden":
            b2 = a2.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a2.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a2.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
        }
    }
    function S$1(a2) {
      var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
      if (b2)
        for (var e2 = a2.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
      else
        for (e2 = a2.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
      a2.subtreeFlags |= d2;
      a2.childLanes = c2;
      return b2;
    }
    function Fj(a2, b2, c2) {
      var d2 = b2.pendingProps;
      wg(b2);
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S$1(b2), null;
        case 1:
          return Zf(b2.type) && $f(), S$1(b2), null;
        case 3:
          d2 = b2.stateNode;
          Jh();
          E$1(Wf);
          E$1(H$1);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a2 || null === a2.child)
            Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a2, b2);
          S$1(b2);
          return null;
        case 5:
          Lh(b2);
          var e2 = Hh(Gh.current);
          c2 = b2.type;
          if (null !== a2 && null != b2.stateNode)
            Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(p$5(166));
              S$1(b2);
              return null;
            }
            a2 = Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[Of] = b2;
              d2[Pf] = f2;
              a2 = 0 !== (b2.mode & 1);
              switch (c2) {
                case "dialog":
                  D$1("cancel", d2);
                  D$1("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D$1("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D$1(lf[e2], d2);
                  break;
                case "source":
                  D$1("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D$1(
                    "error",
                    d2
                  );
                  D$1("load", d2);
                  break;
                case "details":
                  D$1("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  D$1("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  D$1("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), D$1("invalid", d2);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a2
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
                }
              switch (c2) {
                case "input":
                  Va(d2);
                  db(d2, f2, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = Bf);
              }
              d2 = e2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
              "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
              a2[Of] = b2;
              a2[Pf] = d2;
              Aj(a2, b2, false, false);
              b2.stateNode = a2;
              a: {
                g2 = vb(c2, d2);
                switch (c2) {
                  case "dialog":
                    D$1("cancel", a2);
                    D$1("close", a2);
                    e2 = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D$1("load", a2);
                    e2 = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D$1(lf[e2], a2);
                    e2 = d2;
                    break;
                  case "source":
                    D$1("error", a2);
                    e2 = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D$1(
                      "error",
                      a2
                    );
                    D$1("load", a2);
                    e2 = d2;
                    break;
                  case "details":
                    D$1("toggle", a2);
                    e2 = d2;
                    break;
                  case "input":
                    Za(a2, d2);
                    e2 = Ya(a2, d2);
                    D$1("invalid", a2);
                    break;
                  case "option":
                    e2 = d2;
                    break;
                  case "select":
                    a2._wrapperState = { wasMultiple: !!d2.multiple };
                    e2 = A$2({}, d2, { value: void 0 });
                    D$1("invalid", a2);
                    break;
                  case "textarea":
                    hb(a2, d2);
                    e2 = gb(a2, d2);
                    D$1("invalid", a2);
                    break;
                  default:
                    e2 = d2;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va(a2);
                    db(a2, d2, false);
                    break;
                  case "textarea":
                    Va(a2);
                    jb(a2);
                    break;
                  case "option":
                    null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a2.multiple = !!d2.multiple;
                    f2 = d2.value;
                    null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                      a2,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a2.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          }
          S$1(b2);
          return null;
        case 6:
          if (a2 && null != b2.stateNode)
            Dj(a2, b2, a2.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(p$5(166));
            c2 = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.memoizedProps;
              d2[Of] = b2;
              if (f2 = d2.nodeValue !== c2) {
                if (a2 = xg, null !== a2)
                  switch (a2.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                      break;
                    case 5:
                      true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  }
              }
              f2 && (b2.flags |= 4);
            } else
              d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
          }
          S$1(b2);
          return null;
        case 13:
          E$1(M$1);
          d2 = b2.memoizedState;
          if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
            if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
              Hg(), Ig(), b2.flags |= 98560, f2 = false;
            else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
              if (null === a2) {
                if (!f2)
                  throw Error(p$5(318));
                f2 = b2.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$5(317));
                f2[Of] = b2;
              } else
                Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
              S$1(b2);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b2.flags & 65536 ? b2 : null;
          }
          if (0 !== (b2.flags & 128))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b2.updateQueue && (b2.flags |= 4);
          S$1(b2);
          return null;
        case 4:
          return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
        case 10:
          return Rg(b2.type._context), S$1(b2), null;
        case 17:
          return Zf(b2.type) && $f(), S$1(b2), null;
        case 19:
          E$1(M$1);
          f2 = b2.memoizedState;
          if (null === f2)
            return S$1(b2), null;
          d2 = 0 !== (b2.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d2)
              Ej(f2, false);
            else {
              if (0 !== T || null !== a2 && 0 !== (a2.flags & 128))
                for (a2 = b2.child; null !== a2; ) {
                  g2 = Mh(a2);
                  if (null !== g2) {
                    b2.flags |= 128;
                    Ej(f2, false);
                    d2 = g2.updateQueue;
                    null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                    b2.subtreeFlags = 0;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                    G$1(M$1, M$1.current & 1 | 2);
                    return b2.child;
                  }
                  a2 = a2.sibling;
                }
              null !== f2.tail && B$1() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            }
          else {
            if (!d2)
              if (a2 = Mh(g2), null !== a2) {
                if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
                  return S$1(b2), null;
              } else
                2 * B$1() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$1(), b2.sibling = null, c2 = M$1.current, G$1(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
          S$1(b2);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$5(156, b2.tag));
    }
    function Jj(a2, b2) {
      wg(b2);
      switch (b2.tag) {
        case 1:
          return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
        case 3:
          return Jh(), E$1(Wf), E$1(H$1), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
        case 5:
          return Lh(b2), null;
        case 13:
          E$1(M$1);
          a2 = b2.memoizedState;
          if (null !== a2 && null !== a2.dehydrated) {
            if (null === b2.alternate)
              throw Error(p$5(340));
            Ig();
          }
          a2 = b2.flags;
          return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
        case 19:
          return E$1(M$1), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b2.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Mj(a2, b2) {
      var c2 = a2.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d2) {
            W$1(a2, b2, d2);
          }
        else
          c2.current = null;
    }
    function Nj(a2, b2, c2) {
      try {
        c2();
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    }
    var Oj = false;
    function Pj(a2, b2) {
      Cf = dd;
      a2 = Me();
      if (Ne(a2)) {
        if ("selectionStart" in a2)
          var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
        else
          a: {
            c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f2 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a2)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d2 && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a2, selectionRange: c2 };
      dd = false;
      for (V = b2; null !== V; )
        if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
          a2.return = b2, V = a2;
        else
          for (; null !== V; ) {
            b2 = V;
            try {
              var n2 = b2.alternate;
              if (0 !== (b2.flags & 1024))
                switch (b2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b2.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$5(163));
                }
            } catch (F2) {
              W$1(b2, b2.return, F2);
            }
            a2 = b2.sibling;
            if (null !== a2) {
              a2.return = b2.return;
              V = a2;
              break;
            }
            V = b2.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a2, b2, c2) {
      var d2 = b2.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e2 = d2 = d2.next;
        do {
          if ((e2.tag & a2) === a2) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Nj(b2, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d2);
      }
    }
    function Rj(a2, b2) {
      b2 = b2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a2) === a2) {
            var d2 = c2.create;
            c2.destroy = d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Sj(a2) {
      var b2 = a2.ref;
      if (null !== b2) {
        var c2 = a2.stateNode;
        switch (a2.tag) {
          case 5:
            a2 = c2;
            break;
          default:
            a2 = c2;
        }
        "function" === typeof b2 ? b2(a2) : b2.current = a2;
      }
    }
    function Tj(a2) {
      var b2 = a2.alternate;
      null !== b2 && (a2.alternate = null, Tj(b2));
      a2.child = null;
      a2.deletions = null;
      a2.sibling = null;
      5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
      a2.stateNode = null;
      a2.return = null;
      a2.dependencies = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.stateNode = null;
      a2.updateQueue = null;
    }
    function Uj(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function Vj(a2) {
      a:
        for (; ; ) {
          for (; null === a2.sibling; ) {
            if (null === a2.return || Uj(a2.return))
              return null;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
            if (a2.flags & 2)
              continue a;
            if (null === a2.child || 4 === a2.tag)
              continue a;
            else
              a2.child.return = a2, a2 = a2.child;
          }
          if (!(a2.flags & 2))
            return a2.stateNode;
        }
    }
    function Wj(a2, b2, c2) {
      var d2 = a2.tag;
      if (5 === d2 || 6 === d2)
        a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
      else if (4 !== d2 && (a2 = a2.child, null !== a2))
        for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
          Wj(a2, b2, c2), a2 = a2.sibling;
    }
    function Xj(a2, b2, c2) {
      var d2 = a2.tag;
      if (5 === d2 || 6 === d2)
        a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
      else if (4 !== d2 && (a2 = a2.child, null !== a2))
        for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
          Xj(a2, b2, c2), a2 = a2.sibling;
    }
    var X$1 = null, Yj = false;
    function Zj(a2, b2, c2) {
      for (c2 = c2.child; null !== c2; )
        ak(a2, b2, c2), c2 = c2.sibling;
    }
    function ak(a2, b2, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U$1 || Mj(c2, b2);
        case 6:
          var d2 = X$1, e2 = Yj;
          X$1 = null;
          Zj(a2, b2, c2);
          X$1 = d2;
          Yj = e2;
          null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
          break;
        case 4:
          d2 = X$1;
          e2 = Yj;
          X$1 = c2.stateNode.containerInfo;
          Yj = true;
          Zj(a2, b2, c2);
          X$1 = d2;
          Yj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e2 = d2 = d2.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
              e2 = e2.next;
            } while (e2 !== d2);
          }
          Zj(a2, b2, c2);
          break;
        case 1:
          if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
            try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W$1(c2, b2, h2);
            }
          Zj(a2, b2, c2);
          break;
        case 21:
          Zj(a2, b2, c2);
          break;
        case 22:
          c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a2, b2, c2), U$1 = d2) : Zj(a2, b2, c2);
          break;
        default:
          Zj(a2, b2, c2);
      }
    }
    function bk(a2) {
      var b2 = a2.updateQueue;
      if (null !== b2) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        null === c2 && (c2 = a2.stateNode = new Lj());
        b2.forEach(function(b3) {
          var d2 = ck.bind(null, a2, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function dk(a2, b2) {
      var c2 = b2.deletions;
      if (null !== c2)
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f2 = a2, g2 = b2, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X$1 = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X$1 = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X$1 = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X$1)
              throw Error(p$5(160));
            ak(f2, g2, e2);
            X$1 = null;
            Yj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W$1(e2, b2, l2);
          }
        }
      if (b2.subtreeFlags & 12854)
        for (b2 = b2.child; null !== b2; )
          ek(b2, a2), b2 = b2.sibling;
    }
    function ek(a2, b2) {
      var c2 = a2.alternate, d2 = a2.flags;
      switch (a2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b2, a2);
          fk(a2);
          if (d2 & 4) {
            try {
              Qj(3, a2, a2.return), Rj(3, a2);
            } catch (t2) {
              W$1(a2, a2.return, t2);
            }
            try {
              Qj(5, a2, a2.return);
            } catch (t2) {
              W$1(a2, a2.return, t2);
            }
          }
          break;
        case 1:
          dk(b2, a2);
          fk(a2);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          break;
        case 5:
          dk(b2, a2);
          fk(a2);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          if (a2.flags & 32) {
            var e2 = a2.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W$1(a2, a2.return, t2);
            }
          }
          if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
            var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
            a2.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W$1(a2, a2.return, t2);
              }
          }
          break;
        case 6:
          dk(b2, a2);
          fk(a2);
          if (d2 & 4) {
            if (null === a2.stateNode)
              throw Error(p$5(162));
            e2 = a2.stateNode;
            f2 = a2.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W$1(a2, a2.return, t2);
            }
          }
          break;
        case 3:
          dk(b2, a2);
          fk(a2);
          if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b2.containerInfo);
            } catch (t2) {
              W$1(a2, a2.return, t2);
            }
          break;
        case 4:
          dk(b2, a2);
          fk(a2);
          break;
        case 13:
          dk(b2, a2);
          fk(a2);
          e2 = a2.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$1()));
          d2 & 4 && bk(a2);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a2), U$1 = l2) : dk(b2, a2);
          fk(a2);
          if (d2 & 8192) {
            l2 = null !== a2.memoizedState;
            if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
              for (V = a2, m2 = a2.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r2;
                        c2 = r2.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W$1(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a2; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W$1(a2, a2.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W$1(a2, a2.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a2)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a2)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b2, a2);
          fk(a2);
          d2 & 4 && bk(a2);
          break;
        case 21:
          break;
        default:
          dk(
            b2,
            a2
          ), fk(a2);
      }
    }
    function fk(a2) {
      var b2 = a2.flags;
      if (b2 & 2) {
        try {
          a: {
            for (var c2 = a2.return; null !== c2; ) {
              if (Uj(c2)) {
                var d2 = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$5(160));
          }
          switch (d2.tag) {
            case 5:
              var e2 = d2.stateNode;
              d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
              var f2 = Vj(a2);
              Xj(a2, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
              Wj(a2, h2, g2);
              break;
            default:
              throw Error(p$5(161));
          }
        } catch (k2) {
          W$1(a2, a2.return, k2);
        }
        a2.flags &= -3;
      }
      b2 & 4096 && (a2.flags &= -4097);
    }
    function ik(a2, b2, c2) {
      V = a2;
      jk(a2);
    }
    function jk(a2, b2, c2) {
      for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
        var e2 = V, f2 = e2.child;
        if (22 === e2.tag && d2) {
          var g2 = null !== e2.memoizedState || Kj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
            h2 = Kj;
            var l2 = U$1;
            Kj = g2;
            if ((U$1 = k2) && !l2)
              for (V = e2; null !== V; )
                g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
            for (; null !== f2; )
              V = f2, jk(f2), f2 = f2.sibling;
            V = e2;
            Kj = h2;
            U$1 = l2;
          }
          lk(a2);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a2);
      }
    }
    function lk(a2) {
      for (; null !== V; ) {
        var b2 = V;
        if (0 !== (b2.flags & 8772)) {
          var c2 = b2.alternate;
          try {
            if (0 !== (b2.flags & 8772))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U$1 || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U$1)
                    if (null === c2)
                      d2.componentDidMount();
                    else {
                      var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                      d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b2.updateQueue;
                  null !== f2 && ih(b2, f2, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child)
                      switch (b2.child.tag) {
                        case 5:
                          c2 = b2.child.stateNode;
                          break;
                        case 1:
                          c2 = b2.child.stateNode;
                      }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k2 = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$5(163));
              }
            U$1 || b2.flags & 512 && Sj(b2);
          } catch (r2) {
            W$1(b2, b2.return, r2);
          }
        }
        if (b2 === a2) {
          V = null;
          break;
        }
        c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function hk(a2) {
      for (; null !== V; ) {
        var b2 = V;
        if (b2 === a2) {
          V = null;
          break;
        }
        var c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function kk(a2) {
      for (; null !== V; ) {
        var b2 = V;
        try {
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b2.return;
              try {
                Rj(4, b2);
              } catch (k2) {
                W$1(b2, c2, k2);
              }
              break;
            case 1:
              var d2 = b2.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e2 = b2.return;
                try {
                  d2.componentDidMount();
                } catch (k2) {
                  W$1(b2, e2, k2);
                }
              }
              var f2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W$1(b2, f2, k2);
              }
              break;
            case 5:
              var g2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W$1(b2, g2, k2);
              }
          }
        } catch (k2) {
          W$1(b2, b2.return, k2);
        }
        if (b2 === a2) {
          V = null;
          break;
        }
        var h2 = b2.sibling;
        if (null !== h2) {
          h2.return = b2.return;
          V = h2;
          break;
        }
        V = b2.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R$1 = null, Y = null, Z$1 = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L$1() {
      return 0 !== (K & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
    }
    function lh(a2) {
      if (0 === (a2.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z$1)
        return Z$1 & -Z$1;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a2 = C;
      if (0 !== a2)
        return a2;
      a2 = window.event;
      a2 = void 0 === a2 ? 16 : jd(a2.type);
      return a2;
    }
    function mh(a2, b2, c2, d2) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p$5(185));
      Ac(a2, c2, d2);
      if (0 === (K & 2) || a2 !== R$1)
        a2 === R$1 && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a2, Z$1)), Ek(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B$1() + 500, fg && jg());
    }
    function Ek(a2, b2) {
      var c2 = a2.callbackNode;
      wc(a2, b2);
      var d2 = uc(a2, a2 === R$1 ? Z$1 : 0);
      if (0 === d2)
        null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
      else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
        null != c2 && bc(c2);
        if (1 === b2)
          0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Gk(c2, Hk.bind(null, a2));
        }
        a2.callbackPriority = b2;
        a2.callbackNode = c2;
      }
    }
    function Hk(a2, b2) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6))
        throw Error(p$5(327));
      var c2 = a2.callbackNode;
      if (Ik() && a2.callbackNode !== c2)
        return null;
      var d2 = uc(a2, a2 === R$1 ? Z$1 : 0);
      if (0 === d2)
        return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
        b2 = Jk(a2, d2);
      else {
        b2 = d2;
        var e2 = K;
        K |= 2;
        var f2 = Kk();
        if (R$1 !== a2 || Z$1 !== b2)
          vk = null, Hj = B$1() + 500, Lk(a2, b2);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a2, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K = e2;
        null !== Y ? b2 = 0 : (R$1 = null, Z$1 = 0, b2 = T);
      }
      if (0 !== b2) {
        2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
        if (1 === b2)
          throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
        if (6 === b2)
          Dk(a2, d2);
        else {
          e2 = a2.current.alternate;
          if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
            throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
          a2.finishedWork = e2;
          a2.finishedLanes = d2;
          switch (b2) {
            case 0:
            case 1:
              throw Error(p$5(345));
            case 2:
              Qk(a2, uk, vk);
              break;
            case 3:
              Dk(a2, d2);
              if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$1(), 10 < b2)) {
                if (0 !== uc(a2, 0))
                  break;
                e2 = a2.suspendedLanes;
                if ((e2 & d2) !== d2) {
                  L$1();
                  a2.pingedLanes |= a2.suspendedLanes & e2;
                  break;
                }
                a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
                break;
              }
              Qk(a2, uk, vk);
              break;
            case 4:
              Dk(a2, d2);
              if ((d2 & 4194240) === d2)
                break;
              b2 = a2.eventTimes;
              for (e2 = -1; 0 < d2; ) {
                var g2 = 31 - oc(d2);
                f2 = 1 << g2;
                g2 = b2[g2];
                g2 > e2 && (e2 = g2);
                d2 &= ~f2;
              }
              d2 = e2;
              d2 = B$1() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
                break;
              }
              Qk(a2, uk, vk);
              break;
            case 5:
              Qk(a2, uk, vk);
              break;
            default:
              throw Error(p$5(329));
          }
        }
      }
      Ek(a2, B$1());
      return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
    }
    function Ok(a2, b2) {
      var c2 = tk;
      a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
      a2 = Jk(a2, b2);
      2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
      return a2;
    }
    function Gj(a2) {
      null === uk ? uk = a2 : uk.push.apply(uk, a2);
    }
    function Pk(a2) {
      for (var b2 = a2; ; ) {
        if (b2.flags & 16384) {
          var c2 = b2.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b2.child;
        if (b2.subtreeFlags & 16384 && null !== c2)
          c2.return = b2, b2 = c2;
        else {
          if (b2 === a2)
            break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a2)
              return true;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return true;
    }
    function Dk(a2, b2) {
      b2 &= ~sk;
      b2 &= ~rk;
      a2.suspendedLanes |= b2;
      a2.pingedLanes &= ~b2;
      for (a2 = a2.expirationTimes; 0 < b2; ) {
        var c2 = 31 - oc(b2), d2 = 1 << c2;
        a2[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Fk(a2) {
      if (0 !== (K & 6))
        throw Error(p$5(327));
      Ik();
      var b2 = uc(a2, 0);
      if (0 === (b2 & 1))
        return Ek(a2, B$1()), null;
      var c2 = Jk(a2, b2);
      if (0 !== a2.tag && 2 === c2) {
        var d2 = xc(a2);
        0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
      }
      if (1 === c2)
        throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$1()), c2;
      if (6 === c2)
        throw Error(p$5(345));
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b2;
      Qk(a2, uk, vk);
      Ek(a2, B$1());
      return null;
    }
    function Rk(a2, b2) {
      var c2 = K;
      K |= 1;
      try {
        return a2(b2);
      } finally {
        K = c2, 0 === K && (Hj = B$1() + 500, fg && jg());
      }
    }
    function Sk(a2) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b2 = K;
      K |= 1;
      var c2 = pk.transition, d2 = C;
      try {
        if (pk.transition = null, C = 1, a2)
          return a2();
      } finally {
        C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E$1(fj);
    }
    function Lk(a2, b2) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c2 = a2.timeoutHandle;
      -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E$1(Wf);
              E$1(H$1);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E$1(M$1);
              break;
            case 19:
              E$1(M$1);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
      R$1 = a2;
      Y = a2 = wh(a2.current, null);
      Z$1 = gj = b2;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b2 = 0; b2 < Wg.length; b2++)
          if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
        Wg = null;
      }
      return a2;
    }
    function Nk(a2, b2) {
      do {
        var c2 = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N$1.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P$1 = O$1 = N$1 = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c2 || null === c2.return) {
            T = 1;
            qk = b2;
            Y = null;
            break;
          }
          a: {
            var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = Z$1;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g2, h2, f2, b2);
                y2.mode & 1 && Ti(f2, l2, b2);
                b2 = y2;
                k2 = l2;
                var n2 = b2.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b2.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b2 & 1)) {
                  Ti(f2, l2, b2);
                  uj();
                  break a;
                }
                k2 = Error(p$5(426));
              }
            } else if (I$1 && h2.mode & 1) {
              var J2 = Vi(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g2, h2, f2, b2);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T && (T = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var x2 = Oi(f2, k2, b2);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b2 &= -b2;
                    f2.lanes |= b2;
                    var F2 = Ri(f2, h2, b2);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c2);
        } catch (na) {
          b2 = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a2 = nk.current;
      nk.current = ai;
      return null === a2 ? ai : a2;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T)
        T = 4;
      null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$1);
    }
    function Jk(a2, b2) {
      var c2 = K;
      K |= 2;
      var d2 = Kk();
      if (R$1 !== a2 || Z$1 !== b2)
        vk = null, Lk(a2, b2);
      do
        try {
          Uk();
          break;
        } catch (e2) {
          Nk(a2, e2);
        }
      while (1);
      Qg();
      K = c2;
      nk.current = d2;
      if (null !== Y)
        throw Error(p$5(261));
      R$1 = null;
      Z$1 = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; )
        Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); )
        Vk(Y);
    }
    function Vk(a2) {
      var b2 = Wk(a2.alternate, a2, gj);
      a2.memoizedProps = a2.pendingProps;
      null === b2 ? Tk(a2) : Y = b2;
      ok.current = null;
    }
    function Tk(a2) {
      var b2 = a2;
      do {
        var c2 = b2.alternate;
        a2 = b2.return;
        if (0 === (b2.flags & 32768)) {
          if (c2 = Fj(c2, b2, gj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Jj(c2, b2);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a2)
            a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y = b2;
          return;
        }
        Y = b2 = a2;
      } while (null !== b2);
      0 === T && (T = 5);
    }
    function Qk(a2, b2, c2) {
      var d2 = C, e2 = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a2, b2, c2, d2);
      } finally {
        pk.transition = e2, C = d2;
      }
      return null;
    }
    function Xk(a2, b2, c2, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6))
        throw Error(p$5(327));
      c2 = a2.finishedWork;
      var e2 = a2.finishedLanes;
      if (null === c2)
        return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c2 === a2.current)
        throw Error(p$5(177));
      a2.callbackNode = null;
      a2.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a2, f2);
      a2 === R$1 && (Y = R$1 = null, Z$1 = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g2 = C;
        C = 1;
        var h2 = K;
        K |= 4;
        ok.current = null;
        Pj(a2, c2);
        ek(c2, a2);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a2.current = c2;
        ik(c2);
        dc();
        K = h2;
        C = g2;
        pk.transition = f2;
      } else
        a2.current = c2;
      wk && (wk = false, xk = a2, yk = e2);
      f2 = a2.pendingLanes;
      0 === f2 && (Si = null);
      mc(c2.stateNode);
      Ek(a2, B$1());
      if (null !== b2)
        for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
          e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Pi)
        throw Pi = false, a2 = Qi, Qi = null, a2;
      0 !== (yk & 1) && 0 !== a2.tag && Ik();
      f2 = a2.pendingLanes;
      0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a2 = Dc(yk), b2 = pk.transition, c2 = C;
        try {
          pk.transition = null;
          C = 16 > a2 ? 16 : a2;
          if (null === xk)
            var d2 = false;
          else {
            a2 = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6))
              throw Error(p$5(331));
            var e2 = K;
            K |= 4;
            for (V = a2.current; null !== V; ) {
              var f2 = V, g2 = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V = g2;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a2.current;
            for (V = w2; null !== V; ) {
              g2 = V;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V = u2;
              else
                b:
                  for (g2 = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W$1(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a2);
              } catch (na) {
              }
            d2 = true;
          }
          return d2;
        } finally {
          C = c2, pk.transition = b2;
        }
      }
      return false;
    }
    function Yk(a2, b2, c2) {
      b2 = Ki(c2, b2);
      b2 = Oi(a2, b2, 1);
      a2 = dh(a2, b2, 1);
      b2 = L$1();
      null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
    }
    function W$1(a2, b2, c2) {
      if (3 === a2.tag)
        Yk(a2, a2, c2);
      else
        for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a2, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a2 = Ki(c2, a2);
              a2 = Ri(b2, a2, 1);
              b2 = dh(b2, a2, 1);
              a2 = L$1();
              null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
              break;
            }
          }
          b2 = b2.return;
        }
    }
    function Ui(a2, b2, c2) {
      var d2 = a2.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = L$1();
      a2.pingedLanes |= a2.suspendedLanes & c2;
      R$1 === a2 && (Z$1 & c2) === c2 && (4 === T || 3 === T && (Z$1 & 130023424) === Z$1 && 500 > B$1() - gk ? Lk(a2, 0) : sk |= c2);
      Ek(a2, b2);
    }
    function Zk(a2, b2) {
      0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = L$1();
      a2 = Zg(a2, b2);
      null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
    }
    function vj(a2) {
      var b2 = a2.memoizedState, c2 = 0;
      null !== b2 && (c2 = b2.retryLane);
      Zk(a2, c2);
    }
    function ck(a2, b2) {
      var c2 = 0;
      switch (a2.tag) {
        case 13:
          var d2 = a2.stateNode;
          var e2 = a2.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d2 = a2.stateNode;
          break;
        default:
          throw Error(p$5(314));
      }
      null !== d2 && d2.delete(b2);
      Zk(a2, c2);
    }
    var Wk;
    Wk = function(a2, b2, c2) {
      if (null !== a2)
        if (a2.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a2, b2, c2);
          Ug = 0 !== (a2.flags & 131072) ? true : false;
        }
      else
        Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a2, b2);
          a2 = b2.pendingProps;
          var e2 = Yf(b2, H$1.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a2, e2, c2);
          var f2 = bi();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a2, b2);
            a2 = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a2 = Lg(d2, a2);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a2, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a2, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a2, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
                break a;
            }
            throw Error(p$5(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a2)
              throw Error(p$5(387));
            d2 = b2.pendingProps;
            f2 = b2.memoizedState;
            e2 = f2.element;
            bh(a2, b2);
            gh(b2, d2, null, c2);
            var g2 = b2.memoizedState;
            d2 = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
                e2 = Ki(Error(p$5(423)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$5(424)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a2, b2, c2);
                break a;
              }
              Yi(a2, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
        case 6:
          return null === a2 && Eg(b2), null;
        case 13:
          return pj(a2, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
        case 7:
          return Yi(a2, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f2 = b2.memoizedProps;
            g2 = e2.value;
            G$1(Mg, d2._currentValue);
            d2._currentValue = g2;
            if (null !== f2)
              if (He(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b2 = $i(a2, b2, c2);
                  break a;
                }
              } else
                for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d2) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        Sg(
                          f2.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b2.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$5(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g2, c2, b2);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Yi(a2, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
        case 15:
          return cj(a2, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
        case 19:
          return yj(a2, b2, c2);
        case 22:
          return ej(a2, b2, c2);
      }
      throw Error(p$5(156, b2.tag));
    };
    function Gk(a2, b2) {
      return ac(a2, b2);
    }
    function al(a2, b2, c2, d2) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a2, b2, c2, d2) {
      return new al(a2, b2, c2, d2);
    }
    function bj(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function $k(a2) {
      if ("function" === typeof a2)
        return bj(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === Da)
          return 11;
        if (a2 === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a2, b2) {
      var c2 = a2.alternate;
      null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a2.flags & 14680064;
      c2.childLanes = a2.childLanes;
      c2.lanes = a2.lanes;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b2 = a2.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function yh(a2, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a2;
      if ("function" === typeof a2)
        bj(a2) && (g2 = 1);
      else if ("string" === typeof a2)
        g2 = 5;
      else
        a:
          switch (a2) {
            case ya:
              return Ah(c2.children, e2, f2, b2);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
            case Ea:
              return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
            case Fa:
              return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
            case Ia:
              return qj(c2, e2, f2, b2);
            default:
              if ("object" === typeof a2 && null !== a2)
                switch (a2.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha:
                    g2 = 16;
                    d2 = null;
                    break a;
                }
              throw Error(p$5(130, null == a2 ? a2 : typeof a2, ""));
          }
      b2 = Bg(g2, c2, b2, e2);
      b2.elementType = a2;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Ah(a2, b2, c2, d2) {
      a2 = Bg(7, a2, d2, b2);
      a2.lanes = c2;
      return a2;
    }
    function qj(a2, b2, c2, d2) {
      a2 = Bg(22, a2, d2, b2);
      a2.elementType = Ia;
      a2.lanes = c2;
      a2.stateNode = { isHidden: false };
      return a2;
    }
    function xh(a2, b2, c2) {
      a2 = Bg(6, a2, null, b2);
      a2.lanes = c2;
      return a2;
    }
    function zh(a2, b2, c2) {
      b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
      return b2;
    }
    function bl(a2, b2, c2, d2, e2) {
      this.tag = b2;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      a2 = new bl(a2, b2, c2, h2, k2);
      1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
      f2 = Bg(3, null, null, b2);
      a2.current = f2;
      f2.stateNode = a2;
      f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a2;
    }
    function dl(a2, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
    }
    function el(a2) {
      if (!a2)
        return Vf;
      a2 = a2._reactInternals;
      a: {
        if (Vb(a2) !== a2 || 1 !== a2.tag)
          throw Error(p$5(170));
        var b2 = a2;
        do {
          switch (b2.tag) {
            case 3:
              b2 = b2.stateNode.context;
              break a;
            case 1:
              if (Zf(b2.type)) {
                b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b2 = b2.return;
        } while (null !== b2);
        throw Error(p$5(171));
      }
      if (1 === a2.tag) {
        var c2 = a2.type;
        if (Zf(c2))
          return bg(a2, c2, b2);
      }
      return b2;
    }
    function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
      a2.context = el(null);
      c2 = a2.current;
      d2 = L$1();
      e2 = lh(c2);
      f2 = ch(d2, e2);
      f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
      dh(c2, f2, e2);
      a2.current.lanes = e2;
      Ac(a2, e2, d2);
      Ek(a2, d2);
      return a2;
    }
    function gl(a2, b2, c2, d2) {
      var e2 = b2.current, f2 = L$1(), g2 = lh(e2);
      c2 = el(c2);
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = ch(f2, g2);
      b2.payload = { element: a2 };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      a2 = dh(e2, b2, g2);
      null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
      return g2;
    }
    function hl(a2) {
      a2 = a2.current;
      if (!a2.child)
        return null;
      switch (a2.child.tag) {
        case 5:
          return a2.child.stateNode;
        default:
          return a2.child.stateNode;
      }
    }
    function il(a2, b2) {
      a2 = a2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        var c2 = a2.retryLane;
        a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function jl(a2, b2) {
      il(a2, b2);
      (a2 = a2.alternate) && il(a2, b2);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a2) {
      console.error(a2);
    };
    function ml(a2) {
      this._internalRoot = a2;
    }
    nl.prototype.render = ml.prototype.render = function(a2) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$5(409));
      gl(a2, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a2 = this._internalRoot;
      if (null !== a2) {
        this._internalRoot = null;
        var b2 = a2.containerInfo;
        Sk(function() {
          gl(null, a2, null, null);
        });
        b2[uf] = null;
      }
    };
    function nl(a2) {
      this._internalRoot = a2;
    }
    nl.prototype.unstable_scheduleHydration = function(a2) {
      if (a2) {
        var b2 = Hc();
        a2 = { blockedOn: null, target: a2, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a2);
        0 === c2 && Vc(a2);
      }
    };
    function ol(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
    }
    function pl(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
    }
    function ql() {
    }
    function rl(a2, b2, c2, d2, e2) {
      if (e2) {
        if ("function" === typeof d2) {
          var f2 = d2;
          d2 = function() {
            var a3 = hl(g2);
            f2.call(a3);
          };
        }
        var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
        a2._reactRootContainer = g2;
        a2[uf] = g2.current;
        sf(8 === a2.nodeType ? a2.parentNode : a2);
        Sk();
        return g2;
      }
      for (; e2 = a2.lastChild; )
        a2.removeChild(e2);
      if ("function" === typeof d2) {
        var h2 = d2;
        d2 = function() {
          var a3 = hl(k2);
          h2.call(a3);
        };
      }
      var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
      a2._reactRootContainer = k2;
      a2[uf] = k2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Sk(function() {
        gl(b2, k2, c2, d2);
      });
      return k2;
    }
    function sl(a2, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a3 = hl(g2);
            h2.call(a3);
          };
        }
        gl(b2, g2, a2, e2);
      } else
        g2 = rl(c2, b2, a2, e2, d2);
      return hl(g2);
    }
    Ec = function(a2) {
      switch (a2.tag) {
        case 3:
          var b2 = a2.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$1()), 0 === (K & 6) && (Hj = B$1() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a2, 1);
            if (null !== b3) {
              var c3 = L$1();
              mh(b3, a2, 1, c3);
            }
          }), jl(a2, 1);
      }
    };
    Fc = function(a2) {
      if (13 === a2.tag) {
        var b2 = Zg(a2, 134217728);
        if (null !== b2) {
          var c2 = L$1();
          mh(b2, a2, 134217728, c2);
        }
        jl(a2, 134217728);
      }
    };
    Gc = function(a2) {
      if (13 === a2.tag) {
        var b2 = lh(a2), c2 = Zg(a2, b2);
        if (null !== c2) {
          var d2 = L$1();
          mh(c2, a2, b2, d2);
        }
        jl(a2, b2);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a2, b2) {
      var c2 = C;
      try {
        return C = a2, b2();
      } finally {
        C = c2;
      }
    };
    yb = function(a2, b2, c2) {
      switch (b2) {
        case "input":
          bb(a2, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a2; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a2 && d2.form === a2.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$5(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a2, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
      a2 = Zb(a2);
      return null === a2 ? null : a2.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a2) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a2, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$5(200));
      return dl(a2, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a2, b2) {
      if (!ol(a2))
        throw Error(p$5(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
      a2[uf] = b2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a2) {
      if (null == a2)
        return null;
      if (1 === a2.nodeType)
        return a2;
      var b2 = a2._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a2.render)
          throw Error(p$5(188));
        a2 = Object.keys(a2).join(",");
        throw Error(p$5(268, a2));
      }
      a2 = Zb(b2);
      a2 = null === a2 ? null : a2.stateNode;
      return a2;
    };
    reactDom_production_min.flushSync = function(a2) {
      return Sk(a2);
    };
    reactDom_production_min.hydrate = function(a2, b2, c2) {
      if (!pl(b2))
        throw Error(p$5(200));
      return sl(null, a2, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
      if (!ol(a2))
        throw Error(p$5(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a2[uf] = b2.current;
      sf(a2);
      if (d2)
        for (a2 = 0; a2 < d2.length; a2++)
          c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a2, b2, c2) {
      if (!pl(b2))
        throw Error(p$5(200));
      return sl(null, a2, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a2) {
      if (!pl(a2))
        throw Error(p$5(40));
      return a2._reactRootContainer ? (Sk(function() {
        sl(null, null, a2, false, function() {
          a2._reactRootContainer = null;
          a2[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$5(200));
      if (null == a2 || void 0 === a2._reactInternals)
        throw Error(p$5(38));
      return sl(a2, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    var reactDomExports = reactDom.exports;
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    var m$4 = reactDomExports;
    {
      client.createRoot = m$4.createRoot;
      client.hydrateRoot = m$4.hydrateRoot;
    }
    var shim = { exports: {} };
    var useSyncExternalStoreShim_production_min = {};
    /**
     * @license React
     * use-sync-external-store-shim.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var e$2 = reactExports;
    function h$4(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var k$3 = "function" === typeof Object.is ? Object.is : h$4, l$3 = e$2.useState, m$3 = e$2.useEffect, n$4 = e$2.useLayoutEffect, p$4 = e$2.useDebugValue;
    function q$4(a2, b2) {
      var d2 = b2(), f2 = l$3({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
      n$4(function() {
        c2.value = d2;
        c2.getSnapshot = b2;
        r$5(c2) && g2({ inst: c2 });
      }, [a2, d2, b2]);
      m$3(function() {
        r$5(c2) && g2({ inst: c2 });
        return a2(function() {
          r$5(c2) && g2({ inst: c2 });
        });
      }, [a2]);
      p$4(d2);
      return d2;
    }
    function r$5(a2) {
      var b2 = a2.getSnapshot;
      a2 = a2.value;
      try {
        var d2 = b2();
        return !k$3(a2, d2);
      } catch (f2) {
        return true;
      }
    }
    function t$4(a2, b2) {
      return b2();
    }
    var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$4 : q$4;
    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$2.useSyncExternalStore ? e$2.useSyncExternalStore : u$3;
    {
      shim.exports = useSyncExternalStoreShim_production_min;
    }
    var shimExports = shim.exports;
    var withSelector = { exports: {} };
    var withSelector_production_min = {};
    /**
     * @license React
     * use-sync-external-store-shim/with-selector.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var h$3 = reactExports, n$3 = shimExports;
    function p$3(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var q$3 = "function" === typeof Object.is ? Object.is : p$3, r$4 = n$3.useSyncExternalStore, t$3 = h$3.useRef, u$2 = h$3.useEffect, v$3 = h$3.useMemo, w$2 = h$3.useDebugValue;
    withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
      var c2 = t$3(null);
      if (null === c2.current) {
        var f2 = { hasValue: false, value: null };
        c2.current = f2;
      } else
        f2 = c2.current;
      c2 = v$3(function() {
        function a3(a4) {
          if (!c3) {
            c3 = true;
            d3 = a4;
            a4 = l2(a4);
            if (void 0 !== g2 && f2.hasValue) {
              var b3 = f2.value;
              if (g2(b3, a4))
                return k2 = b3;
            }
            return k2 = a4;
          }
          b3 = k2;
          if (q$3(d3, a4))
            return b3;
          var e3 = l2(a4);
          if (void 0 !== g2 && g2(b3, e3))
            return b3;
          d3 = a4;
          return k2 = e3;
        }
        var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
        return [function() {
          return a3(b2());
        }, null === m2 ? void 0 : function() {
          return a3(m2());
        }];
      }, [b2, e2, l2, g2]);
      var d2 = r$4(a2, c2[0], c2[1]);
      u$2(function() {
        f2.hasValue = true;
        f2.value = d2;
      }, [d2]);
      w$2(d2);
      return d2;
    };
    {
      withSelector.exports = withSelector_production_min;
    }
    var withSelectorExports = withSelector.exports;
    function defaultNoopBatch(callback) {
      callback();
    }
    let batch = defaultNoopBatch;
    const setBatch = (newBatch) => batch = newBatch;
    const getBatch = () => batch;
    const ContextKey = Symbol.for(`react-redux-context`);
    const gT = typeof globalThis !== "undefined" ? globalThis : (
      /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
      {}
    );
    function getContext() {
      var _gT$ContextKey;
      if (!reactExports.createContext)
        return {};
      const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();
      let realContext = contextMap.get(reactExports.createContext);
      if (!realContext) {
        realContext = reactExports.createContext(null);
        contextMap.set(reactExports.createContext, realContext);
      }
      return realContext;
    }
    const ReactReduxContext = /* @__PURE__ */ getContext();
    function createReduxContextHook(context = ReactReduxContext) {
      return function useReduxContext2() {
        const contextValue = reactExports.useContext(context);
        return contextValue;
      };
    }
    const useReduxContext = /* @__PURE__ */ createReduxContextHook();
    const notInitialized = () => {
      throw new Error("uSES not initialized!");
    };
    let useSyncExternalStoreWithSelector = notInitialized;
    const initializeUseSelector = (fn2) => {
      useSyncExternalStoreWithSelector = fn2;
    };
    const refEquality = (a2, b2) => a2 === b2;
    function createSelectorHook(context = ReactReduxContext) {
      const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
      return function useSelector2(selector, equalityFnOrOptions = {}) {
        const {
          equalityFn = refEquality,
          stabilityCheck = void 0,
          noopCheck = void 0
        } = typeof equalityFnOrOptions === "function" ? {
          equalityFn: equalityFnOrOptions
        } : equalityFnOrOptions;
        const {
          store: store2,
          subscription,
          getServerState,
          stabilityCheck: globalStabilityCheck,
          noopCheck: globalNoopCheck
        } = useReduxContext$1();
        reactExports.useRef(true);
        const wrappedSelector = reactExports.useCallback({
          [selector.name](state) {
            const selected = selector(state);
            return selected;
          }
        }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store2.getState, getServerState || store2.getState, wrappedSelector, equalityFn);
        reactExports.useDebugValue(selectedState);
        return selectedState;
      };
    }
    const useSelector = /* @__PURE__ */ createSelectorHook();
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var reactIs$1 = { exports: {} };
    var reactIs_production_min$1 = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$2 = "function" === typeof Symbol && Symbol.for, c$2 = b$2 ? Symbol.for("react.element") : 60103, d$2 = b$2 ? Symbol.for("react.portal") : 60106, e$1 = b$2 ? Symbol.for("react.fragment") : 60107, f$2 = b$2 ? Symbol.for("react.strict_mode") : 60108, g$2 = b$2 ? Symbol.for("react.profiler") : 60114, h$2 = b$2 ? Symbol.for("react.provider") : 60109, k$2 = b$2 ? Symbol.for("react.context") : 60110, l$2 = b$2 ? Symbol.for("react.async_mode") : 60111, m$2 = b$2 ? Symbol.for("react.concurrent_mode") : 60111, n$2 = b$2 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$2 ? Symbol.for("react.suspense") : 60113, q$2 = b$2 ? Symbol.for("react.suspense_list") : 60120, r$3 = b$2 ? Symbol.for("react.memo") : 60115, t$2 = b$2 ? Symbol.for("react.lazy") : 60116, v$2 = b$2 ? Symbol.for("react.block") : 60121, w$1 = b$2 ? Symbol.for("react.fundamental") : 60117, x$1 = b$2 ? Symbol.for("react.responder") : 60118, y$1 = b$2 ? Symbol.for("react.scope") : 60119;
    function z$1(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var u2 = a2.$$typeof;
        switch (u2) {
          case c$2:
            switch (a2 = a2.type, a2) {
              case l$2:
              case m$2:
              case e$1:
              case g$2:
              case f$2:
              case p$2:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k$2:
                  case n$2:
                  case t$2:
                  case r$3:
                  case h$2:
                    return a2;
                  default:
                    return u2;
                }
            }
          case d$2:
            return u2;
        }
      }
    }
    function A$1(a2) {
      return z$1(a2) === m$2;
    }
    reactIs_production_min$1.AsyncMode = l$2;
    reactIs_production_min$1.ConcurrentMode = m$2;
    reactIs_production_min$1.ContextConsumer = k$2;
    reactIs_production_min$1.ContextProvider = h$2;
    reactIs_production_min$1.Element = c$2;
    reactIs_production_min$1.ForwardRef = n$2;
    reactIs_production_min$1.Fragment = e$1;
    reactIs_production_min$1.Lazy = t$2;
    reactIs_production_min$1.Memo = r$3;
    reactIs_production_min$1.Portal = d$2;
    reactIs_production_min$1.Profiler = g$2;
    reactIs_production_min$1.StrictMode = f$2;
    reactIs_production_min$1.Suspense = p$2;
    reactIs_production_min$1.isAsyncMode = function(a2) {
      return A$1(a2) || z$1(a2) === l$2;
    };
    reactIs_production_min$1.isConcurrentMode = A$1;
    reactIs_production_min$1.isContextConsumer = function(a2) {
      return z$1(a2) === k$2;
    };
    reactIs_production_min$1.isContextProvider = function(a2) {
      return z$1(a2) === h$2;
    };
    reactIs_production_min$1.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
    };
    reactIs_production_min$1.isForwardRef = function(a2) {
      return z$1(a2) === n$2;
    };
    reactIs_production_min$1.isFragment = function(a2) {
      return z$1(a2) === e$1;
    };
    reactIs_production_min$1.isLazy = function(a2) {
      return z$1(a2) === t$2;
    };
    reactIs_production_min$1.isMemo = function(a2) {
      return z$1(a2) === r$3;
    };
    reactIs_production_min$1.isPortal = function(a2) {
      return z$1(a2) === d$2;
    };
    reactIs_production_min$1.isProfiler = function(a2) {
      return z$1(a2) === g$2;
    };
    reactIs_production_min$1.isStrictMode = function(a2) {
      return z$1(a2) === f$2;
    };
    reactIs_production_min$1.isSuspense = function(a2) {
      return z$1(a2) === p$2;
    };
    reactIs_production_min$1.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === e$1 || a2 === m$2 || a2 === g$2 || a2 === f$2 || a2 === p$2 || a2 === q$2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$2 || a2.$$typeof === r$3 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === n$2 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$2);
    };
    reactIs_production_min$1.typeOf = z$1;
    {
      reactIs$1.exports = reactIs_production_min$1;
    }
    var reactIsExports = reactIs$1.exports;
    var reactIs = reactIsExports;
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    var reactIs_production_min = {};
    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$1 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$1 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f$1 = Symbol.for("react.profiler"), g$1 = Symbol.for("react.provider"), h$1 = Symbol.for("react.context"), k$1 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$1 = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q$1 = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u$1;
    u$1 = Symbol.for("react.module.reference");
    function v$1(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var r2 = a2.$$typeof;
        switch (r2) {
          case b$1:
            switch (a2 = a2.type, a2) {
              case d$1:
              case f$1:
              case e:
              case m$1:
              case n$1:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k$1:
                  case h$1:
                  case l$1:
                  case q$1:
                  case p$1:
                  case g$1:
                    return a2;
                  default:
                    return r2;
                }
            }
          case c$1:
            return r2;
        }
      }
    }
    reactIs_production_min.ContextConsumer = h$1;
    reactIs_production_min.ContextProvider = g$1;
    reactIs_production_min.Element = b$1;
    reactIs_production_min.ForwardRef = l$1;
    reactIs_production_min.Fragment = d$1;
    reactIs_production_min.Lazy = q$1;
    reactIs_production_min.Memo = p$1;
    reactIs_production_min.Portal = c$1;
    reactIs_production_min.Profiler = f$1;
    reactIs_production_min.StrictMode = e;
    reactIs_production_min.Suspense = m$1;
    reactIs_production_min.SuspenseList = n$1;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a2) {
      return v$1(a2) === h$1;
    };
    reactIs_production_min.isContextProvider = function(a2) {
      return v$1(a2) === g$1;
    };
    reactIs_production_min.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$1;
    };
    reactIs_production_min.isForwardRef = function(a2) {
      return v$1(a2) === l$1;
    };
    reactIs_production_min.isFragment = function(a2) {
      return v$1(a2) === d$1;
    };
    reactIs_production_min.isLazy = function(a2) {
      return v$1(a2) === q$1;
    };
    reactIs_production_min.isMemo = function(a2) {
      return v$1(a2) === p$1;
    };
    reactIs_production_min.isPortal = function(a2) {
      return v$1(a2) === c$1;
    };
    reactIs_production_min.isProfiler = function(a2) {
      return v$1(a2) === f$1;
    };
    reactIs_production_min.isStrictMode = function(a2) {
      return v$1(a2) === e;
    };
    reactIs_production_min.isSuspense = function(a2) {
      return v$1(a2) === m$1;
    };
    reactIs_production_min.isSuspenseList = function(a2) {
      return v$1(a2) === n$1;
    };
    reactIs_production_min.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === d$1 || a2 === f$1 || a2 === e || a2 === m$1 || a2 === n$1 || a2 === t$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$1 || a2.$$typeof === p$1 || a2.$$typeof === g$1 || a2.$$typeof === h$1 || a2.$$typeof === l$1 || a2.$$typeof === u$1 || void 0 !== a2.getModuleId) ? true : false;
    };
    reactIs_production_min.typeOf = v$1;
    function createListenerCollection() {
      const batch2 = getBatch();
      let first2 = null;
      let last2 = null;
      return {
        clear() {
          first2 = null;
          last2 = null;
        },
        notify() {
          batch2(() => {
            let listener = first2;
            while (listener) {
              listener.callback();
              listener = listener.next;
            }
          });
        },
        get() {
          let listeners = [];
          let listener = first2;
          while (listener) {
            listeners.push(listener);
            listener = listener.next;
          }
          return listeners;
        },
        subscribe(callback) {
          let isSubscribed = true;
          let listener = last2 = {
            callback,
            next: null,
            prev: last2
          };
          if (listener.prev) {
            listener.prev.next = listener;
          } else {
            first2 = listener;
          }
          return function unsubscribe() {
            if (!isSubscribed || first2 === null)
              return;
            isSubscribed = false;
            if (listener.next) {
              listener.next.prev = listener.prev;
            } else {
              last2 = listener.prev;
            }
            if (listener.prev) {
              listener.prev.next = listener.next;
            } else {
              first2 = listener.next;
            }
          };
        }
      };
    }
    const nullListeners = {
      notify() {
      },
      get: () => []
    };
    function createSubscription(store2, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;
      function addNestedSub(listener) {
        trySubscribe();
        return listeners.subscribe(listener);
      }
      function notifyNestedSubs() {
        listeners.notify();
      }
      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }
      function isSubscribed() {
        return Boolean(unsubscribe);
      }
      function trySubscribe() {
        if (!unsubscribe) {
          unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }
      function tryUnsubscribe() {
        if (unsubscribe) {
          unsubscribe();
          unsubscribe = void 0;
          listeners.clear();
          listeners = nullListeners;
        }
      }
      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe,
        tryUnsubscribe,
        getListeners: () => listeners
      };
      return subscription;
    }
    const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    const useIsomorphicLayoutEffect = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
    function Provider({
      store: store2,
      context,
      children,
      serverState,
      stabilityCheck = "once",
      noopCheck = "once"
    }) {
      const contextValue = reactExports.useMemo(() => {
        const subscription = createSubscription(store2);
        return {
          store: store2,
          subscription,
          getServerState: serverState ? () => serverState : void 0,
          stabilityCheck,
          noopCheck
        };
      }, [store2, serverState, stabilityCheck, noopCheck]);
      const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
      useIsomorphicLayoutEffect(() => {
        const {
          subscription
        } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();
        if (previousState !== store2.getState()) {
          subscription.notifyNestedSubs();
        }
        return () => {
          subscription.tryUnsubscribe();
          subscription.onStateChange = void 0;
        };
      }, [contextValue, previousState]);
      const Context = context || ReactReduxContext;
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value: contextValue
      }, children);
    }
    function createStoreHook(context = ReactReduxContext) {
      const useReduxContext$1 = (
        // @ts-ignore
        context === ReactReduxContext ? useReduxContext : (
          // @ts-ignore
          createReduxContextHook(context)
        )
      );
      return function useStore2() {
        const {
          store: store2
        } = useReduxContext$1();
        return store2;
      };
    }
    const useStore = /* @__PURE__ */ createStoreHook();
    function createDispatchHook(context = ReactReduxContext) {
      const useStore$1 = (
        // @ts-ignore
        context === ReactReduxContext ? useStore : createStoreHook(context)
      );
      return function useDispatch2() {
        const store2 = useStore$1();
        return store2.dispatch;
      };
    }
    const useDispatch = /* @__PURE__ */ createDispatchHook();
    initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
    setBatch(reactDomExports.unstable_batchedUpdates);
    const App$1 = "";
    const common$1 = {
      black: "#000",
      white: "#fff"
    };
    const common$2 = common$1;
    const red = {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000"
    };
    const red$1 = red;
    const purple = {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff"
    };
    const purple$1 = purple;
    const blue = {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff"
    };
    const blue$1 = blue;
    const lightBlue = {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea"
    };
    const lightBlue$1 = lightBlue;
    const green = {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853"
    };
    const green$1 = green;
    const orange = {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00"
    };
    const orange$1 = orange;
    const grey = {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#f5f5f5",
      A200: "#eeeeee",
      A400: "#bdbdbd",
      A700: "#616161"
    };
    const grey$1 = grey;
    function isPlainObject$2(item) {
      return item !== null && typeof item === "object" && item.constructor === Object;
    }
    function deepClone(source) {
      if (!isPlainObject$2(source)) {
        return source;
      }
      const output = {};
      Object.keys(source).forEach((key) => {
        output[key] = deepClone(source[key]);
      });
      return output;
    }
    function deepmerge(target, source, options = {
      clone: true
    }) {
      const output = options.clone ? _extends$1({}, target) : target;
      if (isPlainObject$2(target) && isPlainObject$2(source)) {
        Object.keys(source).forEach((key) => {
          if (key === "__proto__") {
            return;
          }
          if (isPlainObject$2(source[key]) && key in target && isPlainObject$2(target[key])) {
            output[key] = deepmerge(target[key], source[key], options);
          } else if (options.clone) {
            output[key] = isPlainObject$2(source[key]) ? deepClone(source[key]) : source[key];
          } else {
            output[key] = source[key];
          }
        });
      }
      return output;
    }
    var propTypes = { exports: {} };
    var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
    var ReactPropTypesSecret = ReactPropTypesSecret_1;
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    var factoryWithThrowingShims = function() {
      function shim2(props, propName, componentName, location2, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim2.isRequired = shim2;
      function getShim() {
        return shim2;
      }
      var ReactPropTypes = {
        array: shim2,
        bigint: shim2,
        bool: shim2,
        func: shim2,
        number: shim2,
        object: shim2,
        string: shim2,
        symbol: shim2,
        any: shim2,
        arrayOf: getShim,
        element: shim2,
        elementType: shim2,
        instanceOf: getShim,
        node: shim2,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    {
      propTypes.exports = factoryWithThrowingShims();
    }
    var propTypesExports = propTypes.exports;
    const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
    function formatMuiErrorMessage(code) {
      let url = "https://mui.com/production-error/?code=" + code;
      for (let i2 = 1; i2 < arguments.length; i2 += 1) {
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
    }
    function capitalize(string) {
      if (typeof string !== "string") {
        throw new Error(formatMuiErrorMessage(7));
      }
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function createChainedFunction(...funcs) {
      return funcs.reduce((acc, func) => {
        if (func == null) {
          return acc;
        }
        return function chainedFunction(...args) {
          acc.apply(this, args);
          func.apply(this, args);
        };
      }, () => {
      });
    }
    function debounce(func, wait = 166) {
      let timeout;
      function debounced(...args) {
        const later = () => {
          func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      }
      debounced.clear = () => {
        clearTimeout(timeout);
      };
      return debounced;
    }
    function isMuiElement(element, muiNames) {
      return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
    }
    function ownerDocument(node2) {
      return node2 && node2.ownerDocument || document;
    }
    function ownerWindow(node2) {
      const doc = ownerDocument(node2);
      return doc.defaultView || window;
    }
    function setRef(ref, value) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
    const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    const useEnhancedEffect$1 = useEnhancedEffect;
    let globalId = 0;
    function useGlobalId(idOverride) {
      const [defaultId, setDefaultId] = reactExports.useState(idOverride);
      const id2 = idOverride || defaultId;
      reactExports.useEffect(() => {
        if (defaultId == null) {
          globalId += 1;
          setDefaultId(`mui-${globalId}`);
        }
      }, [defaultId]);
      return id2;
    }
    const maybeReactUseId = React$1["useId".toString()];
    function useId(idOverride) {
      if (maybeReactUseId !== void 0) {
        const reactId = maybeReactUseId();
        return idOverride != null ? idOverride : reactId;
      }
      return useGlobalId(idOverride);
    }
    function useControlled({
      controlled,
      default: defaultProp,
      name,
      state = "value"
    }) {
      const {
        current: isControlled
      } = reactExports.useRef(controlled !== void 0);
      const [valueState, setValue] = reactExports.useState(defaultProp);
      const value = isControlled ? controlled : valueState;
      const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
        if (!isControlled) {
          setValue(newValue);
        }
      }, []);
      return [value, setValueIfUncontrolled];
    }
    function useEventCallback(fn2) {
      const ref = reactExports.useRef(fn2);
      useEnhancedEffect$1(() => {
        ref.current = fn2;
      });
      return reactExports.useCallback((...args) => (
        // @ts-expect-error hide `this`
        // tslint:disable-next-line:ban-comma-operator
        (0, ref.current)(...args)
      ), []);
    }
    function useForkRef(...refs) {
      return reactExports.useMemo(() => {
        if (refs.every((ref) => ref == null)) {
          return null;
        }
        return (instance) => {
          refs.forEach((ref) => {
            setRef(ref, instance);
          });
        };
      }, refs);
    }
    let hadKeyboardEvent = true;
    let hadFocusVisibleRecently = false;
    let hadFocusVisibleRecentlyTimeout;
    const inputTypesWhitelist = {
      text: true,
      search: true,
      url: true,
      tel: true,
      email: true,
      password: true,
      number: true,
      date: true,
      month: true,
      week: true,
      time: true,
      datetime: true,
      "datetime-local": true
    };
    function focusTriggersKeyboardModality(node2) {
      const {
        type,
        tagName
      } = node2;
      if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
        return true;
      }
      if (tagName === "TEXTAREA" && !node2.readOnly) {
        return true;
      }
      if (node2.isContentEditable) {
        return true;
      }
      return false;
    }
    function handleKeyDown(event) {
      if (event.metaKey || event.altKey || event.ctrlKey) {
        return;
      }
      hadKeyboardEvent = true;
    }
    function handlePointerDown() {
      hadKeyboardEvent = false;
    }
    function handleVisibilityChange() {
      if (this.visibilityState === "hidden") {
        if (hadFocusVisibleRecently) {
          hadKeyboardEvent = true;
        }
      }
    }
    function prepare(doc) {
      doc.addEventListener("keydown", handleKeyDown, true);
      doc.addEventListener("mousedown", handlePointerDown, true);
      doc.addEventListener("pointerdown", handlePointerDown, true);
      doc.addEventListener("touchstart", handlePointerDown, true);
      doc.addEventListener("visibilitychange", handleVisibilityChange, true);
    }
    function isFocusVisible(event) {
      const {
        target
      } = event;
      try {
        return target.matches(":focus-visible");
      } catch (error) {
      }
      return hadKeyboardEvent || focusTriggersKeyboardModality(target);
    }
    function useIsFocusVisible() {
      const ref = reactExports.useCallback((node2) => {
        if (node2 != null) {
          prepare(node2.ownerDocument);
        }
      }, []);
      const isFocusVisibleRef = reactExports.useRef(false);
      function handleBlurVisible() {
        if (isFocusVisibleRef.current) {
          hadFocusVisibleRecently = true;
          window.clearTimeout(hadFocusVisibleRecentlyTimeout);
          hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
            hadFocusVisibleRecently = false;
          }, 100);
          isFocusVisibleRef.current = false;
          return true;
        }
        return false;
      }
      function handleFocusVisible(event) {
        if (isFocusVisible(event)) {
          isFocusVisibleRef.current = true;
          return true;
        }
        return false;
      }
      return {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref
      };
    }
    function getScrollbarSize(doc) {
      const documentWidth = doc.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    const usePreviousProps = (value) => {
      const ref = reactExports.useRef({});
      reactExports.useEffect(() => {
        ref.current = value;
      });
      return ref.current;
    };
    const usePreviousProps$1 = usePreviousProps;
    function resolveProps(defaultProps2, props) {
      const output = _extends$1({}, props);
      Object.keys(defaultProps2).forEach((propName) => {
        if (propName.toString().match(/^(components|slots)$/)) {
          output[propName] = _extends$1({}, defaultProps2[propName], output[propName]);
        } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
          const defaultSlotProps = defaultProps2[propName] || {};
          const slotProps = props[propName];
          output[propName] = {};
          if (!slotProps || !Object.keys(slotProps)) {
            output[propName] = defaultSlotProps;
          } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
            output[propName] = slotProps;
          } else {
            output[propName] = _extends$1({}, slotProps);
            Object.keys(defaultSlotProps).forEach((slotPropName) => {
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            });
          }
        } else if (output[propName] === void 0) {
          output[propName] = defaultProps2[propName];
        }
      });
      return output;
    }
    function composeClasses(slots, getUtilityClass, classes = void 0) {
      const output = {};
      Object.keys(slots).forEach(
        // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
        // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
        (slot) => {
          output[slot] = slots[slot].reduce((acc, key) => {
            if (key) {
              const utilityClass = getUtilityClass(key);
              if (utilityClass !== "") {
                acc.push(utilityClass);
              }
              if (classes && classes[key]) {
                acc.push(classes[key]);
              }
            }
            return acc;
          }, []).join(" ");
        }
      );
      return output;
    }
    const defaultGenerator = (componentName) => componentName;
    const createClassNameGenerator = () => {
      let generate = defaultGenerator;
      return {
        configure(generator) {
          generate = generator;
        },
        generate(componentName) {
          return generate(componentName);
        },
        reset() {
          generate = defaultGenerator;
        }
      };
    };
    const ClassNameGenerator = createClassNameGenerator();
    const ClassNameGenerator$1 = ClassNameGenerator;
    const globalStateClassesMapping = {
      active: "active",
      checked: "checked",
      completed: "completed",
      disabled: "disabled",
      readOnly: "readOnly",
      error: "error",
      expanded: "expanded",
      focused: "focused",
      focusVisible: "focusVisible",
      required: "required",
      selected: "selected"
    };
    function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
      const globalStateClass = globalStateClassesMapping[slot];
      return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
    }
    function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
      const result = {};
      slots.forEach((slot) => {
        result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
      });
      return result;
    }
    const THEME_ID = "$$material";
    function memoize$1(fn2) {
      var cache = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        if (cache[arg] === void 0)
          cache[arg] = fn2(arg);
        return cache[arg];
      };
    }
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var isPropValid = /* @__PURE__ */ memoize$1(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
        if (document.styleSheets[i2].ownerNode === tag) {
          return document.styleSheets[i2];
        }
      }
    }
    function createStyleElement(options) {
      var tag = document.createElement("style");
      tag.setAttribute("data-emotion", options.key);
      if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
      }
      tag.appendChild(document.createTextNode(""));
      tag.setAttribute("data-s", "");
      return tag;
    }
    var StyleSheet = /* @__PURE__ */ function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }
          _this.container.insertBefore(tag, before);
          _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };
      _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e2) {
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
      };
      return StyleSheet2;
    }();
    var MS = "-ms-";
    var MOZ = "-moz-";
    var WEBKIT = "-webkit-";
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var KEYFRAMES = "@keyframes";
    var LAYER = "@layer";
    var abs = Math.abs;
    var from = String.fromCharCode;
    var assign$1 = Object.assign;
    function hash(value, length2) {
      return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
    }
    function trim(value) {
      return value.trim();
    }
    function match(value, pattern) {
      return (value = pattern.exec(value)) ? value[0] : value;
    }
    function replace(value, pattern, replacement) {
      return value.replace(pattern, replacement);
    }
    function indexof(value, search) {
      return value.indexOf(search);
    }
    function charat(value, index2) {
      return value.charCodeAt(index2) | 0;
    }
    function substr(value, begin, end) {
      return value.slice(begin, end);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array) {
      return array.push(value), value;
    }
    function combine(array, callback) {
      return array.map(callback).join("");
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position$1 = 0;
    var character = 0;
    var characters = "";
    function node(value, root, parent, type, props, children, length2) {
      return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
    }
    function copy$1(root, props) {
      return assign$1(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
    }
    function char() {
      return character;
    }
    function prev() {
      character = position$1 > 0 ? charat(characters, --position$1) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position$1 < length ? charat(characters, position$1++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position$1);
    }
    function caret() {
      return position$1;
    }
    function slice(begin, end) {
      return substr(characters, begin, end);
    }
    function token(type) {
      switch (type) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type) {
      return trim(slice(position$1 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
    }
    function whitespace(type) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token(type) > 2 || token(character) > 3 ? "" : " ";
    }
    function escaping(index2, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type) {
      while (next())
        switch (character) {
          case type:
            return position$1;
          case 34:
          case 39:
            if (type !== 34 && type !== 39)
              delimiter(character);
            break;
          case 40:
            if (type === 41)
              delimiter(type);
            break;
          case 92:
            next();
            break;
        }
      return position$1;
    }
    function commenter(type, index2) {
      while (next())
        if (type + character === 47 + 10)
          break;
        else if (type + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice(index2, position$1 - 1) + "*" + from(type === 47 ? type : next());
    }
    function identifier(index2) {
      while (!token(peek()))
        next();
      return slice(index2, position$1);
    }
    function compile(value) {
      return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse$1(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
      var index2 = 0;
      var offset = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type = "";
      var props = rules;
      var children = rulesets;
      var reference = rule;
      var characters2 = type;
      while (scanning)
        switch (previous = character2, character2 = next()) {
          case 40:
            if (previous != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace(previous);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root, parent), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index2++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset:
                if (ampersand == -1)
                  characters2 = replace(characters2, /\f/g, "");
                if (property > 0 && strlen(characters2) - length2)
                  append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference = ruleset(characters2, root, parent, index2, offset, rules, points, type, props = [], children = [], length2), rulesets);
                if (character2 === 123)
                  if (offset === 0)
                    parse$1(characters2, root, reference, reference, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                        parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                    }
            }
            index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from(character2), character2 * variable) {
              case 38:
                ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root, parent, index2, offset, rules, points, type, props, children, length2) {
      var post = offset - 1;
      var rule = offset === 0 ? rules : [""];
      var size = sizeof(rule);
      for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
          if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
    }
    function comment(value, root, parent) {
      return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
    }
    function declaration(value, root, parent, length2) {
      return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
    }
    function serialize(children, callback) {
      var output = "";
      var length2 = sizeof(children);
      for (var i2 = 0; i2 < length2; i2++)
        output += callback(children[i2], i2, children, callback) || "";
      return output;
    }
    function stringify(element, index2, children, callback) {
      switch (element.type) {
        case LAYER:
          if (element.children.length)
            break;
        case IMPORT:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize(element.children, callback) + "}";
        case RULESET:
          element.value = element.props.join(",");
      }
      return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    function middleware(collection) {
      var length2 = sizeof(collection);
      return function(element, index2, children, callback) {
        var output = "";
        for (var i2 = 0; i2 < length2; i2++)
          output += collection[i2](element, index2, children, callback) || "";
        return output;
      };
    }
    function rulesheet(callback) {
      return function(element) {
        if (!element.root) {
          if (element = element.return)
            callback(element);
        }
      };
    }
    var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
      var previous = 0;
      var character2 = 0;
      while (true) {
        previous = character2;
        character2 = peek();
        if (previous === 38 && character2 === 12) {
          points[index2] = 1;
        }
        if (token(character2)) {
          break;
        }
        next();
      }
      return slice(begin, position$1);
    };
    var toRules = function toRules2(parsed, points) {
      var index2 = -1;
      var character2 = 44;
      do {
        switch (token(character2)) {
          case 0:
            if (character2 === 38 && peek() === 12) {
              points[index2] = 1;
            }
            parsed[index2] += identifierWithPointTracking(position$1 - 1, points, index2);
            break;
          case 2:
            parsed[index2] += delimit(character2);
            break;
          case 4:
            if (character2 === 44) {
              parsed[++index2] = peek() === 58 ? "&\f" : "";
              points[index2] = parsed[index2].length;
              break;
            }
          default:
            parsed[index2] += from(character2);
        }
      } while (character2 = next());
      return parsed;
    };
    var getRules = function getRules2(value, points) {
      return dealloc(toRules(alloc(value), points));
    };
    var fixedElements = /* @__PURE__ */ new WeakMap();
    var compat = function compat2(element) {
      if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
      // negative .length indicates that this rule has been already prefixed
      element.length < 1) {
        return;
      }
      var value = element.value, parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;
      while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent)
          return;
      }
      if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
      }
      if (isImplicitRule) {
        return;
      }
      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;
      for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
        for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
          element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
        }
      }
    };
    var removeLabel = function removeLabel2(element) {
      if (element.type === "decl") {
        var value = element.value;
        if (
          // charcode for l
          value.charCodeAt(0) === 108 && // charcode for b
          value.charCodeAt(2) === 98
        ) {
          element["return"] = "";
          element.value = "";
        }
      }
    };
    function prefix(value, length2) {
      switch (hash(value, length2)) {
        case 5103:
          return WEBKIT + "print-" + value + value;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
          return WEBKIT + value + value;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
          return WEBKIT + value + MOZ + value + MS + value + value;
        case 6828:
        case 4268:
          return WEBKIT + value + MS + value + value;
        case 6165:
          return WEBKIT + value + MS + "flex-" + value + value;
        case 5187:
          return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
        case 5443:
          return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
        case 4675:
          return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
        case 5548:
          return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
        case 5292:
          return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
        case 6060:
          return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
        case 4554:
          return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
        case 6187:
          return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
        case 5495:
        case 3959:
          return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4968:
          return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          if (strlen(value) - 1 - length2 > 6)
            switch (charat(value, length2 + 1)) {
              case 109:
                if (charat(value, length2 + 4) !== 45)
                  break;
              case 102:
                return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
              case 115:
                return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
            }
          break;
        case 4949:
          if (charat(value, length2 + 1) !== 115)
            break;
        case 6444:
          switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
            case 107:
              return replace(value, ":", ":" + WEBKIT) + value;
            case 101:
              return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
          }
          break;
        case 5936:
          switch (charat(value, length2 + 11)) {
            case 114:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
            case 108:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
            case 45:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
          }
          return WEBKIT + value + MS + value + value;
      }
      return value;
    }
    var prefixer = function prefixer2(element, index2, children, callback) {
      if (element.length > -1) {
        if (!element["return"])
          switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize([copy$1(element, {
                value: replace(element.value, "@", "@" + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length)
                return combine(element.props, function(value) {
                  switch (match(value, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return serialize([copy$1(element, {
                        props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                      })], callback);
                    case "::placeholder":
                      return serialize([copy$1(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                      }), copy$1(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                      }), copy$1(element, {
                        props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                      })], callback);
                  }
                  return "";
                });
          }
      }
    };
    var defaultStylisPlugins = [prefixer];
    var createCache = function createCache2(options) {
      var key = options.key;
      if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node2) {
          var dataEmotionAttribute = node2.getAttribute("data-emotion");
          if (dataEmotionAttribute.indexOf(" ") === -1) {
            return;
          }
          document.head.appendChild(node2);
          node2.setAttribute("data-s", "");
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      var inserted = {};
      var container;
      var nodesToHydrate = [];
      {
        container = options.container || document.head;
        Array.prototype.forEach.call(
          // this means we will ignore elements which don't have a space in them which
          // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
          document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
          function(node2) {
            var attrib = node2.getAttribute("data-emotion").split(" ");
            for (var i2 = 1; i2 < attrib.length; i2++) {
              inserted[attrib[i2]] = true;
            }
            nodesToHydrate.push(node2);
          }
        );
      }
      var _insert;
      var omnipresentPlugins = [compat, removeLabel];
      {
        var currentSheet;
        var finalizingPlugins = [stringify, rulesheet(function(rule) {
          currentSheet.insert(rule);
        })];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis = function stylis2(styles2) {
          return serialize(compile(styles2), serializer);
        };
        _insert = function insert(selector, serialized, sheet, shouldCache) {
          currentSheet = sheet;
          stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          if (shouldCache) {
            cache.inserted[serialized.name] = true;
          }
        };
      }
      var cache = {
        key,
        sheet: new StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      cache.sheet.hydrate(nodesToHydrate);
      return cache;
    };
    var isBrowser = true;
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = "";
      classNames.split(" ").forEach(function(className) {
        if (registered[className] !== void 0) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
      var className = cache.key + "-" + serialized.name;
      if (
        // we only need to add the styles to the registered cache if the
        // class name could be used further down
        // the tree but if it's a string tag, we know it won't
        // so we don't have to add it to registered cache.
        // this improves memory usage since we can avoid storing the whole style string
        (isStringTag2 === false || // we need to always store it if we're in compat mode and
        // in node since emotion-server relies on whether a style is in
        // the registered cache to know whether a style is global or not
        // also, note that this check will be dead code eliminated in the browser
        isBrowser === false) && cache.registered[className] === void 0
      ) {
        cache.registered[className] = serialized.styles;
      }
    };
    var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
      registerStyles(cache, serialized, isStringTag2);
      var className = cache.key + "-" + serialized.name;
      if (cache.inserted[serialized.name] === void 0) {
        var current = serialized;
        do {
          cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
          current = current.next;
        } while (current !== void 0);
      }
    };
    function murmur2(str) {
      var h2 = 0;
      var k2, i2 = 0, len = str.length;
      for (; len >= 4; ++i2, len -= 4) {
        k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    var unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    var isCustomProperty = function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    };
    var isProcessableValue = function isProcessableValue2(value) {
      return value != null && typeof value !== "boolean";
    };
    var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    var processStyleValue = function processStyleValue2(key, value) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value === "string") {
            return value.replace(animationRegex, function(match2, p1, p2) {
              cursor = {
                name: p1,
                styles: p2,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
      }
      return value;
    };
    var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return "";
      }
      if (interpolation.__emotion_styles !== void 0) {
        return interpolation;
      }
      switch (typeof interpolation) {
        case "boolean": {
          return "";
        }
        case "object": {
          if (interpolation.anim === 1) {
            cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            };
            return interpolation.name;
          }
          if (interpolation.styles !== void 0) {
            var next2 = interpolation.next;
            if (next2 !== void 0) {
              while (next2 !== void 0) {
                cursor = {
                  name: next2.name,
                  styles: next2.styles,
                  next: cursor
                };
                next2 = next2.next;
              }
            }
            var styles2 = interpolation.styles + ";";
            return styles2;
          }
          return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
          if (mergedProps !== void 0) {
            var previousCursor = cursor;
            var result = interpolation(mergedProps);
            cursor = previousCursor;
            return handleInterpolation(mergedProps, registered, result);
          }
          break;
        }
      }
      if (registered == null) {
        return interpolation;
      }
      var cached = registered[interpolation];
      return cached !== void 0 ? cached : interpolation;
    }
    function createStringFromObject(mergedProps, registered, obj) {
      var string = "";
      if (Array.isArray(obj)) {
        for (var i2 = 0; i2 < obj.length; i2++) {
          string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];
          if (typeof value !== "object") {
            if (registered != null && registered[value] !== void 0) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === "NO_COMPONENT_SELECTOR" && false) {
              throw new Error(noComponentSelectorMessage);
            }
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);
              switch (_key) {
                case "animation":
                case "animationName": {
                  string += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }
                default: {
                  string += _key + "{" + interpolated + "}";
                }
              }
            }
          }
        }
      }
      return string;
    }
    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var cursor;
    var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles2 = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles2 += handleInterpolation(mergedProps, registered, strings);
      } else {
        styles2 += strings[0];
      }
      for (var i2 = 1; i2 < args.length; i2++) {
        styles2 += handleInterpolation(mergedProps, registered, args[i2]);
        if (stringMode) {
          styles2 += strings[i2];
        }
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match2;
      while ((match2 = labelPattern.exec(styles2)) !== null) {
        identifierName += "-" + // $FlowFixMe we know it's not null
        match2[1];
      }
      var name = murmur2(styles2) + identifierName;
      return {
        name,
        styles: styles2,
        next: cursor
      };
    };
    var syncFallback = function syncFallback2(create) {
      return create();
    };
    var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
    var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
    var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
    var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
      // we're doing this to avoid preconstruct's dead code elimination in this one case
      // because this module is primarily intended for the browser and node
      // but it's also required in react native and similar environments sometimes
      // and we could have a special build just for that
      // but this is much easier and the native packages
      // might use a different theme context in the future anyway
      typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
        key: "css"
      }) : null
    );
    EmotionCacheContext.Provider;
    var withEmotionCache = function withEmotionCache2(func) {
      return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var cache = reactExports.useContext(EmotionCacheContext);
        return func(props, cache, ref);
      });
    };
    var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
    var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
      var styles2 = props.styles;
      var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
      var sheetRef = reactExports.useRef();
      useInsertionEffectWithLayoutFallback(function() {
        var key = cache.key + "-global";
        var sheet = new cache.sheet.constructor({
          key,
          nonce: cache.sheet.nonce,
          container: cache.sheet.container,
          speedy: cache.sheet.isSpeedy
        });
        var rehydrating = false;
        var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        if (cache.sheet.tags.length) {
          sheet.before = cache.sheet.tags[0];
        }
        if (node2 !== null) {
          rehydrating = true;
          node2.setAttribute("data-emotion", key);
          sheet.hydrate([node2]);
        }
        sheetRef.current = [sheet, rehydrating];
        return function() {
          sheet.flush();
        };
      }, [cache]);
      useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current;
        var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = false;
          return;
        }
        if (serialized.next !== void 0) {
          insertStyles(cache, serialized.next, true);
        }
        if (sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element;
          sheet.flush();
        }
        cache.insert("", serialized, sheet, false);
      }, [cache, serialized.name]);
      return null;
    });
    function css() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return serializeStyles(args);
    }
    var keyframes = function keyframes2() {
      var insertable = css.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    };
    var testOmitPropsOnStringTag = isPropValid;
    var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
      return key !== "theme";
    };
    var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
      return typeof tag === "string" && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    };
    var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
      var shouldForwardProp2;
      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }
      if (typeof shouldForwardProp2 !== "function" && isReal) {
        shouldForwardProp2 = tag.__emotion_forwardProp;
      }
      return shouldForwardProp2;
    };
    var Insertion = function Insertion2(_ref) {
      var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      registerStyles(cache, serialized, isStringTag2);
      useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(cache, serialized, isStringTag2);
      });
      return null;
    };
    var createStyled$1 = function createStyled2(tag, options) {
      var isReal = tag.__emotion_real === tag;
      var baseTag = isReal && tag.__emotion_base || tag;
      var identifierName;
      var targetClassName;
      if (options !== void 0) {
        identifierName = options.label;
        targetClassName = options.target;
      }
      var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
      var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
      var shouldUseAs = !defaultShouldForwardProp("as");
      return function() {
        var args = arguments;
        var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0) {
          styles2.push("label:" + identifierName + ";");
        }
        if (args[0] == null || args[0].raw === void 0) {
          styles2.push.apply(styles2, args);
        } else {
          styles2.push(args[0][0]);
          var len = args.length;
          var i2 = 1;
          for (; i2 < len; i2++) {
            styles2.push(args[i2], args[0][i2]);
          }
        }
        var Styled = withEmotionCache(function(props, cache, ref) {
          var FinalTag = shouldUseAs && props.as || baseTag;
          var className = "";
          var classInterpolations = [];
          var mergedProps = props;
          if (props.theme == null) {
            mergedProps = {};
            for (var key in props) {
              mergedProps[key] = props[key];
            }
            mergedProps.theme = reactExports.useContext(ThemeContext);
          }
          if (typeof props.className === "string") {
            className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }
          var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
          className += cache.key + "-" + serialized.name;
          if (targetClassName !== void 0) {
            className += " " + targetClassName;
          }
          var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
          var newProps = {};
          for (var _key in props) {
            if (shouldUseAs && _key === "as")
              continue;
            if (
              // $FlowFixMe
              finalShouldForwardProp(_key)
            ) {
              newProps[_key] = props[_key];
            }
          }
          newProps.className = className;
          newProps.ref = ref;
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
            cache,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
        });
        Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles2;
        Styled.__emotion_forwardProp = shouldForwardProp2;
        Object.defineProperty(Styled, "toString", {
          value: function value() {
            if (targetClassName === void 0 && false) {
              return "NO_COMPONENT_SELECTOR";
            }
            return "." + targetClassName;
          }
        });
        Styled.withComponent = function(nextTag, nextOptions) {
          return createStyled2(nextTag, _extends$1({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
          })).apply(void 0, styles2);
        };
        return Styled;
      };
    };
    var tags = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      // SVG
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    var newStyled = createStyled$1.bind();
    tags.forEach(function(tagName) {
      newStyled[tagName] = newStyled(tagName);
    });
    function isEmpty$4(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0;
    }
    function GlobalStyles$2(props) {
      const {
        styles: styles2,
        defaultTheme: defaultTheme2 = {}
      } = props;
      const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
        styles: globalStyles
      });
    }
    /**
     * @mui/styled-engine v5.13.2
     *
     * @license MIT
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    function styled$3(tag, options) {
      const stylesFactory = newStyled(tag, options);
      return stylesFactory;
    }
    const internal_processStyles = (tag, processor) => {
      if (Array.isArray(tag.__emotion_styles)) {
        tag.__emotion_styles = processor(tag.__emotion_styles);
      }
    };
    const _excluded$1d = ["values", "unit", "step"];
    const sortBreakpointsValues = (values2) => {
      const breakpointsAsArray = Object.keys(values2).map((key) => ({
        key,
        val: values2[key]
      })) || [];
      breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
      return breakpointsAsArray.reduce((acc, obj) => {
        return _extends$1({}, acc, {
          [obj.key]: obj.val
        });
      }, {});
    };
    function createBreakpoints(breakpoints) {
      const {
        // The breakpoint **start** at this value.
        // For instance with the first breakpoint xs: [xs, sm).
        values: values2 = {
          xs: 0,
          // phone
          sm: 600,
          // tablet
          md: 900,
          // small laptop
          lg: 1200,
          // desktop
          xl: 1536
          // large screen
        },
        unit = "px",
        step = 5
      } = breakpoints, other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$1d);
      const sortedValues = sortBreakpointsValues(values2);
      const keys = Object.keys(sortedValues);
      function up(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (min-width:${value}${unit})`;
      }
      function down(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (max-width:${value - step / 100}${unit})`;
      }
      function between(start, end) {
        const endIndex = keys.indexOf(end);
        return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
      }
      function only(key) {
        if (keys.indexOf(key) + 1 < keys.length) {
          return between(key, keys[keys.indexOf(key) + 1]);
        }
        return up(key);
      }
      function not(key) {
        const keyIndex = keys.indexOf(key);
        if (keyIndex === 0) {
          return up(keys[1]);
        }
        if (keyIndex === keys.length - 1) {
          return down(keys[keyIndex]);
        }
        return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
      }
      return _extends$1({
        keys,
        values: sortedValues,
        up,
        down,
        between,
        only,
        not,
        unit
      }, other);
    }
    const shape = {
      borderRadius: 4
    };
    const shape$1 = shape;
    function merge(acc, item) {
      if (!item) {
        return acc;
      }
      return deepmerge(acc, item, {
        clone: false
        // No need to clone deep, it's way faster.
      });
    }
    const values$1 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    };
    const defaultBreakpoints = {
      // Sorted ASC by size. That's important.
      // It can't be configured as it's used statically for propTypes.
      keys: ["xs", "sm", "md", "lg", "xl"],
      up: (key) => `@media (min-width:${values$1[key]}px)`
    };
    function handleBreakpoints(props, propValue, styleFromPropValue) {
      const theme = props.theme || {};
      if (Array.isArray(propValue)) {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return propValue.reduce((acc, item, index2) => {
          acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
          return acc;
        }, {});
      }
      if (typeof propValue === "object") {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return Object.keys(propValue).reduce((acc, breakpoint) => {
          if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
            const mediaKey = themeBreakpoints.up(breakpoint);
            acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
          } else {
            const cssKey = breakpoint;
            acc[cssKey] = propValue[cssKey];
          }
          return acc;
        }, {});
      }
      const output = styleFromPropValue(propValue);
      return output;
    }
    function createEmptyBreakpointObject(breakpointsInput = {}) {
      var _breakpointsInput$key;
      const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
        const breakpointStyleKey = breakpointsInput.up(key);
        acc[breakpointStyleKey] = {};
        return acc;
      }, {});
      return breakpointsInOrder || {};
    }
    function removeUnusedBreakpoints(breakpointKeys, style2) {
      return breakpointKeys.reduce((acc, key) => {
        const breakpointOutput = acc[key];
        const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
        if (isBreakpointUnused) {
          delete acc[key];
        }
        return acc;
      }, style2);
    }
    function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
      const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
      const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
      return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
    }
    function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
      if (typeof breakpointValues !== "object") {
        return {};
      }
      const base = {};
      const breakpointsKeys = Object.keys(themeBreakpoints);
      if (Array.isArray(breakpointValues)) {
        breakpointsKeys.forEach((breakpoint, i2) => {
          if (i2 < breakpointValues.length) {
            base[breakpoint] = true;
          }
        });
      } else {
        breakpointsKeys.forEach((breakpoint) => {
          if (breakpointValues[breakpoint] != null) {
            base[breakpoint] = true;
          }
        });
      }
      return base;
    }
    function resolveBreakpointValues({
      values: breakpointValues,
      breakpoints: themeBreakpoints,
      base: customBase
    }) {
      const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
      const keys = Object.keys(base);
      if (keys.length === 0) {
        return breakpointValues;
      }
      let previous;
      return keys.reduce((acc, breakpoint, i2) => {
        if (Array.isArray(breakpointValues)) {
          acc[breakpoint] = breakpointValues[i2] != null ? breakpointValues[i2] : breakpointValues[previous];
          previous = i2;
        } else if (typeof breakpointValues === "object") {
          acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
          previous = breakpoint;
        } else {
          acc[breakpoint] = breakpointValues;
        }
        return acc;
      }, {});
    }
    function getPath(obj, path, checkVars = true) {
      if (!path || typeof path !== "string") {
        return null;
      }
      if (obj && obj.vars && checkVars) {
        const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
        if (val != null) {
          return val;
        }
      }
      return path.split(".").reduce((acc, item) => {
        if (acc && acc[item] != null) {
          return acc[item];
        }
        return null;
      }, obj);
    }
    function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
      let value;
      if (typeof themeMapping === "function") {
        value = themeMapping(propValueFinal);
      } else if (Array.isArray(themeMapping)) {
        value = themeMapping[propValueFinal] || userValue;
      } else {
        value = getPath(themeMapping, propValueFinal) || userValue;
      }
      if (transform) {
        value = transform(value, userValue, themeMapping);
      }
      return value;
    }
    function style$3(options) {
      const {
        prop,
        cssProperty = options.prop,
        themeKey,
        transform
      } = options;
      const fn2 = (props) => {
        if (props[prop] == null) {
          return null;
        }
        const propValue = props[prop];
        const theme = props.theme;
        const themeMapping = getPath(theme, themeKey) || {};
        const styleFromPropValue = (propValueFinal) => {
          let value = getStyleValue$1(themeMapping, transform, propValueFinal);
          if (propValueFinal === value && typeof propValueFinal === "string") {
            value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
          }
          if (cssProperty === false) {
            return value;
          }
          return {
            [cssProperty]: value
          };
        };
        return handleBreakpoints(props, propValue, styleFromPropValue);
      };
      fn2.propTypes = {};
      fn2.filterProps = [prop];
      return fn2;
    }
    function memoize(fn2) {
      const cache = {};
      return (arg) => {
        if (cache[arg] === void 0) {
          cache[arg] = fn2(arg);
        }
        return cache[arg];
      };
    }
    const properties = {
      m: "margin",
      p: "padding"
    };
    const directions = {
      t: "Top",
      r: "Right",
      b: "Bottom",
      l: "Left",
      x: ["Left", "Right"],
      y: ["Top", "Bottom"]
    };
    const aliases = {
      marginX: "mx",
      marginY: "my",
      paddingX: "px",
      paddingY: "py"
    };
    const getCssProperties = memoize((prop) => {
      if (prop.length > 2) {
        if (aliases[prop]) {
          prop = aliases[prop];
        } else {
          return [prop];
        }
      }
      const [a2, b2] = prop.split("");
      const property = properties[a2];
      const direction = directions[b2] || "";
      return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
    });
    const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
    const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
    [...marginKeys, ...paddingKeys];
    function createUnaryUnit(theme, themeKey, defaultValue, propName) {
      var _getPath;
      const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
      if (typeof themeSpacing === "number") {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing * abs2;
        };
      }
      if (Array.isArray(themeSpacing)) {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing[abs2];
        };
      }
      if (typeof themeSpacing === "function") {
        return themeSpacing;
      }
      return () => void 0;
    }
    function createUnarySpacing(theme) {
      return createUnaryUnit(theme, "spacing", 8);
    }
    function getValue(transformer, propValue) {
      if (typeof propValue === "string" || propValue == null) {
        return propValue;
      }
      const abs2 = Math.abs(propValue);
      const transformed = transformer(abs2);
      if (propValue >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    }
    function getStyleFromPropValue(cssProperties, transformer) {
      return (propValue) => cssProperties.reduce((acc, cssProperty) => {
        acc[cssProperty] = getValue(transformer, propValue);
        return acc;
      }, {});
    }
    function resolveCssProperty(props, keys, prop, transformer) {
      if (keys.indexOf(prop) === -1) {
        return null;
      }
      const cssProperties = getCssProperties(prop);
      const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
      const propValue = props[prop];
      return handleBreakpoints(props, propValue, styleFromPropValue);
    }
    function style$2(props, keys) {
      const transformer = createUnarySpacing(props.theme);
      return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
    }
    function margin(props) {
      return style$2(props, marginKeys);
    }
    margin.propTypes = {};
    margin.filterProps = marginKeys;
    function padding(props) {
      return style$2(props, paddingKeys);
    }
    padding.propTypes = {};
    padding.filterProps = paddingKeys;
    function createSpacing(spacingInput = 8) {
      if (spacingInput.mui) {
        return spacingInput;
      }
      const transform = createUnarySpacing({
        spacing: spacingInput
      });
      const spacing = (...argsInput) => {
        const args = argsInput.length === 0 ? [1] : argsInput;
        return args.map((argument) => {
          const output = transform(argument);
          return typeof output === "number" ? `${output}px` : output;
        }).join(" ");
      };
      spacing.mui = true;
      return spacing;
    }
    function compose$1(...styles2) {
      const handlers = styles2.reduce((acc, style2) => {
        style2.filterProps.forEach((prop) => {
          acc[prop] = style2;
        });
        return acc;
      }, {});
      const fn2 = (props) => {
        return Object.keys(props).reduce((acc, prop) => {
          if (handlers[prop]) {
            return merge(acc, handlers[prop](props));
          }
          return acc;
        }, {});
      };
      fn2.propTypes = {};
      fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
      return fn2;
    }
    function borderTransform(value) {
      if (typeof value !== "number") {
        return value;
      }
      return `${value}px solid`;
    }
    const border = style$3({
      prop: "border",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderTop = style$3({
      prop: "borderTop",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderRight = style$3({
      prop: "borderRight",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderBottom = style$3({
      prop: "borderBottom",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderLeft = style$3({
      prop: "borderLeft",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderColor = style$3({
      prop: "borderColor",
      themeKey: "palette"
    });
    const borderTopColor = style$3({
      prop: "borderTopColor",
      themeKey: "palette"
    });
    const borderRightColor = style$3({
      prop: "borderRightColor",
      themeKey: "palette"
    });
    const borderBottomColor = style$3({
      prop: "borderBottomColor",
      themeKey: "palette"
    });
    const borderLeftColor = style$3({
      prop: "borderLeftColor",
      themeKey: "palette"
    });
    const borderRadius = (props) => {
      if (props.borderRadius !== void 0 && props.borderRadius !== null) {
        const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
        const styleFromPropValue = (propValue) => ({
          borderRadius: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
      }
      return null;
    };
    borderRadius.propTypes = {};
    borderRadius.filterProps = ["borderRadius"];
    compose$1(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
    const gap = (props) => {
      if (props.gap !== void 0 && props.gap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          gap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.gap, styleFromPropValue);
      }
      return null;
    };
    gap.propTypes = {};
    gap.filterProps = ["gap"];
    const columnGap = (props) => {
      if (props.columnGap !== void 0 && props.columnGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          columnGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.columnGap, styleFromPropValue);
      }
      return null;
    };
    columnGap.propTypes = {};
    columnGap.filterProps = ["columnGap"];
    const rowGap = (props) => {
      if (props.rowGap !== void 0 && props.rowGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          rowGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.rowGap, styleFromPropValue);
      }
      return null;
    };
    rowGap.propTypes = {};
    rowGap.filterProps = ["rowGap"];
    const gridColumn = style$3({
      prop: "gridColumn"
    });
    const gridRow = style$3({
      prop: "gridRow"
    });
    const gridAutoFlow = style$3({
      prop: "gridAutoFlow"
    });
    const gridAutoColumns = style$3({
      prop: "gridAutoColumns"
    });
    const gridAutoRows = style$3({
      prop: "gridAutoRows"
    });
    const gridTemplateColumns = style$3({
      prop: "gridTemplateColumns"
    });
    const gridTemplateRows = style$3({
      prop: "gridTemplateRows"
    });
    const gridTemplateAreas = style$3({
      prop: "gridTemplateAreas"
    });
    const gridArea = style$3({
      prop: "gridArea"
    });
    compose$1(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
    function paletteTransform(value, userValue) {
      if (userValue === "grey") {
        return userValue;
      }
      return value;
    }
    const color = style$3({
      prop: "color",
      themeKey: "palette",
      transform: paletteTransform
    });
    const bgcolor = style$3({
      prop: "bgcolor",
      cssProperty: "backgroundColor",
      themeKey: "palette",
      transform: paletteTransform
    });
    const backgroundColor = style$3({
      prop: "backgroundColor",
      themeKey: "palette",
      transform: paletteTransform
    });
    compose$1(color, bgcolor, backgroundColor);
    function sizingTransform(value) {
      return value <= 1 && value !== 0 ? `${value * 100}%` : value;
    }
    const width = style$3({
      prop: "width",
      transform: sizingTransform
    });
    const maxWidth = (props) => {
      if (props.maxWidth !== void 0 && props.maxWidth !== null) {
        const styleFromPropValue = (propValue) => {
          var _props$theme;
          const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
          return {
            maxWidth: breakpoint || sizingTransform(propValue)
          };
        };
        return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
      }
      return null;
    };
    maxWidth.filterProps = ["maxWidth"];
    const minWidth = style$3({
      prop: "minWidth",
      transform: sizingTransform
    });
    const height = style$3({
      prop: "height",
      transform: sizingTransform
    });
    const maxHeight = style$3({
      prop: "maxHeight",
      transform: sizingTransform
    });
    const minHeight = style$3({
      prop: "minHeight",
      transform: sizingTransform
    });
    style$3({
      prop: "size",
      cssProperty: "width",
      transform: sizingTransform
    });
    style$3({
      prop: "size",
      cssProperty: "height",
      transform: sizingTransform
    });
    const boxSizing = style$3({
      prop: "boxSizing"
    });
    compose$1(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
    const defaultSxConfig = {
      // borders
      border: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderTop: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderRight: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderBottom: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderLeft: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderColor: {
        themeKey: "palette"
      },
      borderTopColor: {
        themeKey: "palette"
      },
      borderRightColor: {
        themeKey: "palette"
      },
      borderBottomColor: {
        themeKey: "palette"
      },
      borderLeftColor: {
        themeKey: "palette"
      },
      borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius
      },
      // palette
      color: {
        themeKey: "palette",
        transform: paletteTransform
      },
      bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform
      },
      backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform
      },
      // spacing
      p: {
        style: padding
      },
      pt: {
        style: padding
      },
      pr: {
        style: padding
      },
      pb: {
        style: padding
      },
      pl: {
        style: padding
      },
      px: {
        style: padding
      },
      py: {
        style: padding
      },
      padding: {
        style: padding
      },
      paddingTop: {
        style: padding
      },
      paddingRight: {
        style: padding
      },
      paddingBottom: {
        style: padding
      },
      paddingLeft: {
        style: padding
      },
      paddingX: {
        style: padding
      },
      paddingY: {
        style: padding
      },
      paddingInline: {
        style: padding
      },
      paddingInlineStart: {
        style: padding
      },
      paddingInlineEnd: {
        style: padding
      },
      paddingBlock: {
        style: padding
      },
      paddingBlockStart: {
        style: padding
      },
      paddingBlockEnd: {
        style: padding
      },
      m: {
        style: margin
      },
      mt: {
        style: margin
      },
      mr: {
        style: margin
      },
      mb: {
        style: margin
      },
      ml: {
        style: margin
      },
      mx: {
        style: margin
      },
      my: {
        style: margin
      },
      margin: {
        style: margin
      },
      marginTop: {
        style: margin
      },
      marginRight: {
        style: margin
      },
      marginBottom: {
        style: margin
      },
      marginLeft: {
        style: margin
      },
      marginX: {
        style: margin
      },
      marginY: {
        style: margin
      },
      marginInline: {
        style: margin
      },
      marginInlineStart: {
        style: margin
      },
      marginInlineEnd: {
        style: margin
      },
      marginBlock: {
        style: margin
      },
      marginBlockStart: {
        style: margin
      },
      marginBlockEnd: {
        style: margin
      },
      // display
      displayPrint: {
        cssProperty: false,
        transform: (value) => ({
          "@media print": {
            display: value
          }
        })
      },
      display: {},
      overflow: {},
      textOverflow: {},
      visibility: {},
      whiteSpace: {},
      // flexbox
      flexBasis: {},
      flexDirection: {},
      flexWrap: {},
      justifyContent: {},
      alignItems: {},
      alignContent: {},
      order: {},
      flex: {},
      flexGrow: {},
      flexShrink: {},
      alignSelf: {},
      justifyItems: {},
      justifySelf: {},
      // grid
      gap: {
        style: gap
      },
      rowGap: {
        style: rowGap
      },
      columnGap: {
        style: columnGap
      },
      gridColumn: {},
      gridRow: {},
      gridAutoFlow: {},
      gridAutoColumns: {},
      gridAutoRows: {},
      gridTemplateColumns: {},
      gridTemplateRows: {},
      gridTemplateAreas: {},
      gridArea: {},
      // positions
      position: {},
      zIndex: {
        themeKey: "zIndex"
      },
      top: {},
      right: {},
      bottom: {},
      left: {},
      // shadows
      boxShadow: {
        themeKey: "shadows"
      },
      // sizing
      width: {
        transform: sizingTransform
      },
      maxWidth: {
        style: maxWidth
      },
      minWidth: {
        transform: sizingTransform
      },
      height: {
        transform: sizingTransform
      },
      maxHeight: {
        transform: sizingTransform
      },
      minHeight: {
        transform: sizingTransform
      },
      boxSizing: {},
      // typography
      fontFamily: {
        themeKey: "typography"
      },
      fontSize: {
        themeKey: "typography"
      },
      fontStyle: {
        themeKey: "typography"
      },
      fontWeight: {
        themeKey: "typography"
      },
      letterSpacing: {},
      textTransform: {},
      lineHeight: {},
      textAlign: {},
      typography: {
        cssProperty: false,
        themeKey: "typography"
      }
    };
    const defaultSxConfig$1 = defaultSxConfig;
    function objectsHaveSameKeys(...objects) {
      const allKeys = objects.reduce((keys, object2) => keys.concat(Object.keys(object2)), []);
      const union = new Set(allKeys);
      return objects.every((object2) => union.size === Object.keys(object2).length);
    }
    function callIfFn(maybeFn, arg) {
      return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
    }
    function unstable_createStyleFunctionSx() {
      function getThemeValue(prop, val, theme, config2) {
        const props = {
          [prop]: val,
          theme
        };
        const options = config2[prop];
        if (!options) {
          return {
            [prop]: val
          };
        }
        const {
          cssProperty = prop,
          themeKey,
          transform,
          style: style2
        } = options;
        if (val == null) {
          return null;
        }
        if (themeKey === "typography" && val === "inherit") {
          return {
            [prop]: val
          };
        }
        const themeMapping = getPath(theme, themeKey) || {};
        if (style2) {
          return style2(props);
        }
        const styleFromPropValue = (propValueFinal) => {
          let value = getStyleValue$1(themeMapping, transform, propValueFinal);
          if (propValueFinal === value && typeof propValueFinal === "string") {
            value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
          }
          if (cssProperty === false) {
            return value;
          }
          return {
            [cssProperty]: value
          };
        };
        return handleBreakpoints(props, val, styleFromPropValue);
      }
      function styleFunctionSx2(props) {
        var _theme$unstable_sxCon;
        const {
          sx,
          theme = {}
        } = props || {};
        if (!sx) {
          return null;
        }
        const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
        function traverse(sxInput) {
          let sxObject = sxInput;
          if (typeof sxInput === "function") {
            sxObject = sxInput(theme);
          } else if (typeof sxInput !== "object") {
            return sxInput;
          }
          if (!sxObject) {
            return null;
          }
          const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
          const breakpointsKeys = Object.keys(emptyBreakpoints);
          let css2 = emptyBreakpoints;
          Object.keys(sxObject).forEach((styleKey) => {
            const value = callIfFn(sxObject[styleKey], theme);
            if (value !== null && value !== void 0) {
              if (typeof value === "object") {
                if (config2[styleKey]) {
                  css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
                } else {
                  const breakpointsValues = handleBreakpoints({
                    theme
                  }, value, (x2) => ({
                    [styleKey]: x2
                  }));
                  if (objectsHaveSameKeys(breakpointsValues, value)) {
                    css2[styleKey] = styleFunctionSx2({
                      sx: value,
                      theme
                    });
                  } else {
                    css2 = merge(css2, breakpointsValues);
                  }
                }
              } else {
                css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
              }
            }
          });
          return removeUnusedBreakpoints(breakpointsKeys, css2);
        }
        return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
      }
      return styleFunctionSx2;
    }
    const styleFunctionSx = unstable_createStyleFunctionSx();
    styleFunctionSx.filterProps = ["sx"];
    const styleFunctionSx$1 = styleFunctionSx;
    const _excluded$1c = ["breakpoints", "palette", "spacing", "shape"];
    function createTheme$1(options = {}, ...args) {
      const {
        breakpoints: breakpointsInput = {},
        palette: paletteInput = {},
        spacing: spacingInput,
        shape: shapeInput = {}
      } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$1c);
      const breakpoints = createBreakpoints(breakpointsInput);
      const spacing = createSpacing(spacingInput);
      let muiTheme = deepmerge({
        breakpoints,
        direction: "ltr",
        components: {},
        // Inject component definitions.
        palette: _extends$1({
          mode: "light"
        }, paletteInput),
        spacing,
        shape: _extends$1({}, shape$1, shapeInput)
      }, other);
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
      muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
          sx: props,
          theme: this
        });
      };
      return muiTheme;
    }
    function isObjectEmpty(obj) {
      return Object.keys(obj).length === 0;
    }
    function useTheme$2(defaultTheme2 = null) {
      const contextTheme = reactExports.useContext(ThemeContext);
      return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
    }
    const systemDefaultTheme$1 = createTheme$1();
    function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
      return useTheme$2(defaultTheme2);
    }
    function GlobalStyles$1({
      styles: styles2,
      themeId,
      defaultTheme: defaultTheme2 = {}
    }) {
      const upperTheme = useTheme$1(defaultTheme2);
      const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
        styles: globalStyles
      });
    }
    const _excluded$1b = ["sx"];
    const splitProps = (props) => {
      var _props$theme$unstable, _props$theme;
      const result = {
        systemProps: {},
        otherProps: {}
      };
      const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
      Object.keys(props).forEach((prop) => {
        if (config2[prop]) {
          result.systemProps[prop] = props[prop];
        } else {
          result.otherProps[prop] = props[prop];
        }
      });
      return result;
    };
    function extendSxProp(props) {
      const {
        sx: inSx
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1b);
      const {
        systemProps,
        otherProps
      } = splitProps(other);
      let finalSx;
      if (Array.isArray(inSx)) {
        finalSx = [systemProps, ...inSx];
      } else if (typeof inSx === "function") {
        finalSx = (...args) => {
          const result = inSx(...args);
          if (!isPlainObject$2(result)) {
            return systemProps;
          }
          return _extends$1({}, systemProps, result);
        };
      } else {
        finalSx = _extends$1({}, systemProps, inSx);
      }
      return _extends$1({}, otherProps, {
        sx: finalSx
      });
    }
    function r$2(e2) {
      var t2, f2, n2 = "";
      if ("string" == typeof e2 || "number" == typeof e2)
        n2 += e2;
      else if ("object" == typeof e2)
        if (Array.isArray(e2))
          for (t2 = 0; t2 < e2.length; t2++)
            e2[t2] && (f2 = r$2(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
        else
          for (t2 in e2)
            e2[t2] && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    function clsx$1() {
      for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
        (e2 = arguments[f2++]) && (t2 = r$2(e2)) && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    const _excluded$1a = ["className", "component"];
    function createBox(options = {}) {
      const {
        themeId,
        defaultTheme: defaultTheme2,
        defaultClassName = "MuiBox-root",
        generateClassName
      } = options;
      const BoxRoot = styled$3("div", {
        shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
      })(styleFunctionSx$1);
      const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
        const theme = useTheme$1(defaultTheme2);
        const _extendSxProp = extendSxProp(inProps), {
          className,
          component = "div"
        } = _extendSxProp, other = _objectWithoutPropertiesLoose$1(_extendSxProp, _excluded$1a);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, _extends$1({
          as: component,
          ref,
          className: clsx$1(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
          theme: themeId ? theme[themeId] || theme : theme
        }, other));
      });
      return Box2;
    }
    const _excluded$19 = ["variant"];
    function isEmpty$3(string) {
      return string.length === 0;
    }
    function propsToClassKey(props) {
      const {
        variant
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$19);
      let classKey = variant || "";
      Object.keys(other).sort().forEach((key) => {
        if (key === "color") {
          classKey += isEmpty$3(classKey) ? props[key] : capitalize(props[key]);
        } else {
          classKey += `${isEmpty$3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
        }
      });
      return classKey;
    }
    const _excluded$18 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
    function isEmpty$2(obj) {
      return Object.keys(obj).length === 0;
    }
    function isStringTag(tag) {
      return typeof tag === "string" && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      tag.charCodeAt(0) > 96;
    }
    const getStyleOverrides = (name, theme) => {
      if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
        return theme.components[name].styleOverrides;
      }
      return null;
    };
    const getVariantStyles = (name, theme) => {
      let variants = [];
      if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
        variants = theme.components[name].variants;
      }
      const variantsStyles = {};
      variants.forEach((definition) => {
        const key = propsToClassKey(definition.props);
        variantsStyles[key] = definition.style;
      });
      return variantsStyles;
    };
    const variantsResolver = (props, styles2, theme, name) => {
      var _theme$components;
      const {
        ownerState = {}
      } = props;
      const variantsStyles = [];
      const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[name]) == null ? void 0 : _theme$components.variants;
      if (themeVariants) {
        themeVariants.forEach((themeVariant) => {
          let isMatch = true;
          Object.keys(themeVariant.props).forEach((key) => {
            if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
              isMatch = false;
            }
          });
          if (isMatch) {
            variantsStyles.push(styles2[propsToClassKey(themeVariant.props)]);
          }
        });
      }
      return variantsStyles;
    };
    function shouldForwardProp(prop) {
      return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
    }
    const systemDefaultTheme = createTheme$1();
    const lowercaseFirstLetter = (string) => {
      if (!string) {
        return string;
      }
      return string.charAt(0).toLowerCase() + string.slice(1);
    };
    function resolveTheme({
      defaultTheme: defaultTheme2,
      theme,
      themeId
    }) {
      return isEmpty$2(theme) ? defaultTheme2 : theme[themeId] || theme;
    }
    function defaultOverridesResolver(slot) {
      if (!slot) {
        return null;
      }
      return (props, styles2) => styles2[slot];
    }
    function createStyled(input = {}) {
      const {
        themeId,
        defaultTheme: defaultTheme2 = systemDefaultTheme,
        rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
        slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
      } = input;
      const systemSx = (props) => {
        return styleFunctionSx$1(_extends$1({}, props, {
          theme: resolveTheme(_extends$1({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }))
        }));
      };
      systemSx.__mui_systemSx = true;
      return (tag, inputOptions = {}) => {
        internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
        const {
          name: componentName,
          slot: componentSlot,
          skipVariantsResolver: inputSkipVariantsResolver,
          skipSx: inputSkipSx,
          // TODO v6: remove `lowercaseFirstLetter()` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
        } = inputOptions, options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded$18);
        const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
          // TODO v6: remove `Root` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
        );
        const skipSx = inputSkipSx || false;
        let label;
        let shouldForwardPropOption = shouldForwardProp;
        if (componentSlot === "Root" || componentSlot === "root") {
          shouldForwardPropOption = rootShouldForwardProp2;
        } else if (componentSlot) {
          shouldForwardPropOption = slotShouldForwardProp2;
        } else if (isStringTag(tag)) {
          shouldForwardPropOption = void 0;
        }
        const defaultStyledResolver = styled$3(tag, _extends$1({
          shouldForwardProp: shouldForwardPropOption,
          label
        }, options));
        const muiStyledResolver = (styleArg2, ...expressions) => {
          const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
            return typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg ? (props) => {
              return stylesArg(_extends$1({}, props, {
                theme: resolveTheme(_extends$1({}, props, {
                  defaultTheme: defaultTheme2,
                  themeId
                }))
              }));
            } : stylesArg;
          }) : [];
          let transformedStyleArg = styleArg2;
          if (componentName && overridesResolver2) {
            expressionsWithDefaultTheme.push((props) => {
              const theme = resolveTheme(_extends$1({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }));
              const styleOverrides = getStyleOverrides(componentName, theme);
              if (styleOverrides) {
                const resolvedStyleOverrides = {};
                Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                  resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends$1({}, props, {
                    theme
                  })) : slotStyle;
                });
                return overridesResolver2(props, resolvedStyleOverrides);
              }
              return null;
            });
          }
          if (componentName && !skipVariantsResolver) {
            expressionsWithDefaultTheme.push((props) => {
              const theme = resolveTheme(_extends$1({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }));
              return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
            });
          }
          if (!skipSx) {
            expressionsWithDefaultTheme.push(systemSx);
          }
          const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
          if (Array.isArray(styleArg2) && numOfCustomFnsApplied > 0) {
            const placeholders = new Array(numOfCustomFnsApplied).fill("");
            transformedStyleArg = [...styleArg2, ...placeholders];
            transformedStyleArg.raw = [...styleArg2.raw, ...placeholders];
          } else if (typeof styleArg2 === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
          // component stays as a function. This condition makes sure that we do not interpolate functions
          // which are basically components used as a selectors.
          styleArg2.__emotion_real !== styleArg2) {
            transformedStyleArg = (props) => styleArg2(_extends$1({}, props, {
              theme: resolveTheme(_extends$1({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }))
            }));
          }
          const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
          if (tag.muiName) {
            Component.muiName = tag.muiName;
          }
          return Component;
        };
        if (defaultStyledResolver.withConfig) {
          muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
        }
        return muiStyledResolver;
      };
    }
    const styled$2 = createStyled();
    const systemStyled = styled$2;
    function getThemeProps(params) {
      const {
        theme,
        name,
        props
      } = params;
      if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
        return props;
      }
      return resolveProps(theme.components[name].defaultProps, props);
    }
    function useThemeProps$1({
      props,
      name,
      defaultTheme: defaultTheme2,
      themeId
    }) {
      let theme = useTheme$1(defaultTheme2);
      if (themeId) {
        theme = theme[themeId] || theme;
      }
      const mergedProps = getThemeProps({
        theme,
        name,
        props
      });
      return mergedProps;
    }
    function clamp(value, min = 0, max = 1) {
      return Math.min(Math.max(min, value), max);
    }
    function hexToRgb(color2) {
      color2 = color2.slice(1);
      const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
      let colors = color2.match(re2);
      if (colors && colors[0].length === 1) {
        colors = colors.map((n2) => n2 + n2);
      }
      return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
        return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
      }).join(", ")})` : "";
    }
    function decomposeColor(color2) {
      if (color2.type) {
        return color2;
      }
      if (color2.charAt(0) === "#") {
        return decomposeColor(hexToRgb(color2));
      }
      const marker = color2.indexOf("(");
      const type = color2.substring(0, marker);
      if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
        throw new Error(formatMuiErrorMessage(9, color2));
      }
      let values2 = color2.substring(marker + 1, color2.length - 1);
      let colorSpace;
      if (type === "color") {
        values2 = values2.split(" ");
        colorSpace = values2.shift();
        if (values2.length === 4 && values2[3].charAt(0) === "/") {
          values2[3] = values2[3].slice(1);
        }
        if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
          throw new Error(formatMuiErrorMessage(10, colorSpace));
        }
      } else {
        values2 = values2.split(",");
      }
      values2 = values2.map((value) => parseFloat(value));
      return {
        type,
        values: values2,
        colorSpace
      };
    }
    function recomposeColor(color2) {
      const {
        type,
        colorSpace
      } = color2;
      let {
        values: values2
      } = color2;
      if (type.indexOf("rgb") !== -1) {
        values2 = values2.map((n2, i2) => i2 < 3 ? parseInt(n2, 10) : n2);
      } else if (type.indexOf("hsl") !== -1) {
        values2[1] = `${values2[1]}%`;
        values2[2] = `${values2[2]}%`;
      }
      if (type.indexOf("color") !== -1) {
        values2 = `${colorSpace} ${values2.join(" ")}`;
      } else {
        values2 = `${values2.join(", ")}`;
      }
      return `${type}(${values2})`;
    }
    function hslToRgb(color2) {
      color2 = decomposeColor(color2);
      const {
        values: values2
      } = color2;
      const h2 = values2[0];
      const s2 = values2[1] / 100;
      const l2 = values2[2] / 100;
      const a2 = s2 * Math.min(l2, 1 - l2);
      const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
      let type = "rgb";
      const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
      if (color2.type === "hsla") {
        type += "a";
        rgb.push(values2[3]);
      }
      return recomposeColor({
        type,
        values: rgb
      });
    }
    function getLuminance(color2) {
      color2 = decomposeColor(color2);
      let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
      rgb = rgb.map((val) => {
        if (color2.type !== "color") {
          val /= 255;
        }
        return val <= 0.03928 ? val / 12.92 : __pow((val + 0.055) / 1.055, 2.4);
      });
      return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
    }
    function getContrastRatio(foreground, background) {
      const lumA = getLuminance(foreground);
      const lumB = getLuminance(background);
      return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
    }
    function alpha(color2, value) {
      color2 = decomposeColor(color2);
      value = clamp(value);
      if (color2.type === "rgb" || color2.type === "hsl") {
        color2.type += "a";
      }
      if (color2.type === "color") {
        color2.values[3] = `/${value}`;
      } else {
        color2.values[3] = value;
      }
      return recomposeColor(color2);
    }
    function darken(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clamp(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] *= 1 - coefficient;
      } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
        for (let i2 = 0; i2 < 3; i2 += 1) {
          color2.values[i2] *= 1 - coefficient;
        }
      }
      return recomposeColor(color2);
    }
    function lighten(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clamp(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] += (100 - color2.values[2]) * coefficient;
      } else if (color2.type.indexOf("rgb") !== -1) {
        for (let i2 = 0; i2 < 3; i2 += 1) {
          color2.values[i2] += (255 - color2.values[i2]) * coefficient;
        }
      } else if (color2.type.indexOf("color") !== -1) {
        for (let i2 = 0; i2 < 3; i2 += 1) {
          color2.values[i2] += (1 - color2.values[i2]) * coefficient;
        }
      }
      return recomposeColor(color2);
    }
    const _excluded$17 = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"];
    const defaultTheme$3 = createTheme$1();
    const defaultCreateStyledComponent = systemStyled("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    });
    function useThemePropsDefault(props) {
      return useThemeProps$1({
        props,
        name: "MuiStack",
        defaultTheme: defaultTheme$3
      });
    }
    function joinChildren(children, separator) {
      const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
      return childrenArray.reduce((output, child, index2) => {
        output.push(child);
        if (index2 < childrenArray.length - 1) {
          output.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
            key: `separator-${index2}`
          }));
        }
        return output;
      }, []);
    }
    const getSideFromDirection = (direction) => {
      return {
        row: "Left",
        "row-reverse": "Right",
        column: "Top",
        "column-reverse": "Bottom"
      }[direction];
    };
    const style$1 = ({
      ownerState,
      theme
    }) => {
      let styles2 = _extends$1({
        display: "flex",
        flexDirection: "column"
      }, handleBreakpoints({
        theme
      }, resolveBreakpointValues({
        values: ownerState.direction,
        breakpoints: theme.breakpoints.values
      }), (propValue) => ({
        flexDirection: propValue
      })));
      if (ownerState.spacing) {
        const transformer = createUnarySpacing(theme);
        const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
          if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
            acc[breakpoint] = true;
          }
          return acc;
        }, {});
        const directionValues = resolveBreakpointValues({
          values: ownerState.direction,
          base
        });
        const spacingValues = resolveBreakpointValues({
          values: ownerState.spacing,
          base
        });
        if (typeof directionValues === "object") {
          Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
            const directionValue = directionValues[breakpoint];
            if (!directionValue) {
              const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
              directionValues[breakpoint] = previousDirectionValue;
            }
          });
        }
        const styleFromPropValue = (propValue, breakpoint) => {
          if (ownerState.useFlexGap) {
            return {
              gap: getValue(transformer, propValue)
            };
          }
          return {
            // The useFlexGap={false} implement relies on each child to give up control of the margin.
            // We need to reset the margin to avoid double spacing.
            "& > :not(style):not(style)": {
              margin: 0
            },
            "& > :not(style) ~ :not(style)": {
              [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
            }
          };
        };
        styles2 = deepmerge(styles2, handleBreakpoints({
          theme
        }, spacingValues, styleFromPropValue));
      }
      styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
      return styles2;
    };
    function createStack(options = {}) {
      const {
        // This will allow adding custom styled fn (for example for custom sx style function)
        createStyledComponent = defaultCreateStyledComponent,
        useThemeProps: useThemeProps2 = useThemePropsDefault,
        componentName = "MuiStack"
      } = options;
      const useUtilityClasses2 = () => {
        const slots = {
          root: ["root"]
        };
        return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
      };
      const StackRoot = createStyledComponent(style$1);
      const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref) {
        const themeProps = useThemeProps2(inProps);
        const props = extendSxProp(themeProps);
        const {
          component = "div",
          direction = "column",
          spacing = 0,
          divider,
          children,
          className,
          useFlexGap = false
        } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$17);
        const ownerState = {
          direction,
          spacing,
          useFlexGap
        };
        const classes = useUtilityClasses2();
        return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, _extends$1({
          as: component,
          ownerState,
          ref,
          className: clsx$1(classes.root, className)
        }, other, {
          children: divider ? joinChildren(children, divider) : children
        }));
      });
      return Stack2;
    }
    function createMixins(breakpoints, mixins) {
      return _extends$1({
        toolbar: {
          minHeight: 56,
          [breakpoints.up("xs")]: {
            "@media (orientation: landscape)": {
              minHeight: 48
            }
          },
          [breakpoints.up("sm")]: {
            minHeight: 64
          }
        }
      }, mixins);
    }
    const _excluded$16 = ["mode", "contrastThreshold", "tonalOffset"];
    const light = {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: common$2.white,
        default: common$2.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
    const dark = {
      text: {
        primary: common$2.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common$2.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
    function addLightOrDark(intent, direction, shade, tonalOffset) {
      const tonalOffsetLight = tonalOffset.light || tonalOffset;
      const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
      if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) {
          intent[direction] = intent[shade];
        } else if (direction === "light") {
          intent.light = lighten(intent.main, tonalOffsetLight);
        } else if (direction === "dark") {
          intent.dark = darken(intent.main, tonalOffsetDark);
        }
      }
    }
    function getDefaultPrimary(mode = "light") {
      if (mode === "dark") {
        return {
          main: blue$1[200],
          light: blue$1[50],
          dark: blue$1[400]
        };
      }
      return {
        main: blue$1[700],
        light: blue$1[400],
        dark: blue$1[800]
      };
    }
    function getDefaultSecondary(mode = "light") {
      if (mode === "dark") {
        return {
          main: purple$1[200],
          light: purple$1[50],
          dark: purple$1[400]
        };
      }
      return {
        main: purple$1[500],
        light: purple$1[300],
        dark: purple$1[700]
      };
    }
    function getDefaultError(mode = "light") {
      if (mode === "dark") {
        return {
          main: red$1[500],
          light: red$1[300],
          dark: red$1[700]
        };
      }
      return {
        main: red$1[700],
        light: red$1[400],
        dark: red$1[800]
      };
    }
    function getDefaultInfo(mode = "light") {
      if (mode === "dark") {
        return {
          main: lightBlue$1[400],
          light: lightBlue$1[300],
          dark: lightBlue$1[700]
        };
      }
      return {
        main: lightBlue$1[700],
        light: lightBlue$1[500],
        dark: lightBlue$1[900]
      };
    }
    function getDefaultSuccess(mode = "light") {
      if (mode === "dark") {
        return {
          main: green$1[400],
          light: green$1[300],
          dark: green$1[700]
        };
      }
      return {
        main: green$1[800],
        light: green$1[500],
        dark: green$1[900]
      };
    }
    function getDefaultWarning(mode = "light") {
      if (mode === "dark") {
        return {
          main: orange$1[400],
          light: orange$1[300],
          dark: orange$1[700]
        };
      }
      return {
        main: "#ed6c02",
        // closest to orange[800] that pass 3:1.
        light: orange$1[500],
        dark: orange$1[900]
      };
    }
    function createPalette(palette) {
      const {
        mode = "light",
        contrastThreshold = 3,
        tonalOffset = 0.2
      } = palette, other = _objectWithoutPropertiesLoose$1(palette, _excluded$16);
      const primary = palette.primary || getDefaultPrimary(mode);
      const secondary = palette.secondary || getDefaultSecondary(mode);
      const error = palette.error || getDefaultError(mode);
      const info = palette.info || getDefaultInfo(mode);
      const success = palette.success || getDefaultSuccess(mode);
      const warning = palette.warning || getDefaultWarning(mode);
      function getContrastText(background) {
        const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
        return contrastText;
      }
      const augmentColor = ({
        color: color2,
        name,
        mainShade = 500,
        lightShade = 300,
        darkShade = 700
      }) => {
        color2 = _extends$1({}, color2);
        if (!color2.main && color2[mainShade]) {
          color2.main = color2[mainShade];
        }
        if (!color2.hasOwnProperty("main")) {
          throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
        }
        if (typeof color2.main !== "string") {
          throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
        }
        addLightOrDark(color2, "light", lightShade, tonalOffset);
        addLightOrDark(color2, "dark", darkShade, tonalOffset);
        if (!color2.contrastText) {
          color2.contrastText = getContrastText(color2.main);
        }
        return color2;
      };
      const modes = {
        dark,
        light
      };
      const paletteOutput = deepmerge(_extends$1({
        // A collection of common colors.
        common: _extends$1({}, common$2),
        // prevent mutable object.
        // The palette mode, can be light or dark.
        mode,
        // The colors used to represent primary interface elements for a user.
        primary: augmentColor({
          color: primary,
          name: "primary"
        }),
        // The colors used to represent secondary interface elements for a user.
        secondary: augmentColor({
          color: secondary,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700"
        }),
        // The colors used to represent interface elements that the user should be made aware of.
        error: augmentColor({
          color: error,
          name: "error"
        }),
        // The colors used to represent potentially dangerous actions or important messages.
        warning: augmentColor({
          color: warning,
          name: "warning"
        }),
        // The colors used to present information to the user that is neutral and not necessarily important.
        info: augmentColor({
          color: info,
          name: "info"
        }),
        // The colors used to indicate the successful completion of an action that user triggered.
        success: augmentColor({
          color: success,
          name: "success"
        }),
        // The grey colors.
        grey: grey$1,
        // Used by `getContrastText()` to maximize the contrast between
        // the background and the text.
        contrastThreshold,
        // Takes a background color and returns the text color that maximizes the contrast.
        getContrastText,
        // Generate a rich color object.
        augmentColor,
        // Used by the functions below to shift a color's luminance by approximately
        // two indexes within its tonal palette.
        // E.g., shift from Red 500 to Red 300 or Red 700.
        tonalOffset
      }, modes[mode]), other);
      return paletteOutput;
    }
    const _excluded$15 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
    function round(value) {
      return Math.round(value * 1e5) / 1e5;
    }
    const caseAllCaps = {
      textTransform: "uppercase"
    };
    const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
    function createTypography(palette, typography) {
      const _ref = typeof typography === "function" ? typography(palette) : typography, {
        fontFamily = defaultFontFamily,
        // The default font size of the Material Specification.
        fontSize = 14,
        // px
        fontWeightLight = 300,
        fontWeightRegular = 400,
        fontWeightMedium = 500,
        fontWeightBold = 700,
        // Tell MUI what's the font-size on the html element.
        // 16px is the default font-size used by browsers.
        htmlFontSize = 16,
        // Apply the CSS properties to all the variants.
        allVariants,
        pxToRem: pxToRem2
      } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$15);
      const coef = fontSize / 14;
      const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
      const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$1({
        fontFamily,
        fontWeight,
        fontSize: pxToRem(size),
        // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
        lineHeight
      }, fontFamily === defaultFontFamily ? {
        letterSpacing: `${round(letterSpacing / size)}em`
      } : {}, casing, allVariants);
      const variants = {
        h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
        // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
        inherit: {
          fontFamily: "inherit",
          fontWeight: "inherit",
          fontSize: "inherit",
          lineHeight: "inherit",
          letterSpacing: "inherit"
        }
      };
      return deepmerge(_extends$1({
        htmlFontSize,
        pxToRem,
        fontFamily,
        fontSize,
        fontWeightLight,
        fontWeightRegular,
        fontWeightMedium,
        fontWeightBold
      }, variants), other, {
        clone: false
        // No need to clone deep
      });
    }
    const shadowKeyUmbraOpacity = 0.2;
    const shadowKeyPenumbraOpacity = 0.14;
    const shadowAmbientShadowOpacity = 0.12;
    function createShadow(...px) {
      return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
    }
    const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
    const shadows$1 = shadows;
    const _excluded$14 = ["duration", "easing", "delay"];
    const easing = {
      // This is the most common easing curve.
      easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
      // Objects enter the screen at full velocity from off-screen and
      // slowly decelerate to a resting point.
      easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
      // Objects leave the screen at full velocity. They do not decelerate when off-screen.
      easeIn: "cubic-bezier(0.4, 0, 1, 1)",
      // The sharp curve is used by objects that may return to the screen at any time.
      sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    };
    const duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      // most basic recommended timing
      standard: 300,
      // this is to be used in complex animations
      complex: 375,
      // recommended when something is entering screen
      enteringScreen: 225,
      // recommended when something is leaving screen
      leavingScreen: 195
    };
    function formatMs(milliseconds) {
      return `${Math.round(milliseconds)}ms`;
    }
    function getAutoHeightDuration(height2) {
      if (!height2) {
        return 0;
      }
      const constant = height2 / 36;
      return Math.round((4 + 15 * __pow(constant, 0.25) + constant / 5) * 10);
    }
    function createTransitions(inputTransitions) {
      const mergedEasing = _extends$1({}, easing, inputTransitions.easing);
      const mergedDuration = _extends$1({}, duration, inputTransitions.duration);
      const create = (props = ["all"], options = {}) => {
        const {
          duration: durationOption = mergedDuration.standard,
          easing: easingOption = mergedEasing.easeInOut,
          delay = 0
        } = options;
        _objectWithoutPropertiesLoose$1(options, _excluded$14);
        return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
      };
      return _extends$1({
        getAutoHeightDuration,
        create
      }, inputTransitions, {
        easing: mergedEasing,
        duration: mergedDuration
      });
    }
    const zIndex = {
      mobileStepper: 1e3,
      fab: 1050,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };
    const zIndex$1 = zIndex;
    const _excluded$13 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
    function createTheme(options = {}, ...args) {
      const {
        mixins: mixinsInput = {},
        palette: paletteInput = {},
        transitions: transitionsInput = {},
        typography: typographyInput = {}
      } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$13);
      if (options.vars) {
        throw new Error(formatMuiErrorMessage(18));
      }
      const palette = createPalette(paletteInput);
      const systemTheme = createTheme$1(options);
      let muiTheme = deepmerge(systemTheme, {
        mixins: createMixins(systemTheme.breakpoints, mixinsInput),
        palette,
        // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
        shadows: shadows$1.slice(),
        typography: createTypography(palette, typographyInput),
        transitions: createTransitions(transitionsInput),
        zIndex: _extends$1({}, zIndex$1)
      });
      muiTheme = deepmerge(muiTheme, other);
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
      muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
          sx: props,
          theme: this
        });
      };
      return muiTheme;
    }
    const defaultTheme$1 = createTheme();
    const defaultTheme$2 = defaultTheme$1;
    function useTheme() {
      const theme = useTheme$1(defaultTheme$2);
      return theme[THEME_ID] || theme;
    }
    function useThemeProps({
      props,
      name
    }) {
      return useThemeProps$1({
        props,
        name,
        defaultTheme: defaultTheme$2,
        themeId: THEME_ID
      });
    }
    const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
    const slotShouldForwardProp = shouldForwardProp;
    const styled = createStyled({
      themeId: THEME_ID,
      defaultTheme: defaultTheme$2,
      rootShouldForwardProp
    });
    const styled$1 = styled;
    const getOverlayAlpha = (elevation) => {
      let alphaValue;
      if (elevation < 1) {
        alphaValue = 5.11916 * __pow(elevation, 2);
      } else {
        alphaValue = 4.5 * Math.log(elevation + 1) + 2;
      }
      return (alphaValue / 100).toFixed(2);
    };
    const getOverlayAlpha$1 = getOverlayAlpha;
    function getSvgIconUtilityClass(slot) {
      return generateUtilityClass("MuiSvgIcon", slot);
    }
    generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
    const _excluded$12 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
    const useUtilityClasses$T = (ownerState) => {
      const {
        color: color2,
        fontSize,
        classes
      } = ownerState;
      const slots = {
        root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
      };
      return composeClasses(slots, getSvgIconUtilityClass, classes);
    };
    const SvgIconRoot = styled$1("svg", {
      name: "MuiSvgIcon",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
      return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        // the <svg> will define the property that has `currentColor`
        // e.g. heroicons uses fill="none" and stroke="currentColor"
        fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
        flexShrink: 0,
        transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
          duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
        }),
        fontSize: {
          inherit: "inherit",
          small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
          medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
          large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
        }[ownerState.fontSize],
        // TODO v5 deprecate, v6 remove for sx
        color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
          action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
          disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
          inherit: void 0
        }[ownerState.color]
      };
    });
    const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiSvgIcon"
      });
      const {
        children,
        className,
        color: color2 = "inherit",
        component = "svg",
        fontSize = "medium",
        htmlColor,
        inheritViewBox = false,
        titleAccess,
        viewBox = "0 0 24 24"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$12);
      const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        fontSize,
        instanceFontSize: inProps.fontSize,
        inheritViewBox,
        viewBox,
        hasSvgAsChild
      });
      const more = {};
      if (!inheritViewBox) {
        more.viewBox = viewBox;
      }
      const classes = useUtilityClasses$T(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$1({
        as: component,
        className: clsx$1(classes.root, className),
        focusable: "false",
        color: htmlColor,
        "aria-hidden": titleAccess ? void 0 : true,
        role: titleAccess ? "img" : void 0,
        ref
      }, more, other, hasSvgAsChild && children.props, {
        ownerState,
        children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
          children: titleAccess
        }) : null]
      }));
    });
    SvgIcon.muiName = "SvgIcon";
    const SvgIcon$1 = SvgIcon;
    function createSvgIcon(path, displayName) {
      function Component(props, ref) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon$1, _extends$1({
          "data-testid": `${displayName}Icon`,
          ref
        }, props, {
          children: path
        }));
      }
      Component.muiName = SvgIcon$1.muiName;
      return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function hasClass(element, className) {
      if (element.classList)
        return !!className && element.classList.contains(className);
      return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
    }
    function addClass(element, className) {
      if (element.classList)
        element.classList.add(className);
      else if (!hasClass(element, className))
        if (typeof element.className === "string")
          element.className = element.className + " " + className;
        else
          element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
    }
    function replaceClassName(origClass, classToRemove) {
      return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
    }
    function removeClass$1(element, className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (typeof element.className === "string") {
        element.className = replaceClassName(element.className, className);
      } else {
        element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
      }
    }
    const config = {
      disabled: false
    };
    const TransitionGroupContext = React.createContext(null);
    var forceReflow = function forceReflow2(node2) {
      return node2.scrollTop;
    };
    var UNMOUNTED = "unmounted";
    var EXITED = "exited";
    var ENTERING = "entering";
    var ENTERED = "entered";
    var EXITING = "exiting";
    var Transition = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(Transition2, _React$Component);
      function Transition2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context;
        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }
        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }
      Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }
        return null;
      };
      var _proto = Transition2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
          var status = this.state.status;
          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }
        this.updateStatus(false, nextStatus);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };
      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;
        if (timeout != null && typeof timeout !== "number") {
          exit = timeout.exit;
          enter = timeout.enter;
          appear = timeout.appear !== void 0 ? timeout.appear : enter;
        }
        return {
          exit,
          enter,
          appear
        };
      };
      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }
        if (nextStatus !== null) {
          this.cancelNextCallback();
          if (nextStatus === ENTERING) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
              if (node2)
                forceReflow(node2);
            }
            this.performEnter(mounting);
          } else {
            this.performExit();
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };
      _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode);
          });
          return;
        }
        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
          status: ENTERING
        }, function() {
          _this2.props.onEntering(maybeNode, maybeAppearing);
          _this2.onTransitionEnd(enterTimeout, function() {
            _this2.safeSetState({
              status: ENTERED
            }, function() {
              _this2.props.onEntered(maybeNode, maybeAppearing);
            });
          });
        });
      };
      _proto.performExit = function performExit() {
        var _this3 = this;
        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!exit || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
          return;
        }
        this.props.onExit(maybeNode);
        this.safeSetState({
          status: EXITING
        }, function() {
          _this3.props.onExiting(maybeNode);
          _this3.onTransitionEnd(timeouts.exit, function() {
            _this3.safeSetState({
              status: EXITED
            }, function() {
              _this3.props.onExited(maybeNode);
            });
          });
        });
      };
      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };
      _proto.safeSetState = function safeSetState(nextState, callback) {
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };
      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };
        this.nextCallback.cancel = function() {
          active = false;
        };
        return this.nextCallback;
      };
      _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
        this.setNextCallback(handler);
        var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
        if (!node2 || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
          this.props.addEndListener(maybeNode, maybeNextCallback);
        }
        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      };
      _proto.render = function render2() {
        var status = this.state.status;
        if (status === UNMOUNTED) {
          return null;
        }
        var _this$props = this.props, children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return (
          // allows for nested Transitions
          /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
            value: null
          }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
        );
      };
      return Transition2;
    }(React.Component);
    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = {};
    function noop$1() {
    }
    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop$1,
      onEntering: noop$1,
      onEntered: noop$1,
      onExit: noop$1,
      onExiting: noop$1,
      onExited: noop$1
    };
    Transition.UNMOUNTED = UNMOUNTED;
    Transition.EXITED = EXITED;
    Transition.ENTERING = ENTERING;
    Transition.ENTERED = ENTERED;
    Transition.EXITING = EXITING;
    const Transition$1 = Transition;
    var _addClass = function addClass$1(node2, classes) {
      return node2 && classes && classes.split(" ").forEach(function(c2) {
        return addClass(node2, c2);
      });
    };
    var removeClass = function removeClass2(node2, classes) {
      return node2 && classes && classes.split(" ").forEach(function(c2) {
        return removeClass$1(node2, c2);
      });
    };
    var CSSTransition = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(CSSTransition2, _React$Component);
      function CSSTransition2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.appliedClasses = {
          appear: {},
          enter: {},
          exit: {}
        };
        _this.onEnter = function(maybeNode, maybeAppearing) {
          var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
          _this.removeClasses(node2, "exit");
          _this.addClass(node2, appearing ? "appear" : "enter", "base");
          if (_this.props.onEnter) {
            _this.props.onEnter(maybeNode, maybeAppearing);
          }
        };
        _this.onEntering = function(maybeNode, maybeAppearing) {
          var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
          var type = appearing ? "appear" : "enter";
          _this.addClass(node2, type, "active");
          if (_this.props.onEntering) {
            _this.props.onEntering(maybeNode, maybeAppearing);
          }
        };
        _this.onEntered = function(maybeNode, maybeAppearing) {
          var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
          var type = appearing ? "appear" : "enter";
          _this.removeClasses(node2, type);
          _this.addClass(node2, type, "done");
          if (_this.props.onEntered) {
            _this.props.onEntered(maybeNode, maybeAppearing);
          }
        };
        _this.onExit = function(maybeNode) {
          var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
          _this.removeClasses(node2, "appear");
          _this.removeClasses(node2, "enter");
          _this.addClass(node2, "exit", "base");
          if (_this.props.onExit) {
            _this.props.onExit(maybeNode);
          }
        };
        _this.onExiting = function(maybeNode) {
          var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
          _this.addClass(node2, "exit", "active");
          if (_this.props.onExiting) {
            _this.props.onExiting(maybeNode);
          }
        };
        _this.onExited = function(maybeNode) {
          var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
          _this.removeClasses(node2, "exit");
          _this.addClass(node2, "exit", "done");
          if (_this.props.onExited) {
            _this.props.onExited(maybeNode);
          }
        };
        _this.resolveArguments = function(maybeNode, maybeAppearing) {
          return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
        };
        _this.getClassNames = function(type) {
          var classNames = _this.props.classNames;
          var isStringClassNames = typeof classNames === "string";
          var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
          var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames[type];
          var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
          var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
          return {
            baseClassName,
            activeClassName,
            doneClassName
          };
        };
        return _this;
      }
      var _proto = CSSTransition2.prototype;
      _proto.addClass = function addClass2(node2, type, phase) {
        var className = this.getClassNames(type)[phase + "ClassName"];
        var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
        if (type === "appear" && phase === "done" && doneClassName) {
          className += " " + doneClassName;
        }
        if (phase === "active") {
          if (node2)
            forceReflow(node2);
        }
        if (className) {
          this.appliedClasses[type][phase] = className;
          _addClass(node2, className);
        }
      };
      _proto.removeClasses = function removeClasses(node2, type) {
        var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
        this.appliedClasses[type] = {};
        if (baseClassName) {
          removeClass(node2, baseClassName);
        }
        if (activeClassName) {
          removeClass(node2, activeClassName);
        }
        if (doneClassName) {
          removeClass(node2, doneClassName);
        }
      };
      _proto.render = function render2() {
        var _this$props = this.props;
        _this$props.classNames;
        var props = _objectWithoutPropertiesLoose$1(_this$props, ["classNames"]);
        return /* @__PURE__ */ React.createElement(Transition$1, _extends$1({}, props, {
          onEnter: this.onEnter,
          onEntered: this.onEntered,
          onEntering: this.onEntering,
          onExit: this.onExit,
          onExiting: this.onExiting,
          onExited: this.onExited
        }));
      };
      return CSSTransition2;
    }(React.Component);
    CSSTransition.defaultProps = {
      classNames: ""
    };
    CSSTransition.propTypes = {};
    const CSSTransition$1 = CSSTransition;
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function getChildMapping(children, mapFn) {
      var mapper = function mapper2(child) {
        return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
      };
      var result = /* @__PURE__ */ Object.create(null);
      if (children)
        reactExports.Children.map(children, function(c2) {
          return c2;
        }).forEach(function(child) {
          result[child.key] = mapper(child);
        });
      return result;
    }
    function mergeChildMappings(prev2, next2) {
      prev2 = prev2 || {};
      next2 = next2 || {};
      function getValueForKey(key) {
        return key in next2 ? next2[key] : prev2[key];
      }
      var nextKeysPending = /* @__PURE__ */ Object.create(null);
      var pendingKeys = [];
      for (var prevKey in prev2) {
        if (prevKey in next2) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }
      var i2;
      var childMapping = {};
      for (var nextKey in next2) {
        if (nextKeysPending[nextKey]) {
          for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
            var pendingNextKey = nextKeysPending[nextKey][i2];
            childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
          }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
      }
      for (i2 = 0; i2 < pendingKeys.length; i2++) {
        childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
      }
      return childMapping;
    }
    function getProp(child, prop, props) {
      return props[prop] != null ? props[prop] : child.props[prop];
    }
    function getInitialChildMapping(props, onExited) {
      return getChildMapping(props.children, function(child) {
        return reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          appear: getProp(child, "appear", props),
          enter: getProp(child, "enter", props),
          exit: getProp(child, "exit", props)
        });
      });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
      var nextChildMapping = getChildMapping(nextProps.children);
      var children = mergeChildMappings(prevChildMapping, nextChildMapping);
      Object.keys(children).forEach(function(key) {
        var child = children[key];
        if (!reactExports.isValidElement(child))
          return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
        if (hasNext && (!hasPrev || isLeaving)) {
          children[key] = reactExports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        } else if (!hasNext && hasPrev && !isLeaving) {
          children[key] = reactExports.cloneElement(child, {
            in: false
          });
        } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
          children[key] = reactExports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        }
      });
      return children;
    }
    var values = Object.values || function(obj) {
      return Object.keys(obj).map(function(k2) {
        return obj[k2];
      });
    };
    var defaultProps = {
      component: "div",
      childFactory: function childFactory(child) {
        return child;
      }
    };
    var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(TransitionGroup2, _React$Component);
      function TransitionGroup2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
        _this.state = {
          contextValue: {
            isMounting: true
          },
          handleExited,
          firstRender: true
        };
        return _this;
      }
      var _proto = TransitionGroup2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
          contextValue: {
            isMounting: false
          }
        });
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };
      TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
        return {
          children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
          firstRender: false
        };
      };
      _proto.handleExited = function handleExited(child, node2) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping)
          return;
        if (child.props.onExited) {
          child.props.onExited(node2);
        }
        if (this.mounted) {
          this.setState(function(state) {
            var children = _extends$1({}, state.children);
            delete children[child.key];
            return {
              children
            };
          });
        }
      };
      _proto.render = function render2() {
        var _this$props = this.props, Component = _this$props.component, childFactory = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) {
          return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
            value: contextValue
          }, children);
        }
        return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, /* @__PURE__ */ React.createElement(Component, props, children));
      };
      return TransitionGroup2;
    }(React.Component);
    TransitionGroup.propTypes = {};
    TransitionGroup.defaultProps = defaultProps;
    const TransitionGroup$1 = TransitionGroup;
    const reflow = (node2) => node2.scrollTop;
    function getTransitionProps(props, options) {
      var _style$transitionDura, _style$transitionTimi;
      const {
        timeout,
        easing: easing2,
        style: style2 = {}
      } = props;
      return {
        duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
        easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
        delay: style2.transitionDelay
      };
    }
    function getPaperUtilityClass(slot) {
      return generateUtilityClass("MuiPaper", slot);
    }
    generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
    const _excluded$11 = ["className", "component", "elevation", "square", "variant"];
    const useUtilityClasses$S = (ownerState) => {
      const {
        square,
        elevation,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
      };
      return composeClasses(slots, getPaperUtilityClass, classes);
    };
    const PaperRoot = styled$1("div", {
      name: "MuiPaper",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$vars$overlays;
      return _extends$1({
        backgroundColor: (theme.vars || theme).palette.background.paper,
        color: (theme.vars || theme).palette.text.primary,
        transition: theme.transitions.create("box-shadow")
      }, !ownerState.square && {
        borderRadius: theme.shape.borderRadius
      }, ownerState.variant === "outlined" && {
        border: `1px solid ${(theme.vars || theme).palette.divider}`
      }, ownerState.variant === "elevation" && _extends$1({
        boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
      }, !theme.vars && theme.palette.mode === "dark" && {
        backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))})`
      }, theme.vars && {
        backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
      }));
    });
    const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPaper"
      });
      const {
        className,
        component = "div",
        elevation = 1,
        square = false,
        variant = "elevation"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$11);
      const ownerState = _extends$1({}, props, {
        component,
        elevation,
        square,
        variant
      });
      const classes = useUtilityClasses$S(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx$1(classes.root, className),
        ref
      }, other));
    });
    const Paper$1 = Paper;
    function Ripple(props) {
      const {
        className,
        classes,
        pulsate = false,
        rippleX,
        rippleY,
        rippleSize,
        in: inProp,
        onExited,
        timeout
      } = props;
      const [leaving, setLeaving] = reactExports.useState(false);
      const rippleClassName = clsx$1(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
      const rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
      };
      const childClassName = clsx$1(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
      if (!inProp && !leaving) {
        setLeaving(true);
      }
      reactExports.useEffect(() => {
        if (!inProp && onExited != null) {
          const timeoutId = setTimeout(onExited, timeout);
          return () => {
            clearTimeout(timeoutId);
          };
        }
        return void 0;
      }, [onExited, inProp, timeout]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: rippleClassName,
        style: rippleStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: childClassName
        })
      });
    }
    const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
    const touchRippleClasses$1 = touchRippleClasses;
    const _excluded$10 = ["center", "classes", "className"];
    let _$1 = (t2) => t2, _t, _t2, _t3, _t4;
    const DURATION = 550;
    const DELAY_RIPPLE = 80;
    const enterKeyframe = keyframes(_t || (_t = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
    const exitKeyframe = keyframes(_t2 || (_t2 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
    const pulsateKeyframe = keyframes(_t3 || (_t3 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
    const TouchRippleRoot = styled$1("span", {
      name: "MuiTouchRipple",
      slot: "Root"
    })({
      overflow: "hidden",
      pointerEvents: "none",
      position: "absolute",
      zIndex: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderRadius: "inherit"
    });
    const TouchRippleRipple = styled$1(Ripple, {
      name: "MuiTouchRipple",
      slot: "Ripple"
    })(_t4 || (_t4 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
      theme
    }) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
      theme
    }) => theme.transitions.easing.easeInOut);
    const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTouchRipple"
      });
      const {
        center: centerProp = false,
        classes = {},
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$10);
      const [ripples, setRipples] = reactExports.useState([]);
      const nextKey = reactExports.useRef(0);
      const rippleCallback = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (rippleCallback.current) {
          rippleCallback.current();
          rippleCallback.current = null;
        }
      }, [ripples]);
      const ignoringMouseDown = reactExports.useRef(false);
      const startTimer = reactExports.useRef(0);
      const startTimerCommit = reactExports.useRef(null);
      const container = reactExports.useRef(null);
      reactExports.useEffect(() => {
        return () => {
          if (startTimer.current) {
            clearTimeout(startTimer.current);
          }
        };
      }, []);
      const startCommit = reactExports.useCallback((params) => {
        const {
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb: cb2
        } = params;
        setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
          classes: {
            ripple: clsx$1(classes.ripple, touchRippleClasses$1.ripple),
            rippleVisible: clsx$1(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
            ripplePulsate: clsx$1(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
            child: clsx$1(classes.child, touchRippleClasses$1.child),
            childLeaving: clsx$1(classes.childLeaving, touchRippleClasses$1.childLeaving),
            childPulsate: clsx$1(classes.childPulsate, touchRippleClasses$1.childPulsate)
          },
          timeout: DURATION,
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize
        }, nextKey.current)]);
        nextKey.current += 1;
        rippleCallback.current = cb2;
      }, [classes]);
      const start = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
      }) => {
        const {
          pulsate: pulsate2 = false,
          center = centerProp || options.pulsate,
          fakeElement = false
          // For test purposes
        } = options;
        if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
          ignoringMouseDown.current = false;
          return;
        }
        if ((event == null ? void 0 : event.type) === "touchstart") {
          ignoringMouseDown.current = true;
        }
        const element = fakeElement ? null : container.current;
        const rect = element ? element.getBoundingClientRect() : {
          width: 0,
          height: 0,
          left: 0,
          top: 0
        };
        let rippleX;
        let rippleY;
        let rippleSize;
        if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
          rippleX = Math.round(rect.width / 2);
          rippleY = Math.round(rect.height / 2);
        } else {
          const {
            clientX,
            clientY
          } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
          rippleX = Math.round(clientX - rect.left);
          rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
          rippleSize = Math.sqrt((2 * __pow(rect.width, 2) + __pow(rect.height, 2)) / 3);
          if (rippleSize % 2 === 0) {
            rippleSize += 1;
          }
        } else {
          const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
          const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
          rippleSize = Math.sqrt(__pow(sizeX, 2) + __pow(sizeY, 2));
        }
        if (event != null && event.touches) {
          if (startTimerCommit.current === null) {
            startTimerCommit.current = () => {
              startCommit({
                pulsate: pulsate2,
                rippleX,
                rippleY,
                rippleSize,
                cb: cb2
              });
            };
            startTimer.current = setTimeout(() => {
              if (startTimerCommit.current) {
                startTimerCommit.current();
                startTimerCommit.current = null;
              }
            }, DELAY_RIPPLE);
          }
        } else {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        }
      }, [centerProp, startCommit]);
      const pulsate = reactExports.useCallback(() => {
        start({}, {
          pulsate: true
        });
      }, [start]);
      const stop = reactExports.useCallback((event, cb2) => {
        clearTimeout(startTimer.current);
        if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
          startTimerCommit.current();
          startTimerCommit.current = null;
          startTimer.current = setTimeout(() => {
            stop(event, cb2);
          });
          return;
        }
        startTimerCommit.current = null;
        setRipples((oldRipples) => {
          if (oldRipples.length > 0) {
            return oldRipples.slice(1);
          }
          return oldRipples;
        });
        rippleCallback.current = cb2;
      }, []);
      reactExports.useImperativeHandle(ref, () => ({
        pulsate,
        start,
        stop
      }), [pulsate, start, stop]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$1({
        className: clsx$1(touchRippleClasses$1.root, classes.root, className),
        ref: container
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
          component: null,
          exit: true,
          children: ripples
        })
      }));
    });
    const TouchRipple$1 = TouchRipple;
    function getButtonBaseUtilityClass(slot) {
      return generateUtilityClass("MuiButtonBase", slot);
    }
    const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
    const buttonBaseClasses$1 = buttonBaseClasses;
    const _excluded$$ = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
    const useUtilityClasses$R = (ownerState) => {
      const {
        disabled,
        focusVisible,
        focusVisibleClassName,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
      };
      const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
      if (focusVisible && focusVisibleClassName) {
        composedClasses.root += ` ${focusVisibleClassName}`;
      }
      return composedClasses;
    };
    const ButtonBaseRoot = styled$1("button", {
      name: "MuiButtonBase",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      position: "relative",
      boxSizing: "border-box",
      WebkitTapHighlightColor: "transparent",
      backgroundColor: "transparent",
      // Reset default value
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      border: 0,
      margin: 0,
      // Remove the margin in Safari
      borderRadius: 0,
      padding: 0,
      // Remove the padding in Firefox
      cursor: "pointer",
      userSelect: "none",
      verticalAlign: "middle",
      MozAppearance: "none",
      // Reset
      WebkitAppearance: "none",
      // Reset
      textDecoration: "none",
      // So we take precedent over the style of a native <a /> element.
      color: "inherit",
      "&::-moz-focus-inner": {
        borderStyle: "none"
        // Remove Firefox dotted outline.
      },
      [`&.${buttonBaseClasses$1.disabled}`]: {
        pointerEvents: "none",
        // Disable link interactions
        cursor: "default"
      },
      "@media print": {
        colorAdjust: "exact"
      }
    });
    const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiButtonBase"
      });
      const {
        action,
        centerRipple = false,
        children,
        className,
        component = "button",
        disabled = false,
        disableRipple = false,
        disableTouchRipple = false,
        focusRipple = false,
        LinkComponent = "a",
        onBlur,
        onClick,
        onContextMenu,
        onDragLeave,
        onFocus,
        onFocusVisible,
        onKeyDown,
        onKeyUp,
        onMouseDown,
        onMouseLeave,
        onMouseUp,
        onTouchEnd,
        onTouchMove,
        onTouchStart,
        tabIndex = 0,
        TouchRippleProps,
        touchRippleRef,
        type
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$$);
      const buttonRef = reactExports.useRef(null);
      const rippleRef = reactExports.useRef(null);
      const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
      const {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref: focusVisibleRef
      } = useIsFocusVisible();
      const [focusVisible, setFocusVisible] = reactExports.useState(false);
      if (disabled && focusVisible) {
        setFocusVisible(false);
      }
      reactExports.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      }), []);
      const [mountedState, setMountedState] = reactExports.useState(false);
      reactExports.useEffect(() => {
        setMountedState(true);
      }, []);
      const enableTouchRipple = mountedState && !disableRipple && !disabled;
      reactExports.useEffect(() => {
        if (focusVisible && focusRipple && !disableRipple && mountedState) {
          rippleRef.current.pulsate();
        }
      }, [disableRipple, focusRipple, focusVisible, mountedState]);
      function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
        return useEventCallback((event) => {
          if (eventCallback) {
            eventCallback(event);
          }
          const ignore = skipRippleAction;
          if (!ignore && rippleRef.current) {
            rippleRef.current[rippleAction](event);
          }
          return true;
        });
      }
      const handleMouseDown = useRippleHandler("start", onMouseDown);
      const handleContextMenu = useRippleHandler("stop", onContextMenu);
      const handleDragLeave = useRippleHandler("stop", onDragLeave);
      const handleMouseUp = useRippleHandler("stop", onMouseUp);
      const handleMouseLeave = useRippleHandler("stop", (event) => {
        if (focusVisible) {
          event.preventDefault();
        }
        if (onMouseLeave) {
          onMouseLeave(event);
        }
      });
      const handleTouchStart = useRippleHandler("start", onTouchStart);
      const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
      const handleTouchMove = useRippleHandler("stop", onTouchMove);
      const handleBlur = useRippleHandler("stop", (event) => {
        handleBlurVisible(event);
        if (isFocusVisibleRef.current === false) {
          setFocusVisible(false);
        }
        if (onBlur) {
          onBlur(event);
        }
      }, false);
      const handleFocus = useEventCallback((event) => {
        if (!buttonRef.current) {
          buttonRef.current = event.currentTarget;
        }
        handleFocusVisible(event);
        if (isFocusVisibleRef.current === true) {
          setFocusVisible(true);
          if (onFocusVisible) {
            onFocusVisible(event);
          }
        }
        if (onFocus) {
          onFocus(event);
        }
      });
      const isNonNativeButton = () => {
        const button = buttonRef.current;
        return component && component !== "button" && !(button.tagName === "A" && button.href);
      };
      const keydownRef = reactExports.useRef(false);
      const handleKeyDown2 = useEventCallback((event) => {
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
          keydownRef.current = true;
          rippleRef.current.stop(event, () => {
            rippleRef.current.start(event);
          });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
          event.preventDefault();
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
          event.preventDefault();
          if (onClick) {
            onClick(event);
          }
        }
      });
      const handleKeyUp = useEventCallback((event) => {
        if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
          keydownRef.current = false;
          rippleRef.current.stop(event, () => {
            rippleRef.current.pulsate(event);
          });
        }
        if (onKeyUp) {
          onKeyUp(event);
        }
        if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
          onClick(event);
        }
      });
      let ComponentProp = component;
      if (ComponentProp === "button" && (other.href || other.to)) {
        ComponentProp = LinkComponent;
      }
      const buttonProps = {};
      if (ComponentProp === "button") {
        buttonProps.type = type === void 0 ? "button" : type;
        buttonProps.disabled = disabled;
      } else {
        if (!other.href && !other.to) {
          buttonProps.role = "button";
        }
        if (disabled) {
          buttonProps["aria-disabled"] = disabled;
        }
      }
      const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
      const ownerState = _extends$1({}, props, {
        centerRipple,
        component,
        disabled,
        disableRipple,
        disableTouchRipple,
        focusRipple,
        tabIndex,
        focusVisible
      });
      const classes = useUtilityClasses$R(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$1({
        as: ComponentProp,
        className: clsx$1(classes.root, className),
        ownerState,
        onBlur: handleBlur,
        onClick,
        onContextMenu: handleContextMenu,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown2,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onDragLeave: handleDragLeave,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex,
        type
      }, buttonProps, other, {
        children: [children, enableTouchRipple ? (
          /* TouchRipple is only needed client-side, x2 boost on the server. */
          /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends$1({
            ref: handleRippleRef,
            center: centerRipple
          }, TouchRippleProps))
        ) : null]
      }));
    });
    const ButtonBase$1 = ButtonBase;
    function getAlertUtilityClass(slot) {
      return generateUtilityClass("MuiAlert", slot);
    }
    const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
    const alertClasses$1 = alertClasses;
    function getIconButtonUtilityClass(slot) {
      return generateUtilityClass("MuiIconButton", slot);
    }
    const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
    const iconButtonClasses$1 = iconButtonClasses;
    const _excluded$_ = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
    const useUtilityClasses$Q = (ownerState) => {
      const {
        classes,
        disabled,
        color: color2,
        edge,
        size
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
      };
      return composeClasses(slots, getIconButtonUtilityClass, classes);
    };
    const IconButtonRoot = styled$1(ButtonBase$1, {
      name: "MuiIconButton",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      textAlign: "center",
      flex: "0 0 auto",
      fontSize: theme.typography.pxToRem(24),
      padding: 8,
      borderRadius: "50%",
      overflow: "visible",
      // Explicitly set the default value to solve a bug on IE11.
      color: (theme.vars || theme).palette.action.active,
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      })
    }, !ownerState.disableRipple && {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }, ownerState.edge === "start" && {
      marginLeft: ownerState.size === "small" ? -3 : -12
    }, ownerState.edge === "end" && {
      marginRight: ownerState.size === "small" ? -3 : -12
    }), ({
      theme,
      ownerState
    }) => {
      var _palette;
      const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
      return _extends$1({}, ownerState.color === "inherit" && {
        color: "inherit"
      }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$1({
        color: palette == null ? void 0 : palette.main
      }, !ownerState.disableRipple && {
        "&:hover": _extends$1({}, palette && {
          backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(palette.main, theme.palette.action.hoverOpacity)
        }, {
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        })
      }), ownerState.size === "small" && {
        padding: 5,
        fontSize: theme.typography.pxToRem(18)
      }, ownerState.size === "large" && {
        padding: 12,
        fontSize: theme.typography.pxToRem(28)
      }, {
        [`&.${iconButtonClasses$1.disabled}`]: {
          backgroundColor: "transparent",
          color: (theme.vars || theme).palette.action.disabled
        }
      });
    });
    const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiIconButton"
      });
      const {
        edge = false,
        children,
        className,
        color: color2 = "default",
        disabled = false,
        disableFocusRipple = false,
        size = "medium"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$_);
      const ownerState = _extends$1({}, props, {
        edge,
        color: color2,
        disabled,
        disableFocusRipple,
        size
      });
      const classes = useUtilityClasses$Q(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends$1({
        className: clsx$1(classes.root, className),
        centerRipple: true,
        focusRipple: !disableFocusRipple,
        disabled,
        ref,
        ownerState
      }, other, {
        children
      }));
    });
    const IconButton$1 = IconButton;
    const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
    }), "SuccessOutlined");
    const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
    }), "ReportProblemOutlined");
    const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), "ErrorOutline");
    const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
    }), "InfoOutlined");
    const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Close");
    const _excluded$Z = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"];
    const useUtilityClasses$P = (ownerState) => {
      const {
        variant,
        color: color2,
        severity,
        classes
      } = ownerState;
      const slots = {
        root: ["root", `${variant}${capitalize(color2 || severity)}`, `${variant}`],
        icon: ["icon"],
        message: ["message"],
        action: ["action"]
      };
      return composeClasses(slots, getAlertUtilityClass, classes);
    };
    const AlertRoot = styled$1(Paper$1, {
      name: "MuiAlert",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const getColor = theme.palette.mode === "light" ? darken : lighten;
      const getBackgroundColor = theme.palette.mode === "light" ? lighten : darken;
      const color2 = ownerState.color || ownerState.severity;
      return _extends$1({}, theme.typography.body2, {
        backgroundColor: "transparent",
        display: "flex",
        padding: "6px 16px"
      }, color2 && ownerState.variant === "standard" && {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme.palette[color2].light, 0.9),
        [`& .${alertClasses$1.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }, color2 && ownerState.variant === "outlined" && {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        border: `1px solid ${(theme.vars || theme).palette[color2].light}`,
        [`& .${alertClasses$1.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }, color2 && ownerState.variant === "filled" && _extends$1({
        fontWeight: theme.typography.fontWeightMedium
      }, theme.vars ? {
        color: theme.vars.palette.Alert[`${color2}FilledColor`],
        backgroundColor: theme.vars.palette.Alert[`${color2}FilledBg`]
      } : {
        backgroundColor: theme.palette.mode === "dark" ? theme.palette[color2].dark : theme.palette[color2].main,
        color: theme.palette.getContrastText(theme.palette[color2].main)
      }));
    });
    const AlertIcon = styled$1("div", {
      name: "MuiAlert",
      slot: "Icon",
      overridesResolver: (props, styles2) => styles2.icon
    })({
      marginRight: 12,
      padding: "7px 0",
      display: "flex",
      fontSize: 22,
      opacity: 0.9
    });
    const AlertMessage = styled$1("div", {
      name: "MuiAlert",
      slot: "Message",
      overridesResolver: (props, styles2) => styles2.message
    })({
      padding: "8px 0",
      minWidth: 0,
      overflow: "auto"
    });
    const AlertAction = styled$1("div", {
      name: "MuiAlert",
      slot: "Action",
      overridesResolver: (props, styles2) => styles2.action
    })({
      display: "flex",
      alignItems: "flex-start",
      padding: "4px 0 0 16px",
      marginLeft: "auto",
      marginRight: -8
    });
    const defaultIconMapping = {
      success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
        fontSize: "inherit"
      }),
      warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
        fontSize: "inherit"
      }),
      error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
        fontSize: "inherit"
      }),
      info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
        fontSize: "inherit"
      })
    };
    const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref) {
      var _ref, _slots$closeButton, _ref2, _slots$closeIcon, _slotProps$closeButto, _slotProps$closeIcon;
      const props = useThemeProps({
        props: inProps,
        name: "MuiAlert"
      });
      const {
        action,
        children,
        className,
        closeText = "Close",
        color: color2,
        components = {},
        componentsProps = {},
        icon,
        iconMapping = defaultIconMapping,
        onClose,
        role = "alert",
        severity = "success",
        slotProps = {},
        slots = {},
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Z);
      const ownerState = _extends$1({}, props, {
        color: color2,
        severity,
        variant
      });
      const classes = useUtilityClasses$P(ownerState);
      const AlertCloseButton = (_ref = (_slots$closeButton = slots.closeButton) != null ? _slots$closeButton : components.CloseButton) != null ? _ref : IconButton$1;
      const AlertCloseIcon = (_ref2 = (_slots$closeIcon = slots.closeIcon) != null ? _slots$closeIcon : components.CloseIcon) != null ? _ref2 : ClearIcon;
      const closeButtonProps = (_slotProps$closeButto = slotProps.closeButton) != null ? _slotProps$closeButto : componentsProps.closeButton;
      const closeIconProps = (_slotProps$closeIcon = slotProps.closeIcon) != null ? _slotProps$closeIcon : componentsProps.closeIcon;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertRoot, _extends$1({
        role,
        elevation: 0,
        ownerState,
        className: clsx$1(classes.root, className),
        ref
      }, other, {
        children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, {
          ownerState,
          className: classes.icon,
          children: icon || iconMapping[severity] || defaultIconMapping[severity]
        }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(AlertMessage, {
          ownerState,
          className: classes.message,
          children
        }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
          ownerState,
          className: classes.action,
          children: action
        }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
          ownerState,
          className: classes.action,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCloseButton, _extends$1({
            size: "small",
            "aria-label": closeText,
            title: closeText,
            color: "inherit",
            onClick: onClose
          }, closeButtonProps, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCloseIcon, _extends$1({
              fontSize: "small"
            }, closeIconProps))
          }))
        }) : null]
      }));
    });
    const Alert$1 = Alert;
    function getTypographyUtilityClass(slot) {
      return generateUtilityClass("MuiTypography", slot);
    }
    generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
    const _excluded$Y = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
    const useUtilityClasses$O = (ownerState) => {
      const {
        align,
        gutterBottom,
        noWrap,
        paragraph,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
      };
      return composeClasses(slots, getTypographyUtilityClass, classes);
    };
    const TypographyRoot = styled$1("span", {
      name: "MuiTypography",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      margin: 0
    }, ownerState.variant === "inherit" && {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit"
    }, ownerState.variant !== "inherit" && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
      textAlign: ownerState.align
    }, ownerState.noWrap && {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, ownerState.gutterBottom && {
      marginBottom: "0.35em"
    }, ownerState.paragraph && {
      marginBottom: 16
    }));
    const defaultVariantMapping = {
      h1: "h1",
      h2: "h2",
      h3: "h3",
      h4: "h4",
      h5: "h5",
      h6: "h6",
      subtitle1: "h6",
      subtitle2: "h6",
      body1: "p",
      body2: "p",
      inherit: "p"
    };
    const colorTransformations = {
      primary: "primary.main",
      textPrimary: "text.primary",
      secondary: "secondary.main",
      textSecondary: "text.secondary",
      error: "error.main"
    };
    const transformDeprecatedColors = (color2) => {
      return colorTransformations[color2] || color2;
    };
    const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
      const themeProps = useThemeProps({
        props: inProps,
        name: "MuiTypography"
      });
      const color2 = transformDeprecatedColors(themeProps.color);
      const props = extendSxProp(_extends$1({}, themeProps, {
        color: color2
      }));
      const {
        align = "inherit",
        className,
        component,
        gutterBottom = false,
        noWrap = false,
        paragraph = false,
        variant = "body1",
        variantMapping = defaultVariantMapping
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Y);
      const ownerState = _extends$1({}, props, {
        align,
        color: color2,
        className,
        component,
        gutterBottom,
        noWrap,
        paragraph,
        variant,
        variantMapping
      });
      const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
      const classes = useUtilityClasses$O(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends$1({
        as: Component,
        ref,
        ownerState,
        className: clsx$1(classes.root, className)
      }, other));
    });
    const Typography$1 = Typography;
    function getAlertTitleUtilityClass(slot) {
      return generateUtilityClass("MuiAlertTitle", slot);
    }
    generateUtilityClasses("MuiAlertTitle", ["root"]);
    const _excluded$X = ["className"];
    const useUtilityClasses$N = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getAlertTitleUtilityClass, classes);
    };
    const AlertTitleRoot = styled$1(Typography$1, {
      name: "MuiAlertTitle",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme
    }) => {
      return {
        fontWeight: theme.typography.fontWeightMedium,
        marginTop: -2
      };
    });
    const AlertTitle = /* @__PURE__ */ reactExports.forwardRef(function AlertTitle2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiAlertTitle"
      });
      const {
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$X);
      const ownerState = props;
      const classes = useUtilityClasses$N(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitleRoot, _extends$1({
        gutterBottom: true,
        component: "div",
        ownerState,
        ref,
        className: clsx$1(classes.root, className)
      }, other));
    });
    const AlertTitle$1 = AlertTitle;
    function getAppBarUtilityClass(slot) {
      return generateUtilityClass("MuiAppBar", slot);
    }
    generateUtilityClasses("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent"]);
    const _excluded$W = ["className", "color", "enableColorOnDark", "position"];
    const useUtilityClasses$M = (ownerState) => {
      const {
        color: color2,
        position: position2,
        classes
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, `position${capitalize(position2)}`]
      };
      return composeClasses(slots, getAppBarUtilityClass, classes);
    };
    const joinVars = (var1, var2) => var1 ? `${var1 == null ? void 0 : var1.replace(")", "")}, ${var2})` : var2;
    const AppBarRoot = styled$1(Paper$1, {
      name: "MuiAppBar",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], styles2[`color${capitalize(ownerState.color)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const backgroundColorDefault = theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[900];
      return _extends$1({
        display: "flex",
        flexDirection: "column",
        width: "100%",
        boxSizing: "border-box",
        // Prevent padding issue with the Modal and fixed positioned AppBar.
        flexShrink: 0
      }, ownerState.position === "fixed" && {
        position: "fixed",
        zIndex: (theme.vars || theme).zIndex.appBar,
        top: 0,
        left: "auto",
        right: 0,
        "@media print": {
          // Prevent the app bar to be visible on each printed page.
          position: "absolute"
        }
      }, ownerState.position === "absolute" && {
        position: "absolute",
        zIndex: (theme.vars || theme).zIndex.appBar,
        top: 0,
        left: "auto",
        right: 0
      }, ownerState.position === "sticky" && {
        // ⚠️ sticky is not supported by IE11.
        position: "sticky",
        zIndex: (theme.vars || theme).zIndex.appBar,
        top: 0,
        left: "auto",
        right: 0
      }, ownerState.position === "static" && {
        position: "static"
      }, ownerState.position === "relative" && {
        position: "relative"
      }, !theme.vars && _extends$1({}, ownerState.color === "default" && {
        backgroundColor: backgroundColorDefault,
        color: theme.palette.getContrastText(backgroundColorDefault)
      }, ownerState.color && ownerState.color !== "default" && ownerState.color !== "inherit" && ownerState.color !== "transparent" && {
        backgroundColor: theme.palette[ownerState.color].main,
        color: theme.palette[ownerState.color].contrastText
      }, ownerState.color === "inherit" && {
        color: "inherit"
      }, theme.palette.mode === "dark" && !ownerState.enableColorOnDark && {
        backgroundColor: null,
        color: null
      }, ownerState.color === "transparent" && _extends$1({
        backgroundColor: "transparent",
        color: "inherit"
      }, theme.palette.mode === "dark" && {
        backgroundImage: "none"
      })), theme.vars && _extends$1({}, ownerState.color === "default" && {
        "--AppBar-background": ownerState.enableColorOnDark ? theme.vars.palette.AppBar.defaultBg : joinVars(theme.vars.palette.AppBar.darkBg, theme.vars.palette.AppBar.defaultBg),
        "--AppBar-color": ownerState.enableColorOnDark ? theme.vars.palette.text.primary : joinVars(theme.vars.palette.AppBar.darkColor, theme.vars.palette.text.primary)
      }, ownerState.color && !ownerState.color.match(/^(default|inherit|transparent)$/) && {
        "--AppBar-background": ownerState.enableColorOnDark ? theme.vars.palette[ownerState.color].main : joinVars(theme.vars.palette.AppBar.darkBg, theme.vars.palette[ownerState.color].main),
        "--AppBar-color": ownerState.enableColorOnDark ? theme.vars.palette[ownerState.color].contrastText : joinVars(theme.vars.palette.AppBar.darkColor, theme.vars.palette[ownerState.color].contrastText)
      }, {
        backgroundColor: "var(--AppBar-background)",
        color: ownerState.color === "inherit" ? "inherit" : "var(--AppBar-color)"
      }, ownerState.color === "transparent" && {
        backgroundImage: "none",
        backgroundColor: "transparent",
        color: "inherit"
      }));
    });
    const AppBar = /* @__PURE__ */ reactExports.forwardRef(function AppBar2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiAppBar"
      });
      const {
        className,
        color: color2 = "primary",
        enableColorOnDark = false,
        position: position2 = "fixed"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$W);
      const ownerState = _extends$1({}, props, {
        color: color2,
        position: position2,
        enableColorOnDark
      });
      const classes = useUtilityClasses$M(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(AppBarRoot, _extends$1({
        square: true,
        component: "header",
        ownerState,
        elevation: 4,
        className: clsx$1(classes.root, className, position2 === "fixed" && "mui-fixed"),
        ref
      }, other));
    });
    const AppBar$1 = AppBar;
    function isHostComponent(element) {
      return typeof element === "string";
    }
    function appendOwnerState(elementType, otherProps, ownerState) {
      if (elementType === void 0 || isHostComponent(elementType)) {
        return otherProps;
      }
      return _extends$1({}, otherProps, {
        ownerState: _extends$1({}, otherProps.ownerState, ownerState)
      });
    }
    const defaultContextValue = {
      disableDefaultClasses: false
    };
    const ClassNameConfiguratorContext = /* @__PURE__ */ reactExports.createContext(defaultContextValue);
    function useClassNamesOverride(generateUtilityClass2) {
      const {
        disableDefaultClasses
      } = reactExports.useContext(ClassNameConfiguratorContext);
      return (slot) => {
        if (disableDefaultClasses) {
          return "";
        }
        return generateUtilityClass2(slot);
      };
    }
    function extractEventHandlers(object2, excludeKeys = []) {
      if (object2 === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object2).filter((prop) => prop.match(/^on[A-Z]/) && typeof object2[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
        result[prop] = object2[prop];
      });
      return result;
    }
    function resolveComponentProps(componentProps, ownerState, slotState) {
      if (typeof componentProps === "function") {
        return componentProps(ownerState, slotState);
      }
      return componentProps;
    }
    function omitEventHandlers(object2) {
      if (object2 === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object2).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object2[prop] === "function")).forEach((prop) => {
        result[prop] = object2[prop];
      });
      return result;
    }
    function mergeSlotProps(parameters) {
      const {
        getSlotProps,
        additionalProps,
        externalSlotProps,
        externalForwardedProps,
        className
      } = parameters;
      if (!getSlotProps) {
        const joinedClasses2 = clsx$1(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
        const mergedStyle2 = _extends$1({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
        const props2 = _extends$1({}, additionalProps, externalForwardedProps, externalSlotProps);
        if (joinedClasses2.length > 0) {
          props2.className = joinedClasses2;
        }
        if (Object.keys(mergedStyle2).length > 0) {
          props2.style = mergedStyle2;
        }
        return {
          props: props2,
          internalRef: void 0
        };
      }
      const eventHandlers = extractEventHandlers(_extends$1({}, externalForwardedProps, externalSlotProps));
      const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
      const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
      const internalSlotProps = getSlotProps(eventHandlers);
      const joinedClasses = clsx$1(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle = _extends$1({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props = _extends$1({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
      if (joinedClasses.length > 0) {
        props.className = joinedClasses;
      }
      if (Object.keys(mergedStyle).length > 0) {
        props.style = mergedStyle;
      }
      return {
        props,
        internalRef: internalSlotProps.ref
      };
    }
    const _excluded$V = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
    function useSlotProps(parameters) {
      var _parameters$additiona;
      const {
        elementType,
        externalSlotProps,
        ownerState,
        skipResolvingSlotProps = false
      } = parameters, rest = _objectWithoutPropertiesLoose$1(parameters, _excluded$V);
      const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
      const {
        props: mergedProps,
        internalRef
      } = mergeSlotProps(_extends$1({}, rest, {
        externalSlotProps: resolvedComponentsProps
      }));
      const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
      const props = appendOwnerState(elementType, _extends$1({}, mergedProps, {
        ref
      }), ownerState);
      return props;
    }
    function useBadge(parameters) {
      const {
        badgeContent: badgeContentProp,
        invisible: invisibleProp = false,
        max: maxProp = 99,
        showZero = false
      } = parameters;
      const prevProps = usePreviousProps$1({
        badgeContent: badgeContentProp,
        max: maxProp
      });
      let invisible = invisibleProp;
      if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
        invisible = true;
      }
      const {
        badgeContent,
        max = maxProp
      } = invisible ? prevProps : parameters;
      const displayValue = badgeContent && Number(badgeContent) > max ? `${max}+` : badgeContent;
      return {
        badgeContent,
        invisible,
        max,
        displayValue
      };
    }
    const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
    function getTabIndex(node2) {
      const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
      if (!Number.isNaN(tabindexAttr)) {
        return tabindexAttr;
      }
      if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
        return 0;
      }
      return node2.tabIndex;
    }
    function isNonTabbableRadio(node2) {
      if (node2.tagName !== "INPUT" || node2.type !== "radio") {
        return false;
      }
      if (!node2.name) {
        return false;
      }
      const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
      let roving = getRadio(`[name="${node2.name}"]:checked`);
      if (!roving) {
        roving = getRadio(`[name="${node2.name}"]`);
      }
      return roving !== node2;
    }
    function isNodeMatchingSelectorFocusable(node2) {
      if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
        return false;
      }
      return true;
    }
    function defaultGetTabbable(root) {
      const regularTabNodes = [];
      const orderedTabNodes = [];
      Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i2) => {
        const nodeTabIndex = getTabIndex(node2);
        if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
          return;
        }
        if (nodeTabIndex === 0) {
          regularTabNodes.push(node2);
        } else {
          orderedTabNodes.push({
            documentOrder: i2,
            tabIndex: nodeTabIndex,
            node: node2
          });
        }
      });
      return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
    }
    function defaultIsEnabled() {
      return true;
    }
    function FocusTrap(props) {
      const {
        children,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableRestoreFocus = false,
        getTabbable = defaultGetTabbable,
        isEnabled = defaultIsEnabled,
        open: open2
      } = props;
      const ignoreNextEnforceFocus = reactExports.useRef(false);
      const sentinelStart = reactExports.useRef(null);
      const sentinelEnd = reactExports.useRef(null);
      const nodeToRestore = reactExports.useRef(null);
      const reactFocusEventTarget = reactExports.useRef(null);
      const activated = reactExports.useRef(false);
      const rootRef = reactExports.useRef(null);
      const handleRef = useForkRef(children.ref, rootRef);
      const lastKeydown = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (!open2 || !rootRef.current) {
          return;
        }
        activated.current = !disableAutoFocus;
      }, [disableAutoFocus, open2]);
      reactExports.useEffect(() => {
        if (!open2 || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        if (!rootRef.current.contains(doc.activeElement)) {
          if (!rootRef.current.hasAttribute("tabIndex")) {
            rootRef.current.setAttribute("tabIndex", "-1");
          }
          if (activated.current) {
            rootRef.current.focus();
          }
        }
        return () => {
          if (!disableRestoreFocus) {
            if (nodeToRestore.current && nodeToRestore.current.focus) {
              ignoreNextEnforceFocus.current = true;
              nodeToRestore.current.focus();
            }
            nodeToRestore.current = null;
          }
        };
      }, [open2]);
      reactExports.useEffect(() => {
        if (!open2 || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        const contain = (nativeEvent) => {
          const {
            current: rootElement
          } = rootRef;
          if (rootElement === null) {
            return;
          }
          if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
            ignoreNextEnforceFocus.current = false;
            return;
          }
          if (!rootElement.contains(doc.activeElement)) {
            if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
              reactFocusEventTarget.current = null;
            } else if (reactFocusEventTarget.current !== null) {
              return;
            }
            if (!activated.current) {
              return;
            }
            let tabbable = [];
            if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
              tabbable = getTabbable(rootRef.current);
            }
            if (tabbable.length > 0) {
              var _lastKeydown$current, _lastKeydown$current2;
              const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
              const focusNext = tabbable[0];
              const focusPrevious = tabbable[tabbable.length - 1];
              if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
                if (isShiftTab) {
                  focusPrevious.focus();
                } else {
                  focusNext.focus();
                }
              }
            } else {
              rootElement.focus();
            }
          }
        };
        const loopFocus = (nativeEvent) => {
          lastKeydown.current = nativeEvent;
          if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
            return;
          }
          if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
            ignoreNextEnforceFocus.current = true;
            if (sentinelEnd.current) {
              sentinelEnd.current.focus();
            }
          }
        };
        doc.addEventListener("focusin", contain);
        doc.addEventListener("keydown", loopFocus, true);
        const interval = setInterval(() => {
          if (doc.activeElement && doc.activeElement.tagName === "BODY") {
            contain(null);
          }
        }, 50);
        return () => {
          clearInterval(interval);
          doc.removeEventListener("focusin", contain);
          doc.removeEventListener("keydown", loopFocus, true);
        };
      }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open2, getTabbable]);
      const onFocus = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
        reactFocusEventTarget.current = event.target;
        const childrenPropsHandler = children.props.onFocus;
        if (childrenPropsHandler) {
          childrenPropsHandler(event);
        }
      };
      const handleFocusSentinel = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          tabIndex: open2 ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelStart,
          "data-testid": "sentinelStart"
        }), /* @__PURE__ */ reactExports.cloneElement(children, {
          ref: handleRef,
          onFocus
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          tabIndex: open2 ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelEnd,
          "data-testid": "sentinelEnd"
        })]
      });
    }
    function getContainer$1(container) {
      return typeof container === "function" ? container() : container;
    }
    const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
      const {
        children,
        container,
        disablePortal = false
      } = props;
      const [mountNode, setMountNode] = reactExports.useState(null);
      const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
      useEnhancedEffect$1(() => {
        if (!disablePortal) {
          setMountNode(getContainer$1(container) || document.body);
        }
      }, [container, disablePortal]);
      useEnhancedEffect$1(() => {
        if (mountNode && !disablePortal) {
          setRef(forwardedRef, mountNode);
          return () => {
            setRef(forwardedRef, null);
          };
        }
        return void 0;
      }, [forwardedRef, mountNode, disablePortal]);
      if (disablePortal) {
        if (/* @__PURE__ */ reactExports.isValidElement(children)) {
          const newProps = {
            ref: handleRef
          };
          return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
          children
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
      });
    });
    function isOverflowing(container) {
      const doc = ownerDocument(container);
      if (doc.body === container) {
        return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
      }
      return container.scrollHeight > container.clientHeight;
    }
    function ariaHidden(element, show) {
      if (show) {
        element.setAttribute("aria-hidden", "true");
      } else {
        element.removeAttribute("aria-hidden");
      }
    }
    function getPaddingRight(element) {
      return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
    }
    function isAriaHiddenForbiddenOnElement(element) {
      const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
      const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
      const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
      return isForbiddenTagName || isInputHidden;
    }
    function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
      const blacklist = [mountElement, currentElement, ...elementsToExclude];
      [].forEach.call(container.children, (element) => {
        const isNotExcludedElement = blacklist.indexOf(element) === -1;
        const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
        if (isNotExcludedElement && isNotForbiddenElement) {
          ariaHidden(element, show);
        }
      });
    }
    function findIndexOf(items, callback) {
      let idx = -1;
      items.some((item, index2) => {
        if (callback(item)) {
          idx = index2;
          return true;
        }
        return false;
      });
      return idx;
    }
    function handleContainer(containerInfo, props) {
      const restoreStyle = [];
      const container = containerInfo.container;
      if (!props.disableScrollLock) {
        if (isOverflowing(container)) {
          const scrollbarSize = getScrollbarSize(ownerDocument(container));
          restoreStyle.push({
            value: container.style.paddingRight,
            property: "padding-right",
            el: container
          });
          container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
          const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
          [].forEach.call(fixedElements2, (element) => {
            restoreStyle.push({
              value: element.style.paddingRight,
              property: "padding-right",
              el: element
            });
            element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
          });
        }
        let scrollContainer;
        if (container.parentNode instanceof DocumentFragment) {
          scrollContainer = ownerDocument(container).body;
        } else {
          const parent = container.parentElement;
          const containerWindow = ownerWindow(container);
          scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
        }
        restoreStyle.push({
          value: scrollContainer.style.overflow,
          property: "overflow",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowX,
          property: "overflow-x",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowY,
          property: "overflow-y",
          el: scrollContainer
        });
        scrollContainer.style.overflow = "hidden";
      }
      const restore = () => {
        restoreStyle.forEach(({
          value,
          el: el2,
          property
        }) => {
          if (value) {
            el2.style.setProperty(property, value);
          } else {
            el2.style.removeProperty(property);
          }
        });
      };
      return restore;
    }
    function getHiddenSiblings(container) {
      const hiddenSiblings = [];
      [].forEach.call(container.children, (element) => {
        if (element.getAttribute("aria-hidden") === "true") {
          hiddenSiblings.push(element);
        }
      });
      return hiddenSiblings;
    }
    class ModalManager {
      constructor() {
        this.containers = void 0;
        this.modals = void 0;
        this.modals = [];
        this.containers = [];
      }
      add(modal, container) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
          return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal);
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }
        const hiddenSiblings = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
        const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }
        this.containers.push({
          modals: [modal],
          container,
          restore: null,
          hiddenSiblings
        });
        return modalIndex;
      }
      mount(modal, props) {
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props);
        }
      }
      remove(modal, ariaHiddenState = true) {
        const modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
          return modalIndex;
        }
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1);
        if (containerInfo.modals.length === 0) {
          if (containerInfo.restore) {
            containerInfo.restore();
          }
          if (modal.modalRef) {
            ariaHidden(modal.modalRef, ariaHiddenState);
          }
          ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
          this.containers.splice(containerIndex, 1);
        } else {
          const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }
        return modalIndex;
      }
      isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    }
    function getModalUtilityClass(slot) {
      return generateUtilityClass("MuiModal", slot);
    }
    generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
    const _excluded$U = ["children", "closeAfterTransition", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"];
    const useUtilityClasses$L = (ownerState) => {
      const {
        open: open2,
        exited
      } = ownerState;
      const slots = {
        root: ["root", !open2 && exited && "hidden"],
        backdrop: ["backdrop"]
      };
      return composeClasses(slots, useClassNamesOverride(getModalUtilityClass));
    };
    function getContainer(container) {
      return typeof container === "function" ? container() : container;
    }
    function getHasTransition(children) {
      return children ? children.props.hasOwnProperty("in") : false;
    }
    const defaultManager = new ModalManager();
    const Modal$2 = /* @__PURE__ */ reactExports.forwardRef(function Modal2(props, forwardedRef) {
      var _props$ariaHidden, _slots$root;
      const {
        children,
        closeAfterTransition = false,
        container,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        // private
        manager: managerProp = defaultManager,
        onBackdropClick,
        onClose,
        onKeyDown,
        open: open2,
        onTransitionEnter,
        onTransitionExited,
        slotProps = {},
        slots = {}
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$U);
      const manager = managerProp;
      const [exited, setExited] = reactExports.useState(!open2);
      const modal = reactExports.useRef({});
      const mountNodeRef = reactExports.useRef(null);
      const modalRef = reactExports.useRef(null);
      const handleRef = useForkRef(modalRef, forwardedRef);
      const hasTransition = getHasTransition(children);
      const ariaHiddenProp = (_props$ariaHidden = props["aria-hidden"]) != null ? _props$ariaHidden : true;
      const getDoc = () => ownerDocument(mountNodeRef.current);
      const getModal = () => {
        modal.current.modalRef = modalRef.current;
        modal.current.mountNode = mountNodeRef.current;
        return modal.current;
      };
      const handleMounted = () => {
        manager.mount(getModal(), {
          disableScrollLock
        });
        if (modalRef.current) {
          modalRef.current.scrollTop = 0;
        }
      };
      const handleOpen = useEventCallback(() => {
        const resolvedContainer = getContainer(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer);
        if (modalRef.current) {
          handleMounted();
        }
      });
      const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
      const handlePortalRef = useEventCallback((node2) => {
        mountNodeRef.current = node2;
        if (!node2 || !modalRef.current) {
          return;
        }
        if (open2 && isTopModal()) {
          handleMounted();
        } else {
          ariaHidden(modalRef.current, ariaHiddenProp);
        }
      });
      const handleClose = reactExports.useCallback(() => {
        manager.remove(getModal(), ariaHiddenProp);
      }, [manager, ariaHiddenProp]);
      reactExports.useEffect(() => {
        return () => {
          handleClose();
        };
      }, [handleClose]);
      reactExports.useEffect(() => {
        if (open2) {
          handleOpen();
        } else if (!hasTransition || !closeAfterTransition) {
          handleClose();
        }
      }, [open2, handleClose, hasTransition, closeAfterTransition, handleOpen]);
      const ownerState = _extends$1({}, props, {
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        exited,
        hideBackdrop,
        keepMounted
      });
      const classes = useUtilityClasses$L(ownerState);
      const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
          onTransitionEnter();
        }
      };
      const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
          onTransitionExited();
        }
        if (closeAfterTransition) {
          handleClose();
        }
      };
      const handleBackdropClick = (event) => {
        if (event.target !== event.currentTarget) {
          return;
        }
        if (onBackdropClick) {
          onBackdropClick(event);
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const handleKeyDown2 = (event) => {
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.key !== "Escape" || !isTopModal()) {
          return;
        }
        if (!disableEscapeKeyDown) {
          event.stopPropagation();
          if (onClose) {
            onClose(event, "escapeKeyDown");
          }
        }
      };
      const childProps = {};
      if (children.props.tabIndex === void 0) {
        childProps.tabIndex = "-1";
      }
      if (hasTransition) {
        childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
        childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
      }
      const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: slotProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref: handleRef,
          role: "presentation",
          onKeyDown: handleKeyDown2
        },
        className: classes.root,
        ownerState
      });
      const BackdropComponent = slots.backdrop;
      const backdropProps = useSlotProps({
        elementType: BackdropComponent,
        externalSlotProps: slotProps.backdrop,
        additionalProps: {
          "aria-hidden": true,
          onClick: handleBackdropClick,
          open: open2
        },
        className: classes.backdrop,
        ownerState
      });
      if (!keepMounted && !open2 && (!hasTransition || exited)) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Portal,
        {
          ref: handlePortalRef,
          container,
          disablePortal,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, {
            children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropComponent, _extends$1({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
              disableEnforceFocus,
              disableAutoFocus,
              disableRestoreFocus,
              isEnabled: isTopModal,
              open: open2,
              children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
            })]
          }))
        }
      );
    });
    const _excluded$T = ["onChange", "maxRows", "minRows", "style", "value"];
    function getStyleValue(value) {
      return parseInt(value, 10) || 0;
    }
    const styles$2 = {
      shadow: {
        // Visibility needed to hide the extra text area on iPads
        visibility: "hidden",
        // Remove from the content flow
        position: "absolute",
        // Ignore the scrollbar width
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        // Create a new layer, increase the isolation of the computed values
        transform: "translateZ(0)"
      }
    };
    function isEmpty$1(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
    }
    const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
      const {
        onChange,
        maxRows,
        minRows = 1,
        style: style2,
        value
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$T);
      const {
        current: isControlled
      } = reactExports.useRef(value != null);
      const inputRef = reactExports.useRef(null);
      const handleRef = useForkRef(forwardedRef, inputRef);
      const shadowRef = reactExports.useRef(null);
      const renders = reactExports.useRef(0);
      const [state, setState] = reactExports.useState({
        outerHeightStyle: 0
      });
      const getUpdatedState = reactExports.useCallback(() => {
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        const computedStyle = containerWindow.getComputedStyle(input);
        if (computedStyle.width === "0px") {
          return {
            outerHeightStyle: 0
          };
        }
        const inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || "x";
        if (inputShallow.value.slice(-1) === "\n") {
          inputShallow.value += " ";
        }
        const boxSizing2 = computedStyle.boxSizing;
        const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
        const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
        const innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        const singleRowHeight = inputShallow.scrollHeight;
        let outerHeight = innerHeight;
        if (minRows) {
          outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        }
        if (maxRows) {
          outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        }
        outerHeight = Math.max(outerHeight, singleRowHeight);
        const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
        const overflow = Math.abs(outerHeight - innerHeight) <= 1;
        return {
          outerHeightStyle,
          overflow
        };
      }, [maxRows, minRows, props.placeholder]);
      const updateState = (prevState, newState) => {
        const {
          outerHeightStyle,
          overflow
        } = newState;
        if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
          renders.current += 1;
          return {
            overflow,
            outerHeightStyle
          };
        }
        return prevState;
      };
      const syncHeight = reactExports.useCallback(() => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
          return;
        }
        setState((prevState) => {
          return updateState(prevState, newState);
        });
      }, [getUpdatedState]);
      const syncHeightWithFlushSync = () => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
          return;
        }
        reactDomExports.flushSync(() => {
          setState((prevState) => {
            return updateState(prevState, newState);
          });
        });
      };
      reactExports.useEffect(() => {
        const handleResize = debounce(() => {
          renders.current = 0;
          if (inputRef.current) {
            syncHeightWithFlushSync();
          }
        });
        let resizeObserver;
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        containerWindow.addEventListener("resize", handleResize);
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          resizeObserver.observe(input);
        }
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      });
      useEnhancedEffect$1(() => {
        syncHeight();
      });
      reactExports.useEffect(() => {
        renders.current = 0;
      }, [value]);
      const handleChange = (event) => {
        renders.current = 0;
        if (!isControlled) {
          syncHeight();
        }
        if (onChange) {
          onChange(event);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$1({
          value,
          onChange: handleChange,
          ref: handleRef,
          rows: minRows,
          style: _extends$1({
            height: state.outerHeightStyle,
            // Need a large enough difference to allow scrolling.
            // This prevents infinite rendering loop.
            overflow: state.overflow ? "hidden" : void 0
          }, style2)
        }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
          "aria-hidden": true,
          className: props.className,
          readOnly: true,
          ref: shadowRef,
          tabIndex: -1,
          style: _extends$1({}, styles$2.shadow, style2, {
            paddingTop: 0,
            paddingBottom: 0
          })
        })]
      });
    });
    const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
    }), "Cancel");
    function getChipUtilityClass(slot) {
      return generateUtilityClass("MuiChip", slot);
    }
    const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
    const chipClasses$1 = chipClasses;
    const _excluded$S = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
    const useUtilityClasses$K = (ownerState) => {
      const {
        classes,
        disabled,
        size,
        color: color2,
        iconColor,
        onDelete,
        clickable,
        variant
      } = ownerState;
      const slots = {
        root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
        label: ["label", `label${capitalize(size)}`],
        avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
        icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
        deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
      };
      return composeClasses(slots, getChipUtilityClass, classes);
    };
    const ChipRoot = styled$1("div", {
      name: "MuiChip",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        const {
          color: color2,
          iconColor,
          clickable,
          onDelete,
          size,
          variant
        } = ownerState;
        return [{
          [`& .${chipClasses$1.avatar}`]: styles2.avatar
        }, {
          [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
        }, {
          [`& .${chipClasses$1.icon}`]: styles2.icon
        }, {
          [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
        }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
      return _extends$1({
        maxWidth: "100%",
        fontFamily: theme.typography.fontFamily,
        fontSize: theme.typography.pxToRem(13),
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        height: 32,
        color: (theme.vars || theme).palette.text.primary,
        backgroundColor: (theme.vars || theme).palette.action.selected,
        borderRadius: 32 / 2,
        whiteSpace: "nowrap",
        transition: theme.transitions.create(["background-color", "box-shadow"]),
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
        textDecoration: "none",
        border: 0,
        // Remove `button` border
        padding: 0,
        // Remove `button` padding
        verticalAlign: "middle",
        boxSizing: "border-box",
        [`&.${chipClasses$1.disabled}`]: {
          opacity: (theme.vars || theme).palette.action.disabledOpacity,
          pointerEvents: "none"
        },
        [`& .${chipClasses$1.avatar}`]: {
          marginLeft: 5,
          marginRight: -6,
          width: 24,
          height: 24,
          color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
          fontSize: theme.typography.pxToRem(12)
        },
        [`& .${chipClasses$1.avatarColorPrimary}`]: {
          color: (theme.vars || theme).palette.primary.contrastText,
          backgroundColor: (theme.vars || theme).palette.primary.dark
        },
        [`& .${chipClasses$1.avatarColorSecondary}`]: {
          color: (theme.vars || theme).palette.secondary.contrastText,
          backgroundColor: (theme.vars || theme).palette.secondary.dark
        },
        [`& .${chipClasses$1.avatarSmall}`]: {
          marginLeft: 4,
          marginRight: -4,
          width: 18,
          height: 18,
          fontSize: theme.typography.pxToRem(10)
        },
        [`& .${chipClasses$1.icon}`]: _extends$1({
          marginLeft: 5,
          marginRight: -6
        }, ownerState.size === "small" && {
          fontSize: 18,
          marginLeft: 4,
          marginRight: -4
        }, ownerState.iconColor === ownerState.color && _extends$1({
          color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
        }, ownerState.color !== "default" && {
          color: "inherit"
        })),
        [`& .${chipClasses$1.deleteIcon}`]: _extends$1({
          WebkitTapHighlightColor: "transparent",
          color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha(theme.palette.text.primary, 0.26),
          fontSize: 22,
          cursor: "pointer",
          margin: "0 5px 0 -6px",
          "&:hover": {
            color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha(theme.palette.text.primary, 0.4)
          }
        }, ownerState.size === "small" && {
          fontSize: 16,
          marginRight: 4,
          marginLeft: -4
        }, ownerState.color !== "default" && {
          color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme.palette[ownerState.color].contrastText, 0.7),
          "&:hover, &:active": {
            color: (theme.vars || theme).palette[ownerState.color].contrastText
          }
        })
      }, ownerState.size === "small" && {
        height: 24
      }, ownerState.color !== "default" && {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
        color: (theme.vars || theme).palette[ownerState.color].contrastText
      }, ownerState.onDelete && {
        [`&.${chipClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      }, ownerState.onDelete && ownerState.color !== "default" && {
        [`&.${chipClasses$1.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
        }
      });
    }, ({
      theme,
      ownerState
    }) => _extends$1({}, ownerState.clickable && {
      userSelect: "none",
      WebkitTapHighlightColor: "transparent",
      cursor: "pointer",
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      },
      "&:active": {
        boxShadow: (theme.vars || theme).shadows[1]
      }
    }, ownerState.clickable && ownerState.color !== "default" && {
      [`&:hover, &.${chipClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
      }
    }), ({
      theme,
      ownerState
    }) => _extends$1({}, ownerState.variant === "outlined" && {
      backgroundColor: "transparent",
      border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
      [`&.${chipClasses$1.clickable}:hover`]: {
        backgroundColor: (theme.vars || theme).palette.action.hover
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`& .${chipClasses$1.avatar}`]: {
        marginLeft: 4
      },
      [`& .${chipClasses$1.avatarSmall}`]: {
        marginLeft: 2
      },
      [`& .${chipClasses$1.icon}`]: {
        marginLeft: 4
      },
      [`& .${chipClasses$1.iconSmall}`]: {
        marginLeft: 2
      },
      [`& .${chipClasses$1.deleteIcon}`]: {
        marginRight: 5
      },
      [`& .${chipClasses$1.deleteIconSmall}`]: {
        marginRight: 3
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "default" && {
      color: (theme.vars || theme).palette[ownerState.color].main,
      border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7)}`,
      [`&.${chipClasses$1.clickable}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
      },
      [`& .${chipClasses$1.deleteIcon}`]: {
        color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7),
        "&:hover, &:active": {
          color: (theme.vars || theme).palette[ownerState.color].main
        }
      }
    }));
    const ChipLabel = styled$1("span", {
      name: "MuiChip",
      slot: "Label",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        const {
          size
        } = ownerState;
        return [styles2.label, styles2[`label${capitalize(size)}`]];
      }
    })(({
      ownerState
    }) => _extends$1({
      overflow: "hidden",
      textOverflow: "ellipsis",
      paddingLeft: 12,
      paddingRight: 12,
      whiteSpace: "nowrap"
    }, ownerState.size === "small" && {
      paddingLeft: 8,
      paddingRight: 8
    }));
    function isDeleteKeyboardEvent(keyboardEvent) {
      return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
    }
    const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiChip"
      });
      const {
        avatar: avatarProp,
        className,
        clickable: clickableProp,
        color: color2 = "default",
        component: ComponentProp,
        deleteIcon: deleteIconProp,
        disabled = false,
        icon: iconProp,
        label,
        onClick,
        onDelete,
        onKeyDown,
        onKeyUp,
        size = "medium",
        variant = "filled",
        tabIndex,
        skipFocusWhenDisabled = false
        // TODO v6: Rename to `focusableWhenDisabled`.
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$S);
      const chipRef = reactExports.useRef(null);
      const handleRef = useForkRef(chipRef, ref);
      const handleDeleteIconClick = (event) => {
        event.stopPropagation();
        if (onDelete) {
          onDelete(event);
        }
      };
      const handleKeyDown2 = (event) => {
        if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
          event.preventDefault();
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
      };
      const handleKeyUp = (event) => {
        if (event.currentTarget === event.target) {
          if (onDelete && isDeleteKeyboardEvent(event)) {
            onDelete(event);
          } else if (event.key === "Escape" && chipRef.current) {
            chipRef.current.blur();
          }
        }
        if (onKeyUp) {
          onKeyUp(event);
        }
      };
      const clickable = clickableProp !== false && onClick ? true : clickableProp;
      const component = clickable || onDelete ? ButtonBase$1 : ComponentProp || "div";
      const ownerState = _extends$1({}, props, {
        component,
        disabled,
        size,
        color: color2,
        iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
        onDelete: !!onDelete,
        clickable,
        variant
      });
      const classes = useUtilityClasses$K(ownerState);
      const moreProps = component === ButtonBase$1 ? _extends$1({
        component: ComponentProp || "div",
        focusVisibleClassName: classes.focusVisible
      }, onDelete && {
        disableRipple: true
      }) : {};
      let deleteIcon = null;
      if (onDelete) {
        deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
          className: clsx$1(deleteIconProp.props.className, classes.deleteIcon),
          onClick: handleDeleteIconClick
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
          className: clsx$1(classes.deleteIcon),
          onClick: handleDeleteIconClick
        });
      }
      let avatar = null;
      if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
        avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
          className: clsx$1(classes.avatar, avatarProp.props.className)
        });
      }
      let icon = null;
      if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
        icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
          className: clsx$1(classes.icon, iconProp.props.className)
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, _extends$1({
        as: component,
        className: clsx$1(classes.root, className),
        disabled: clickable && disabled ? true : void 0,
        onClick,
        onKeyDown: handleKeyDown2,
        onKeyUp: handleKeyUp,
        ref: handleRef,
        tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
        ownerState
      }, moreProps, other, {
        children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
          className: clsx$1(classes.label),
          ownerState,
          children: label
        }), deleteIcon]
      }));
    });
    const Chip$1 = Chip;
    function formControlState({
      props,
      states,
      muiFormControl
    }) {
      return states.reduce((acc, state) => {
        acc[state] = props[state];
        if (muiFormControl) {
          if (typeof props[state] === "undefined") {
            acc[state] = muiFormControl[state];
          }
        }
        return acc;
      }, {});
    }
    const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const FormControlContext$1 = FormControlContext;
    function useFormControl() {
      return reactExports.useContext(FormControlContext$1);
    }
    function GlobalStyles(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$1({}, props, {
        defaultTheme: defaultTheme$2,
        themeId: THEME_ID
      }));
    }
    function hasValue(value) {
      return value != null && !(Array.isArray(value) && value.length === 0);
    }
    function isFilled(obj, SSR = false) {
      return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
    }
    function isAdornedStart(obj) {
      return obj.startAdornment;
    }
    function getInputBaseUtilityClass(slot) {
      return generateUtilityClass("MuiInputBase", slot);
    }
    const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
    const inputBaseClasses$1 = inputBaseClasses;
    const _excluded$R = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
    const rootOverridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
    };
    const inputOverridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
    };
    const useUtilityClasses$J = (ownerState) => {
      const {
        classes,
        color: color2,
        disabled,
        error,
        endAdornment,
        focused,
        formControl,
        fullWidth,
        hiddenLabel,
        multiline,
        readOnly,
        size,
        startAdornment,
        type
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size === "small" && "sizeSmall", multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
        input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
      };
      return composeClasses(slots, getInputBaseUtilityClass, classes);
    };
    const InputBaseRoot = styled$1("div", {
      name: "MuiInputBase",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.body1, {
      color: (theme.vars || theme).palette.text.primary,
      lineHeight: "1.4375em",
      // 23px
      boxSizing: "border-box",
      // Prevent padding issue with fullWidth.
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      [`&.${inputBaseClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled,
        cursor: "default"
      }
    }, ownerState.multiline && _extends$1({
      padding: "4px 0 5px"
    }, ownerState.size === "small" && {
      paddingTop: 1
    }), ownerState.fullWidth && {
      width: "100%"
    }));
    const InputBaseComponent = styled$1("input", {
      name: "MuiInputBase",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      const placeholder = _extends$1({
        color: "currentColor"
      }, theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      }, {
        transition: theme.transitions.create("opacity", {
          duration: theme.transitions.duration.shorter
        })
      });
      const placeholderHidden = {
        opacity: "0 !important"
      };
      const placeholderVisible = theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      };
      return _extends$1({
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        // Reset 23pxthe native input line-height
        margin: 0,
        // Reset for Safari
        WebkitTapHighlightColor: "transparent",
        display: "block",
        // Make the flex item shrink with Firefox
        minWidth: 0,
        width: "100%",
        // Fix IE11 width issue
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": placeholder,
        "&::-moz-placeholder": placeholder,
        // Firefox 19+
        "&:-ms-input-placeholder": placeholder,
        // IE11
        "&::-ms-input-placeholder": placeholder,
        // Edge
        "&:focus": {
          outline: 0
        },
        // Reset Firefox invalid required input style
        "&:invalid": {
          boxShadow: "none"
        },
        "&::-webkit-search-decoration": {
          // Remove the padding when type=search.
          WebkitAppearance: "none"
        },
        // Show and hide the placeholder logic
        [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
          "&::-webkit-input-placeholder": placeholderHidden,
          "&::-moz-placeholder": placeholderHidden,
          // Firefox 19+
          "&:-ms-input-placeholder": placeholderHidden,
          // IE11
          "&::-ms-input-placeholder": placeholderHidden,
          // Edge
          "&:focus::-webkit-input-placeholder": placeholderVisible,
          "&:focus::-moz-placeholder": placeholderVisible,
          // Firefox 19+
          "&:focus:-ms-input-placeholder": placeholderVisible,
          // IE11
          "&:focus::-ms-input-placeholder": placeholderVisible
          // Edge
        },
        [`&.${inputBaseClasses$1.disabled}`]: {
          opacity: 1,
          // Reset iOS opacity
          WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
          // Fix opacity Safari bug
        },
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }, ownerState.size === "small" && {
        paddingTop: 1
      }, ownerState.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }, ownerState.type === "search" && {
        // Improve type search style.
        MozAppearance: "textfield"
      });
    });
    const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      styles: {
        "@keyframes mui-auto-fill": {
          from: {
            display: "block"
          }
        },
        "@keyframes mui-auto-fill-cancel": {
          from: {
            display: "block"
          }
        }
      }
    });
    const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
      var _slotProps$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiInputBase"
      });
      const {
        "aria-describedby": ariaDescribedby,
        autoComplete,
        autoFocus,
        className,
        components = {},
        componentsProps = {},
        defaultValue,
        disabled,
        disableInjectingGlobalStyles,
        endAdornment,
        fullWidth = false,
        id: id2,
        inputComponent = "input",
        inputProps: inputPropsProp = {},
        inputRef: inputRefProp,
        maxRows,
        minRows,
        multiline = false,
        name,
        onBlur,
        onChange,
        onClick,
        onFocus,
        onKeyDown,
        onKeyUp,
        placeholder,
        readOnly,
        renderSuffix,
        rows,
        slotProps = {},
        slots = {},
        startAdornment,
        type = "text",
        value: valueProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$R);
      const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
      const {
        current: isControlled
      } = reactExports.useRef(value != null);
      const inputRef = reactExports.useRef();
      const handleInputRefWarning = reactExports.useCallback((instance) => {
      }, []);
      const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
      const [focused, setFocused] = reactExports.useState(false);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
      });
      fcs.focused = muiFormControl ? muiFormControl.focused : focused;
      reactExports.useEffect(() => {
        if (!muiFormControl && disabled && focused) {
          setFocused(false);
          if (onBlur) {
            onBlur();
          }
        }
      }, [muiFormControl, disabled, focused, onBlur]);
      const onFilled = muiFormControl && muiFormControl.onFilled;
      const onEmpty = muiFormControl && muiFormControl.onEmpty;
      const checkDirty = reactExports.useCallback((obj) => {
        if (isFilled(obj)) {
          if (onFilled) {
            onFilled();
          }
        } else if (onEmpty) {
          onEmpty();
        }
      }, [onFilled, onEmpty]);
      useEnhancedEffect$1(() => {
        if (isControlled) {
          checkDirty({
            value
          });
        }
      }, [value, checkDirty, isControlled]);
      const handleFocus = (event) => {
        if (fcs.disabled) {
          event.stopPropagation();
          return;
        }
        if (onFocus) {
          onFocus(event);
        }
        if (inputPropsProp.onFocus) {
          inputPropsProp.onFocus(event);
        }
        if (muiFormControl && muiFormControl.onFocus) {
          muiFormControl.onFocus(event);
        } else {
          setFocused(true);
        }
      };
      const handleBlur = (event) => {
        if (onBlur) {
          onBlur(event);
        }
        if (inputPropsProp.onBlur) {
          inputPropsProp.onBlur(event);
        }
        if (muiFormControl && muiFormControl.onBlur) {
          muiFormControl.onBlur(event);
        } else {
          setFocused(false);
        }
      };
      const handleChange = (event, ...args) => {
        if (!isControlled) {
          const element = event.target || inputRef.current;
          if (element == null) {
            throw new Error(formatMuiErrorMessage(1));
          }
          checkDirty({
            value: element.value
          });
        }
        if (inputPropsProp.onChange) {
          inputPropsProp.onChange(event, ...args);
        }
        if (onChange) {
          onChange(event, ...args);
        }
      };
      reactExports.useEffect(() => {
        checkDirty(inputRef.current);
      }, []);
      const handleClick = (event) => {
        if (inputRef.current && event.currentTarget === event.target) {
          inputRef.current.focus();
        }
        if (onClick && !fcs.disabled) {
          onClick(event);
        }
      };
      let InputComponent = inputComponent;
      let inputProps = inputPropsProp;
      if (multiline && InputComponent === "input") {
        if (rows) {
          inputProps = _extends$1({
            type: void 0,
            minRows: rows,
            maxRows: rows
          }, inputProps);
        } else {
          inputProps = _extends$1({
            type: void 0,
            maxRows,
            minRows
          }, inputProps);
        }
        InputComponent = TextareaAutosize;
      }
      const handleAutoFill = (event) => {
        checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
          value: "x"
        });
      };
      reactExports.useEffect(() => {
        if (muiFormControl) {
          muiFormControl.setAdornedStart(Boolean(startAdornment));
        }
      }, [muiFormControl, startAdornment]);
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        endAdornment,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        startAdornment,
        type
      });
      const classes = useUtilityClasses$J(ownerState);
      const Root = slots.root || components.Root || InputBaseRoot;
      const rootProps = slotProps.root || componentsProps.root || {};
      const Input2 = slots.input || components.Input || InputBaseComponent;
      inputProps = _extends$1({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, !isHostComponent(Root) && {
          ownerState: _extends$1({}, ownerState, rootProps.ownerState)
        }, {
          ref,
          onClick: handleClick
        }, other, {
          className: clsx$1(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
          children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
            value: null,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input2, _extends$1({
              ownerState,
              "aria-invalid": fcs.error,
              "aria-describedby": ariaDescribedby,
              autoComplete,
              autoFocus,
              defaultValue,
              disabled: fcs.disabled,
              id: id2,
              onAnimationStart: handleAutoFill,
              name,
              placeholder,
              readOnly,
              required: fcs.required,
              rows,
              value,
              onKeyDown,
              onKeyUp,
              type
            }, inputProps, !isHostComponent(Input2) && {
              as: InputComponent,
              ownerState: _extends$1({}, ownerState, inputProps.ownerState)
            }, {
              ref: handleInputRef,
              className: clsx$1(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
              onBlur: handleBlur,
              onChange: handleChange,
              onFocus: handleFocus
            }))
          }), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
            startAdornment
          })) : null]
        }))]
      });
    });
    const InputBase$1 = InputBase;
    function getInputUtilityClass(slot) {
      return generateUtilityClass("MuiInput", slot);
    }
    const inputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
    const inputClasses$1 = inputClasses;
    function getOutlinedInputUtilityClass(slot) {
      return generateUtilityClass("MuiOutlinedInput", slot);
    }
    const outlinedInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
    const outlinedInputClasses$1 = outlinedInputClasses;
    function getFilledInputUtilityClass(slot) {
      return generateUtilityClass("MuiFilledInput", slot);
    }
    const filledInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
    const filledInputClasses$1 = filledInputClasses;
    const ArrowDropDownIcon$1 = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    const _excluded$Q = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    const styles$1 = {
      entering: {
        opacity: 1
      },
      entered: {
        opacity: 1
      }
    };
    const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
      const theme = useTheme();
      const defaultTimeout = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = defaultTimeout,
        // eslint-disable-next-line react/prop-types
        TransitionComponent = Transition$1
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Q);
      const nodeRef = reactExports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
            style: _extends$1({
              opacity: 0,
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles$1[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    const Fade$1 = Fade;
    function getBackdropUtilityClass(slot) {
      return generateUtilityClass("MuiBackdrop", slot);
    }
    generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
    const _excluded$P = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
    const useUtilityClasses$I = (ownerState) => {
      const {
        classes,
        invisible
      } = ownerState;
      const slots = {
        root: ["root", invisible && "invisible"]
      };
      return composeClasses(slots, getBackdropUtilityClass, classes);
    };
    const BackdropRoot = styled$1("div", {
      name: "MuiBackdrop",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.invisible && styles2.invisible];
      }
    })(({
      ownerState
    }) => _extends$1({
      position: "fixed",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      WebkitTapHighlightColor: "transparent"
    }, ownerState.invisible && {
      backgroundColor: "transparent"
    }));
    const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
      var _slotProps$root, _ref, _slots$root;
      const props = useThemeProps({
        props: inProps,
        name: "MuiBackdrop"
      });
      const {
        children,
        className,
        component = "div",
        components = {},
        componentsProps = {},
        invisible = false,
        open: open2,
        slotProps = {},
        slots = {},
        TransitionComponent = Fade$1,
        transitionDuration
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$P);
      const ownerState = _extends$1({}, props, {
        component,
        invisible
      });
      const classes = useUtilityClasses$I(ownerState);
      const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        in: open2,
        timeout: transitionDuration
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$1({
          "aria-hidden": true
        }, rootSlotProps, {
          as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
          className: clsx$1(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
          ownerState: _extends$1({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
          classes,
          ref,
          children
        }))
      }));
    });
    const Backdrop$1 = Backdrop;
    function getBadgeUtilityClass(slot) {
      return generateUtilityClass("MuiBadge", slot);
    }
    const badgeClasses = generateUtilityClasses("MuiBadge", [
      "root",
      "badge",
      "dot",
      "standard",
      "anchorOriginTopRight",
      "anchorOriginBottomRight",
      "anchorOriginTopLeft",
      "anchorOriginBottomLeft",
      "invisible",
      "colorError",
      "colorInfo",
      "colorPrimary",
      "colorSecondary",
      "colorSuccess",
      "colorWarning",
      "overlapRectangular",
      "overlapCircular",
      // TODO: v6 remove the overlap value from these class keys
      "anchorOriginTopLeftCircular",
      "anchorOriginTopLeftRectangular",
      "anchorOriginTopRightCircular",
      "anchorOriginTopRightRectangular",
      "anchorOriginBottomLeftCircular",
      "anchorOriginBottomLeftRectangular",
      "anchorOriginBottomRightCircular",
      "anchorOriginBottomRightRectangular"
    ]);
    const badgeClasses$1 = badgeClasses;
    const _excluded$O = ["anchorOrigin", "className", "classes", "component", "components", "componentsProps", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "variant"];
    const RADIUS_STANDARD = 10;
    const RADIUS_DOT = 4;
    const useUtilityClasses$H = (ownerState) => {
      const {
        color: color2,
        anchorOrigin,
        invisible,
        overlap,
        variant,
        classes = {}
      } = ownerState;
      const slots = {
        root: ["root"],
        badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}${capitalize(overlap)}`, `overlap${capitalize(overlap)}`, color2 !== "default" && `color${capitalize(color2)}`]
      };
      return composeClasses(slots, getBadgeUtilityClass, classes);
    };
    const BadgeRoot = styled$1("span", {
      name: "MuiBadge",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      position: "relative",
      display: "inline-flex",
      // For correct alignment with the text.
      verticalAlign: "middle",
      flexShrink: 0
    });
    const BadgeBadge = styled$1("span", {
      name: "MuiBadge",
      slot: "Badge",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}${capitalize(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.invisible && styles2.invisible];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "center",
      alignContent: "center",
      alignItems: "center",
      position: "absolute",
      boxSizing: "border-box",
      fontFamily: theme.typography.fontFamily,
      fontWeight: theme.typography.fontWeightMedium,
      fontSize: theme.typography.pxToRem(12),
      minWidth: RADIUS_STANDARD * 2,
      lineHeight: 1,
      padding: "0 6px",
      height: RADIUS_STANDARD * 2,
      borderRadius: RADIUS_STANDARD,
      zIndex: 1,
      // Render the badge on top of potential ripples.
      transition: theme.transitions.create("transform", {
        easing: theme.transitions.easing.easeInOut,
        duration: theme.transitions.duration.enteringScreen
      })
    }, ownerState.color !== "default" && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
      color: (theme.vars || theme).palette[ownerState.color].contrastText
    }, ownerState.variant === "dot" && {
      borderRadius: RADIUS_DOT,
      height: RADIUS_DOT * 2,
      minWidth: RADIUS_DOT * 2,
      padding: 0
    }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular" && {
      top: 0,
      right: 0,
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular" && {
      bottom: 0,
      right: 0,
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular" && {
      top: 0,
      left: 0,
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular" && {
      bottom: 0,
      left: 0,
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular" && {
      top: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular" && {
      bottom: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular" && {
      top: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular" && {
      bottom: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses$1.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }, ownerState.invisible && {
      transition: theme.transitions.create("transform", {
        easing: theme.transitions.easing.easeInOut,
        duration: theme.transitions.duration.leavingScreen
      })
    }));
    const Badge = /* @__PURE__ */ reactExports.forwardRef(function Badge2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$badge, _slotProps$root, _slotProps$badge;
      const props = useThemeProps({
        props: inProps,
        name: "MuiBadge"
      });
      const {
        anchorOrigin: anchorOriginProp = {
          vertical: "top",
          horizontal: "right"
        },
        className,
        component,
        components = {},
        componentsProps = {},
        children,
        overlap: overlapProp = "rectangular",
        color: colorProp = "default",
        invisible: invisibleProp = false,
        max: maxProp = 99,
        badgeContent: badgeContentProp,
        slots,
        slotProps,
        showZero = false,
        variant: variantProp = "standard"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$O);
      const {
        badgeContent,
        invisible: invisibleFromHook,
        max,
        displayValue: displayValueFromHook
      } = useBadge({
        max: maxProp,
        invisible: invisibleProp,
        badgeContent: badgeContentProp,
        showZero
      });
      const prevProps = usePreviousProps$1({
        anchorOrigin: anchorOriginProp,
        color: colorProp,
        overlap: overlapProp,
        variant: variantProp,
        badgeContent: badgeContentProp
      });
      const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
      const {
        color: color2 = colorProp,
        overlap = overlapProp,
        anchorOrigin = anchorOriginProp,
        variant = variantProp
      } = invisible ? prevProps : props;
      const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
      const ownerState = _extends$1({}, props, {
        badgeContent,
        invisible,
        max,
        displayValue,
        showZero,
        anchorOrigin,
        color: color2,
        overlap,
        variant
      });
      const classes = useUtilityClasses$H(ownerState);
      const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : BadgeRoot;
      const BadgeSlot = (_ref2 = (_slots$badge = slots == null ? void 0 : slots.badge) != null ? _slots$badge : components.Badge) != null ? _ref2 : BadgeBadge;
      const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
      const badgeSlotProps = (_slotProps$badge = slotProps == null ? void 0 : slotProps.badge) != null ? _slotProps$badge : componentsProps.badge;
      const rootProps = useSlotProps({
        elementType: RootSlot,
        externalSlotProps: rootSlotProps,
        externalForwardedProps: other,
        additionalProps: {
          ref,
          as: component
        },
        ownerState,
        className: clsx$1(rootSlotProps == null ? void 0 : rootSlotProps.className, classes.root, className)
      });
      const badgeProps = useSlotProps({
        elementType: BadgeSlot,
        externalSlotProps: badgeSlotProps,
        ownerState,
        className: clsx$1(classes.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$1({}, rootProps, {
        children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(BadgeSlot, _extends$1({}, badgeProps, {
          children: displayValue
        }))]
      }));
    });
    const Badge$1 = Badge;
    const defaultTheme = createTheme();
    const Box = createBox({
      themeId: THEME_ID,
      defaultTheme,
      defaultClassName: "MuiBox-root",
      generateClassName: ClassNameGenerator$1.generate
    });
    const Box$1 = Box;
    function getButtonUtilityClass(slot) {
      return generateUtilityClass("MuiButton", slot);
    }
    const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
    const buttonClasses$1 = buttonClasses;
    const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
    const ButtonGroupContext$1 = ButtonGroupContext;
    const _excluded$N = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
    const useUtilityClasses$G = (ownerState) => {
      const {
        color: color2,
        disableElevation,
        fullWidth,
        size,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
        label: ["label"],
        startIcon: ["startIcon", `iconSize${capitalize(size)}`],
        endIcon: ["endIcon", `iconSize${capitalize(size)}`]
      };
      const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const commonIconStyles = (ownerState) => _extends$1({}, ownerState.size === "small" && {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }, ownerState.size === "medium" && {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }, ownerState.size === "large" && {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    });
    const ButtonRoot = styled$1(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiButton",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$palette$getCon, _theme$palette;
      const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
      const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
      return _extends$1({}, theme.typography.button, {
        minWidth: 64,
        padding: "6px 16px",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
          duration: theme.transitions.duration.short
        }),
        "&:hover": _extends$1({
          textDecoration: "none",
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
          border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "contained" && {
          backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
          boxShadow: (theme.vars || theme).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2],
            backgroundColor: (theme.vars || theme).palette.grey[300]
          }
        }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].main
          }
        }),
        "&:active": _extends$1({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[8]
        }),
        [`&.${buttonClasses$1.focusVisible}`]: _extends$1({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[6]
        }),
        [`&.${buttonClasses$1.disabled}`]: _extends$1({
          color: (theme.vars || theme).palette.action.disabled
        }, ownerState.variant === "outlined" && {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }, ownerState.variant === "contained" && {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        })
      }, ownerState.variant === "text" && {
        padding: "6px 8px"
      }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.variant === "outlined" && {
        padding: "5px 15px",
        border: "1px solid currentColor"
      }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main,
        border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`
      }, ownerState.variant === "contained" && {
        color: theme.vars ? (
          // this is safe because grey does not change between default light/dark mode
          theme.vars.palette.text.primary
        ) : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
        backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        boxShadow: (theme.vars || theme).shadows[2]
      }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].contrastText,
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.color === "inherit" && {
        color: "inherit",
        borderColor: "currentColor"
      }, ownerState.size === "small" && ownerState.variant === "text" && {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "text" && {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "outlined" && {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "outlined" && {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "contained" && {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "contained" && {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.fullWidth && {
        width: "100%"
      });
    }, ({
      ownerState
    }) => ownerState.disableElevation && {
      boxShadow: "none",
      "&:hover": {
        boxShadow: "none"
      },
      [`&.${buttonClasses$1.focusVisible}`]: {
        boxShadow: "none"
      },
      "&:active": {
        boxShadow: "none"
      },
      [`&.${buttonClasses$1.disabled}`]: {
        boxShadow: "none"
      }
    });
    const ButtonStartIcon = styled$1("span", {
      name: "MuiButton",
      slot: "StartIcon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.startIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "inherit",
      marginRight: 8,
      marginLeft: -4
    }, ownerState.size === "small" && {
      marginLeft: -2
    }, commonIconStyles(ownerState)));
    const ButtonEndIcon = styled$1("span", {
      name: "MuiButton",
      slot: "EndIcon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.endIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "inherit",
      marginRight: -4,
      marginLeft: 8
    }, ownerState.size === "small" && {
      marginRight: -2
    }, commonIconStyles(ownerState)));
    const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
      const contextProps = reactExports.useContext(ButtonGroupContext$1);
      const resolvedProps = resolveProps(contextProps, inProps);
      const props = useThemeProps({
        props: resolvedProps,
        name: "MuiButton"
      });
      const {
        children,
        color: color2 = "primary",
        component = "button",
        className,
        disabled = false,
        disableElevation = false,
        disableFocusRipple = false,
        endIcon: endIconProp,
        focusVisibleClassName,
        fullWidth = false,
        size = "medium",
        startIcon: startIconProp,
        type,
        variant = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$N);
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        disabled,
        disableElevation,
        disableFocusRipple,
        fullWidth,
        size,
        type,
        variant
      });
      const classes = useUtilityClasses$G(ownerState);
      const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
        className: classes.startIcon,
        ownerState,
        children: startIconProp
      });
      const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
        className: classes.endIcon,
        ownerState,
        children: endIconProp
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends$1({
        ownerState,
        className: clsx$1(contextProps.className, classes.root, className),
        component,
        disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: clsx$1(classes.focusVisible, focusVisibleClassName),
        ref,
        type
      }, other, {
        classes,
        children: [startIcon, children, endIcon]
      }));
    });
    const Button$1 = Button;
    function getButtonGroupUtilityClass(slot) {
      return generateUtilityClass("MuiButtonGroup", slot);
    }
    const buttonGroupClasses = generateUtilityClasses("MuiButtonGroup", ["root", "contained", "outlined", "text", "disableElevation", "disabled", "fullWidth", "vertical", "grouped", "groupedHorizontal", "groupedVertical", "groupedText", "groupedTextHorizontal", "groupedTextVertical", "groupedTextPrimary", "groupedTextSecondary", "groupedOutlined", "groupedOutlinedHorizontal", "groupedOutlinedVertical", "groupedOutlinedPrimary", "groupedOutlinedSecondary", "groupedContained", "groupedContainedHorizontal", "groupedContainedVertical", "groupedContainedPrimary", "groupedContainedSecondary"]);
    const buttonGroupClasses$1 = buttonGroupClasses;
    const _excluded$M = ["children", "className", "color", "component", "disabled", "disableElevation", "disableFocusRipple", "disableRipple", "fullWidth", "orientation", "size", "variant"];
    const overridesResolver$3 = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${buttonGroupClasses$1.grouped}`]: styles2.grouped
      }, {
        [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.orientation)}`]
      }, {
        [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}`]
      }, {
        [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.orientation)}`]
      }, {
        [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.color)}`]
      }, styles2.root, styles2[ownerState.variant], ownerState.disableElevation === true && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.orientation === "vertical" && styles2.vertical];
    };
    const useUtilityClasses$F = (ownerState) => {
      const {
        classes,
        color: color2,
        disabled,
        disableElevation,
        fullWidth,
        orientation,
        variant
      } = ownerState;
      const slots = {
        root: ["root", variant, orientation === "vertical" && "vertical", fullWidth && "fullWidth", disableElevation && "disableElevation"],
        grouped: ["grouped", `grouped${capitalize(orientation)}`, `grouped${capitalize(variant)}`, `grouped${capitalize(variant)}${capitalize(orientation)}`, `grouped${capitalize(variant)}${capitalize(color2)}`, disabled && "disabled"]
      };
      return composeClasses(slots, getButtonGroupUtilityClass, classes);
    };
    const ButtonGroupRoot = styled$1("div", {
      name: "MuiButtonGroup",
      slot: "Root",
      overridesResolver: overridesResolver$3
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "inline-flex",
      borderRadius: (theme.vars || theme).shape.borderRadius
    }, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[2]
    }, ownerState.disableElevation && {
      boxShadow: "none"
    }, ownerState.fullWidth && {
      width: "100%"
    }, ownerState.orientation === "vertical" && {
      flexDirection: "column"
    }, {
      [`& .${buttonGroupClasses$1.grouped}`]: _extends$1({
        minWidth: 40,
        "&:not(:first-of-type)": _extends$1({}, ownerState.orientation === "horizontal" && {
          borderTopLeftRadius: 0,
          borderBottomLeftRadius: 0
        }, ownerState.orientation === "vertical" && {
          borderTopRightRadius: 0,
          borderTopLeftRadius: 0
        }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
          marginLeft: -1
        }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
          marginTop: -1
        }),
        "&:not(:last-of-type)": _extends$1({}, ownerState.orientation === "horizontal" && {
          borderTopRightRadius: 0,
          borderBottomRightRadius: 0
        }, ownerState.orientation === "vertical" && {
          borderBottomRightRadius: 0,
          borderBottomLeftRadius: 0
        }, ownerState.variant === "text" && ownerState.orientation === "horizontal" && {
          borderRight: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
          [`&.${buttonGroupClasses$1.disabled}`]: {
            borderRight: `1px solid ${(theme.vars || theme).palette.action.disabled}`
          }
        }, ownerState.variant === "text" && ownerState.orientation === "vertical" && {
          borderBottom: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
          [`&.${buttonGroupClasses$1.disabled}`]: {
            borderBottom: `1px solid ${(theme.vars || theme).palette.action.disabled}`
          }
        }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
          borderColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : alpha(theme.palette[ownerState.color].main, 0.5)
        }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
          borderRightColor: "transparent"
        }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
          borderBottomColor: "transparent"
        }, ownerState.variant === "contained" && ownerState.orientation === "horizontal" && {
          borderRight: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
          [`&.${buttonGroupClasses$1.disabled}`]: {
            borderRight: `1px solid ${(theme.vars || theme).palette.action.disabled}`
          }
        }, ownerState.variant === "contained" && ownerState.orientation === "vertical" && {
          borderBottom: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
          [`&.${buttonGroupClasses$1.disabled}`]: {
            borderBottom: `1px solid ${(theme.vars || theme).palette.action.disabled}`
          }
        }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
          borderColor: (theme.vars || theme).palette[ownerState.color].dark
        }, {
          "&:hover": _extends$1({}, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
            borderRightColor: "currentColor"
          }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
            borderBottomColor: "currentColor"
          })
        }),
        "&:hover": _extends$1({}, ownerState.variant === "contained" && {
          boxShadow: "none"
        })
      }, ownerState.variant === "contained" && {
        boxShadow: "none"
      })
    }));
    const ButtonGroup = /* @__PURE__ */ reactExports.forwardRef(function ButtonGroup2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiButtonGroup"
      });
      const {
        children,
        className,
        color: color2 = "primary",
        component = "div",
        disabled = false,
        disableElevation = false,
        disableFocusRipple = false,
        disableRipple = false,
        fullWidth = false,
        orientation = "horizontal",
        size = "medium",
        variant = "outlined"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$M);
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        disabled,
        disableElevation,
        disableFocusRipple,
        disableRipple,
        fullWidth,
        orientation,
        size,
        variant
      });
      const classes = useUtilityClasses$F(ownerState);
      const context = reactExports.useMemo(() => ({
        className: classes.grouped,
        color: color2,
        disabled,
        disableElevation,
        disableFocusRipple,
        disableRipple,
        fullWidth,
        size,
        variant
      }), [color2, disabled, disableElevation, disableFocusRipple, disableRipple, fullWidth, size, variant, classes.grouped]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupRoot, _extends$1({
        as: component,
        role: "group",
        className: clsx$1(classes.root, className),
        ref,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupContext$1.Provider, {
          value: context,
          children
        })
      }));
    });
    const ButtonGroup$1 = ButtonGroup;
    const _excluded$L = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "open", "slotProps", "slots", "theme"];
    const ModalRoot = styled$1("div", {
      name: "MuiModal",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      position: "fixed",
      zIndex: (theme.vars || theme).zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0
    }, !ownerState.open && ownerState.exited && {
      visibility: "hidden"
    }));
    const ModalBackdrop = styled$1(Backdrop$1, {
      name: "MuiModal",
      slot: "Backdrop",
      overridesResolver: (props, styles2) => {
        return styles2.backdrop;
      }
    })({
      zIndex: -1
    });
    const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
      const props = useThemeProps({
        name: "MuiModal",
        props: inProps
      });
      const {
        BackdropComponent = ModalBackdrop,
        BackdropProps,
        classes,
        className,
        closeAfterTransition = false,
        children,
        container,
        component,
        components = {},
        componentsProps = {},
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        onBackdropClick,
        onClose,
        open: open2,
        slotProps,
        slots,
        // eslint-disable-next-line react/prop-types
        theme
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$L);
      const [exited, setExited] = reactExports.useState(true);
      const commonProps = {
        container,
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        hideBackdrop,
        keepMounted,
        onBackdropClick,
        onClose,
        open: open2
      };
      const ownerState = _extends$1({}, props, commonProps, {
        exited
      });
      const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
      const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
      const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
      const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$2, _extends$1({
        slots: {
          root: RootSlot,
          backdrop: BackdropSlot
        },
        slotProps: {
          root: () => _extends$1({}, resolveComponentProps(rootSlotProps, ownerState), !isHostComponent(RootSlot) && {
            as: component,
            theme
          }, {
            className: clsx$1(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
          }),
          backdrop: () => _extends$1({}, BackdropProps, resolveComponentProps(backdropSlotProps, ownerState), {
            className: clsx$1(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop)
          })
        },
        onTransitionEnter: () => setExited(false),
        onTransitionExited: () => setExited(true),
        ref
      }, other, commonProps, {
        children
      }));
    });
    const Modal$1 = Modal;
    function getDialogActionsUtilityClass(slot) {
      return generateUtilityClass("MuiDialogActions", slot);
    }
    generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
    const _excluded$K = ["className", "disableSpacing"];
    const useUtilityClasses$E = (ownerState) => {
      const {
        classes,
        disableSpacing
      } = ownerState;
      const slots = {
        root: ["root", !disableSpacing && "spacing"]
      };
      return composeClasses(slots, getDialogActionsUtilityClass, classes);
    };
    const DialogActionsRoot = styled$1("div", {
      name: "MuiDialogActions",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "flex",
      alignItems: "center",
      padding: 8,
      justifyContent: "flex-end",
      flex: "0 0 auto"
    }, !ownerState.disableSpacing && {
      "& > :not(:first-of-type)": {
        marginLeft: 8
      }
    }));
    const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDialogActions"
      });
      const {
        className,
        disableSpacing = false
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$K);
      const ownerState = _extends$1({}, props, {
        disableSpacing
      });
      const classes = useUtilityClasses$E(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, _extends$1({
        className: clsx$1(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const DialogActions$1 = DialogActions;
    const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
    const dividerClasses$1 = dividerClasses;
    const _excluded$J = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$D = (ownerState) => {
      const {
        classes,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const FilledInputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiFilledInput",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _palette;
      const light2 = theme.palette.mode === "light";
      const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
      const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
      const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
      return _extends$1({
        position: "relative",
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
        borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create("background-color", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        "&:hover": {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
          }
        },
        [`&.${filledInputClasses$1.focused}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
        },
        [`&.${filledInputClasses$1.disabled}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
        }
      }, !ownerState.disableUnderline && {
        "&:after": {
          borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${filledInputClasses$1.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses$1.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&:before": {
          borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
          borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
        },
        [`&.${filledInputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }, ownerState.startAdornment && {
        paddingLeft: 12
      }, ownerState.endAdornment && {
        paddingRight: 12
      }, ownerState.multiline && _extends$1({
        padding: "25px 12px 8px"
      }, ownerState.size === "small" && {
        paddingTop: 21,
        paddingBottom: 4
      }, ownerState.hiddenLabel && {
        paddingTop: 16,
        paddingBottom: 17
      }));
    });
    const FilledInputInput = styled$1(InputBaseComponent, {
      name: "MuiFilledInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({
      paddingTop: 25,
      paddingRight: 12,
      paddingBottom: 8,
      paddingLeft: 12
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      paddingTop: 21,
      paddingBottom: 4
    }, ownerState.hiddenLabel && {
      paddingTop: 16,
      paddingBottom: 17
    }, ownerState.multiline && {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }, ownerState.hiddenLabel && ownerState.size === "small" && {
      paddingTop: 8,
      paddingBottom: 9
    }));
    const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiFilledInput"
      });
      const {
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        // declare here to prevent spreading to DOM
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$J);
      const ownerState = _extends$1({}, props, {
        fullWidth,
        inputComponent,
        multiline,
        type
      });
      const classes = useUtilityClasses$D(props);
      const filledInputComponentsProps = {
        root: {
          ownerState
        },
        input: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes
      }));
    });
    FilledInput.muiName = "Input";
    const FilledInput$1 = FilledInput;
    function getFormControlUtilityClasses(slot) {
      return generateUtilityClass("MuiFormControl", slot);
    }
    generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
    const _excluded$I = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
    const useUtilityClasses$C = (ownerState) => {
      const {
        classes,
        margin: margin2,
        fullWidth
      } = ownerState;
      const slots = {
        root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"]
      };
      return composeClasses(slots, getFormControlUtilityClasses, classes);
    };
    const FormControlRoot = styled$1("div", {
      name: "MuiFormControl",
      slot: "Root",
      overridesResolver: ({
        ownerState
      }, styles2) => {
        return _extends$1({}, styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "inline-flex",
      flexDirection: "column",
      position: "relative",
      // Reset fieldset default style.
      minWidth: 0,
      padding: 0,
      margin: 0,
      border: 0,
      verticalAlign: "top"
    }, ownerState.margin === "normal" && {
      marginTop: 16,
      marginBottom: 8
    }, ownerState.margin === "dense" && {
      marginTop: 8,
      marginBottom: 4
    }, ownerState.fullWidth && {
      width: "100%"
    }));
    const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiFormControl"
      });
      const {
        children,
        className,
        color: color2 = "primary",
        component = "div",
        disabled = false,
        error = false,
        focused: visuallyFocused,
        fullWidth = false,
        hiddenLabel = false,
        margin: margin2 = "none",
        required = false,
        size = "medium",
        variant = "outlined"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$I);
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        disabled,
        error,
        fullWidth,
        hiddenLabel,
        margin: margin2,
        required,
        size,
        variant
      });
      const classes = useUtilityClasses$C(ownerState);
      const [adornedStart, setAdornedStart] = reactExports.useState(() => {
        let initialAdornedStart = false;
        if (children) {
          reactExports.Children.forEach(children, (child) => {
            if (!isMuiElement(child, ["Input", "Select"])) {
              return;
            }
            const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
            if (input && isAdornedStart(input.props)) {
              initialAdornedStart = true;
            }
          });
        }
        return initialAdornedStart;
      });
      const [filled, setFilled] = reactExports.useState(() => {
        let initialFilled = false;
        if (children) {
          reactExports.Children.forEach(children, (child) => {
            if (!isMuiElement(child, ["Input", "Select"])) {
              return;
            }
            if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
              initialFilled = true;
            }
          });
        }
        return initialFilled;
      });
      const [focusedState, setFocused] = reactExports.useState(false);
      if (disabled && focusedState) {
        setFocused(false);
      }
      const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
      let registerEffect;
      const childContext = reactExports.useMemo(() => {
        return {
          adornedStart,
          setAdornedStart,
          color: color2,
          disabled,
          error,
          filled,
          focused,
          fullWidth,
          hiddenLabel,
          size,
          onBlur: () => {
            setFocused(false);
          },
          onEmpty: () => {
            setFilled(false);
          },
          onFilled: () => {
            setFilled(true);
          },
          onFocus: () => {
            setFocused(true);
          },
          registerEffect,
          required,
          variant
        };
      }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, _extends$1({
          as: component,
          ownerState,
          className: clsx$1(classes.root, className),
          ref
        }, other, {
          children
        }))
      });
    });
    const FormControl$1 = FormControl;
    const Stack = createStack({
      createStyledComponent: styled$1("div", {
        name: "MuiStack",
        slot: "Root",
        overridesResolver: (props, styles2) => styles2.root
      }),
      useThemeProps: (inProps) => useThemeProps({
        props: inProps,
        name: "MuiStack"
      })
    });
    const Stack$1 = Stack;
    function getFormHelperTextUtilityClasses(slot) {
      return generateUtilityClass("MuiFormHelperText", slot);
    }
    const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
    const formHelperTextClasses$1 = formHelperTextClasses;
    var _span$2;
    const _excluded$H = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
    const useUtilityClasses$B = (ownerState) => {
      const {
        classes,
        contained,
        size,
        disabled,
        error,
        filled,
        focused,
        required
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", error && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
      };
      return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
    };
    const FormHelperTextRoot = styled$1("p", {
      name: "MuiFormHelperText",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      color: (theme.vars || theme).palette.text.secondary
    }, theme.typography.caption, {
      textAlign: "left",
      marginTop: 3,
      marginRight: 0,
      marginBottom: 0,
      marginLeft: 0,
      [`&.${formHelperTextClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${formHelperTextClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }, ownerState.size === "small" && {
      marginTop: 4
    }, ownerState.contained && {
      marginLeft: 14,
      marginRight: 14
    }));
    const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiFormHelperText"
      });
      const {
        children,
        className,
        component = "p"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$H);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
      });
      const ownerState = _extends$1({}, props, {
        component,
        contained: fcs.variant === "filled" || fcs.variant === "outlined",
        variant: fcs.variant,
        size: fcs.size,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required
      });
      const classes = useUtilityClasses$B(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx$1(classes.root, className),
        ref
      }, other, {
        children: children === " " ? (
          // notranslate needed while Google Translate will not fix zero-width space issue
          _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        ) : children
      }));
    });
    const FormHelperText$1 = FormHelperText;
    function getFormLabelUtilityClasses(slot) {
      return generateUtilityClass("MuiFormLabel", slot);
    }
    const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
    const formLabelClasses$1 = formLabelClasses;
    const _excluded$G = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
    const useUtilityClasses$A = (ownerState) => {
      const {
        classes,
        color: color2,
        focused,
        disabled,
        error,
        filled,
        required
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
        asterisk: ["asterisk", error && "error"]
      };
      return composeClasses(slots, getFormLabelUtilityClasses, classes);
    };
    const FormLabelRoot = styled$1("label", {
      name: "MuiFormLabel",
      slot: "Root",
      overridesResolver: ({
        ownerState
      }, styles2) => {
        return _extends$1({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      color: (theme.vars || theme).palette.text.secondary
    }, theme.typography.body1, {
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      [`&.${formLabelClasses$1.focused}`]: {
        color: (theme.vars || theme).palette[ownerState.color].main
      },
      [`&.${formLabelClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${formLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }));
    const AsteriskComponent = styled$1("span", {
      name: "MuiFormLabel",
      slot: "Asterisk",
      overridesResolver: (props, styles2) => styles2.asterisk
    })(({
      theme
    }) => ({
      [`&.${formLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }));
    const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiFormLabel"
      });
      const {
        children,
        className,
        component = "label"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$G);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "required", "focused", "disabled", "error", "filled"]
      });
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        component,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required
      });
      const classes = useUtilityClasses$A(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx$1(classes.root, className),
        ref
      }, other, {
        children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
          ownerState,
          "aria-hidden": true,
          className: classes.asterisk,
          children: [" ", "*"]
        })]
      }));
    });
    const FormLabel$1 = FormLabel;
    const GridContext = /* @__PURE__ */ reactExports.createContext();
    const GridContext$1 = GridContext;
    function getGridUtilityClass(slot) {
      return generateUtilityClass("MuiGrid", slot);
    }
    const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
    const WRAPS = ["nowrap", "wrap-reverse", "wrap"];
    const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    const gridClasses = generateUtilityClasses("MuiGrid", [
      "root",
      "container",
      "item",
      "zeroMinWidth",
      // spacings
      ...SPACINGS.map((spacing) => `spacing-xs-${spacing}`),
      // direction values
      ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
      // wrap values
      ...WRAPS.map((wrap) => `wrap-xs-${wrap}`),
      // grid sizes for all breakpoints
      ...GRID_SIZES.map((size) => `grid-xs-${size}`),
      ...GRID_SIZES.map((size) => `grid-sm-${size}`),
      ...GRID_SIZES.map((size) => `grid-md-${size}`),
      ...GRID_SIZES.map((size) => `grid-lg-${size}`),
      ...GRID_SIZES.map((size) => `grid-xl-${size}`)
    ]);
    const gridClasses$1 = gridClasses;
    const _excluded$F = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
    function getOffset(val) {
      const parse2 = parseFloat(val);
      return `${parse2}${String(val).replace(String(parse2), "") || "px"}`;
    }
    function generateGrid({
      theme,
      ownerState
    }) {
      let size;
      return theme.breakpoints.keys.reduce((globalStyles, breakpoint) => {
        let styles2 = {};
        if (ownerState[breakpoint]) {
          size = ownerState[breakpoint];
        }
        if (!size) {
          return globalStyles;
        }
        if (size === true) {
          styles2 = {
            flexBasis: 0,
            flexGrow: 1,
            maxWidth: "100%"
          };
        } else if (size === "auto") {
          styles2 = {
            flexBasis: "auto",
            flexGrow: 0,
            flexShrink: 0,
            maxWidth: "none",
            width: "auto"
          };
        } else {
          const columnsBreakpointValues = resolveBreakpointValues({
            values: ownerState.columns,
            breakpoints: theme.breakpoints.values
          });
          const columnValue = typeof columnsBreakpointValues === "object" ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
          if (columnValue === void 0 || columnValue === null) {
            return globalStyles;
          }
          const width2 = `${Math.round(size / columnValue * 1e8) / 1e6}%`;
          let more = {};
          if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
            const themeSpacing = theme.spacing(ownerState.columnSpacing);
            if (themeSpacing !== "0px") {
              const fullWidth = `calc(${width2} + ${getOffset(themeSpacing)})`;
              more = {
                flexBasis: fullWidth,
                maxWidth: fullWidth
              };
            }
          }
          styles2 = _extends$1({
            flexBasis: width2,
            flexGrow: 0,
            maxWidth: width2
          }, more);
        }
        if (theme.breakpoints.values[breakpoint] === 0) {
          Object.assign(globalStyles, styles2);
        } else {
          globalStyles[theme.breakpoints.up(breakpoint)] = styles2;
        }
        return globalStyles;
      }, {});
    }
    function generateDirection({
      theme,
      ownerState
    }) {
      const directionValues = resolveBreakpointValues({
        values: ownerState.direction,
        breakpoints: theme.breakpoints.values
      });
      return handleBreakpoints({
        theme
      }, directionValues, (propValue) => {
        const output = {
          flexDirection: propValue
        };
        if (propValue.indexOf("column") === 0) {
          output[`& > .${gridClasses$1.item}`] = {
            maxWidth: "none"
          };
        }
        return output;
      });
    }
    function extractZeroValueBreakpointKeys({
      breakpoints,
      values: values2
    }) {
      let nonZeroKey = "";
      Object.keys(values2).forEach((key) => {
        if (nonZeroKey !== "") {
          return;
        }
        if (values2[key] !== 0) {
          nonZeroKey = key;
        }
      });
      const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a2, b2) => {
        return breakpoints[a2] - breakpoints[b2];
      });
      return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
    }
    function generateRowGap({
      theme,
      ownerState
    }) {
      const {
        container,
        rowSpacing
      } = ownerState;
      let styles2 = {};
      if (container && rowSpacing !== 0) {
        const rowSpacingValues = resolveBreakpointValues({
          values: rowSpacing,
          breakpoints: theme.breakpoints.values
        });
        let zeroValueBreakpointKeys;
        if (typeof rowSpacingValues === "object") {
          zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
            breakpoints: theme.breakpoints.values,
            values: rowSpacingValues
          });
        }
        styles2 = handleBreakpoints({
          theme
        }, rowSpacingValues, (propValue, breakpoint) => {
          var _zeroValueBreakpointK;
          const themeSpacing = theme.spacing(propValue);
          if (themeSpacing !== "0px") {
            return {
              marginTop: `-${getOffset(themeSpacing)}`,
              [`& > .${gridClasses$1.item}`]: {
                paddingTop: getOffset(themeSpacing)
              }
            };
          }
          if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
            return {};
          }
          return {
            marginTop: 0,
            [`& > .${gridClasses$1.item}`]: {
              paddingTop: 0
            }
          };
        });
      }
      return styles2;
    }
    function generateColumnGap({
      theme,
      ownerState
    }) {
      const {
        container,
        columnSpacing
      } = ownerState;
      let styles2 = {};
      if (container && columnSpacing !== 0) {
        const columnSpacingValues = resolveBreakpointValues({
          values: columnSpacing,
          breakpoints: theme.breakpoints.values
        });
        let zeroValueBreakpointKeys;
        if (typeof columnSpacingValues === "object") {
          zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
            breakpoints: theme.breakpoints.values,
            values: columnSpacingValues
          });
        }
        styles2 = handleBreakpoints({
          theme
        }, columnSpacingValues, (propValue, breakpoint) => {
          var _zeroValueBreakpointK2;
          const themeSpacing = theme.spacing(propValue);
          if (themeSpacing !== "0px") {
            return {
              width: `calc(100% + ${getOffset(themeSpacing)})`,
              marginLeft: `-${getOffset(themeSpacing)}`,
              [`& > .${gridClasses$1.item}`]: {
                paddingLeft: getOffset(themeSpacing)
              }
            };
          }
          if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
            return {};
          }
          return {
            width: "100%",
            marginLeft: 0,
            [`& > .${gridClasses$1.item}`]: {
              paddingLeft: 0
            }
          };
        });
      }
      return styles2;
    }
    function resolveSpacingStyles(spacing, breakpoints, styles2 = {}) {
      if (!spacing || spacing <= 0) {
        return [];
      }
      if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
        return [styles2[`spacing-xs-${String(spacing)}`]];
      }
      const spacingStyles = [];
      breakpoints.forEach((breakpoint) => {
        const value = spacing[breakpoint];
        if (Number(value) > 0) {
          spacingStyles.push(styles2[`spacing-${breakpoint}-${String(value)}`]);
        }
      });
      return spacingStyles;
    }
    const GridRoot = styled$1("div", {
      name: "MuiGrid",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        const {
          container,
          direction,
          item,
          spacing,
          wrap,
          zeroMinWidth,
          breakpoints
        } = ownerState;
        let spacingStyles = [];
        if (container) {
          spacingStyles = resolveSpacingStyles(spacing, breakpoints, styles2);
        }
        const breakpointsStyles = [];
        breakpoints.forEach((breakpoint) => {
          const value = ownerState[breakpoint];
          if (value) {
            breakpointsStyles.push(styles2[`grid-${breakpoint}-${String(value)}`]);
          }
        });
        return [styles2.root, container && styles2.container, item && styles2.item, zeroMinWidth && styles2.zeroMinWidth, ...spacingStyles, direction !== "row" && styles2[`direction-xs-${String(direction)}`], wrap !== "wrap" && styles2[`wrap-xs-${String(wrap)}`], ...breakpointsStyles];
      }
    })(({
      ownerState
    }) => _extends$1({
      boxSizing: "border-box"
    }, ownerState.container && {
      display: "flex",
      flexWrap: "wrap",
      width: "100%"
    }, ownerState.item && {
      margin: 0
      // For instance, it's useful when used with a `figure` element.
    }, ownerState.zeroMinWidth && {
      minWidth: 0
    }, ownerState.wrap !== "wrap" && {
      flexWrap: ownerState.wrap
    }), generateDirection, generateRowGap, generateColumnGap, generateGrid);
    function resolveSpacingClasses(spacing, breakpoints) {
      if (!spacing || spacing <= 0) {
        return [];
      }
      if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
        return [`spacing-xs-${String(spacing)}`];
      }
      const classes = [];
      breakpoints.forEach((breakpoint) => {
        const value = spacing[breakpoint];
        if (Number(value) > 0) {
          const className = `spacing-${breakpoint}-${String(value)}`;
          classes.push(className);
        }
      });
      return classes;
    }
    const useUtilityClasses$z = (ownerState) => {
      const {
        classes,
        container,
        direction,
        item,
        spacing,
        wrap,
        zeroMinWidth,
        breakpoints
      } = ownerState;
      let spacingClasses = [];
      if (container) {
        spacingClasses = resolveSpacingClasses(spacing, breakpoints);
      }
      const breakpointsClasses = [];
      breakpoints.forEach((breakpoint) => {
        const value = ownerState[breakpoint];
        if (value) {
          breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
        }
      });
      const slots = {
        root: ["root", container && "container", item && "item", zeroMinWidth && "zeroMinWidth", ...spacingClasses, direction !== "row" && `direction-xs-${String(direction)}`, wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...breakpointsClasses]
      };
      return composeClasses(slots, getGridUtilityClass, classes);
    };
    const Grid = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref) {
      const themeProps = useThemeProps({
        props: inProps,
        name: "MuiGrid"
      });
      const {
        breakpoints
      } = useTheme();
      const props = extendSxProp(themeProps);
      const {
        className,
        columns: columnsProp,
        columnSpacing: columnSpacingProp,
        component = "div",
        container = false,
        direction = "row",
        item = false,
        rowSpacing: rowSpacingProp,
        spacing = 0,
        wrap = "wrap",
        zeroMinWidth = false
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$F);
      const rowSpacing = rowSpacingProp || spacing;
      const columnSpacing = columnSpacingProp || spacing;
      const columnsContext = reactExports.useContext(GridContext$1);
      const columns = container ? columnsProp || 12 : columnsContext;
      const breakpointsValues = {};
      const otherFiltered = _extends$1({}, other);
      breakpoints.keys.forEach((breakpoint) => {
        if (other[breakpoint] != null) {
          breakpointsValues[breakpoint] = other[breakpoint];
          delete otherFiltered[breakpoint];
        }
      });
      const ownerState = _extends$1({}, props, {
        columns,
        container,
        direction,
        item,
        rowSpacing,
        columnSpacing,
        wrap,
        zeroMinWidth,
        spacing
      }, breakpointsValues, {
        breakpoints: breakpoints.keys
      });
      const classes = useUtilityClasses$z(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContext$1.Provider, {
        value: columns,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridRoot, _extends$1({
          ownerState,
          className: clsx$1(classes.root, className),
          as: component,
          ref
        }, otherFiltered))
      });
    });
    const Grid$1 = Grid;
    const _excluded$E = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    function getScale(value) {
      return `scale(${value}, ${__pow(value, 2)})`;
    }
    const styles = {
      entering: {
        opacity: 1,
        transform: getScale(1)
      },
      entered: {
        opacity: 1,
        transform: "none"
      }
    };
    const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
    const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = "auto",
        // eslint-disable-next-line react/prop-types
        TransitionComponent = Transition$1
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$E);
      const timer = reactExports.useRef();
      const autoTimeout = reactExports.useRef();
      const theme = useTheme();
      const nodeRef = reactExports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const {
          duration: transitionDuration,
          delay,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay,
          easing: transitionTimingFunction
        })].join(",");
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const {
          duration: transitionDuration,
          delay,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay: isWebKit154 ? delay : delay || duration2 * 0.333,
          easing: transitionTimingFunction
        })].join(",");
        node2.style.opacity = 0;
        node2.style.transform = getScale(0.75);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (timeout === "auto") {
          timer.current = setTimeout(next2, autoTimeout.current || 0);
        }
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      reactExports.useEffect(() => {
        return () => {
          clearTimeout(timer.current);
        };
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout: timeout === "auto" ? null : timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
            style: _extends$1({
              opacity: 0,
              transform: getScale(0.75),
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    Grow.muiSupportAuto = true;
    const Grow$1 = Grow;
    function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
      const [match2, setMatch] = reactExports.useState(() => {
        if (noSsr && matchMedia) {
          return matchMedia(query).matches;
        }
        if (ssrMatchMedia) {
          return ssrMatchMedia(query).matches;
        }
        return defaultMatches;
      });
      useEnhancedEffect$1(() => {
        let active = true;
        if (!matchMedia) {
          return void 0;
        }
        const queryList = matchMedia(query);
        const updateMatch = () => {
          if (active) {
            setMatch(queryList.matches);
          }
        };
        updateMatch();
        queryList.addListener(updateMatch);
        return () => {
          active = false;
          queryList.removeListener(updateMatch);
        };
      }, [query, matchMedia]);
      return match2;
    }
    const maybeReactUseSyncExternalStore = React$1["useSyncExternalStore"];
    function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
      const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
      const getServerSnapshot = reactExports.useMemo(() => {
        if (noSsr && matchMedia) {
          return () => matchMedia(query).matches;
        }
        if (ssrMatchMedia !== null) {
          const {
            matches
          } = ssrMatchMedia(query);
          return () => matches;
        }
        return getDefaultSnapshot;
      }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
      const [getSnapshot, subscribe] = reactExports.useMemo(() => {
        if (matchMedia === null) {
          return [getDefaultSnapshot, () => () => {
          }];
        }
        const mediaQueryList = matchMedia(query);
        return [() => mediaQueryList.matches, (notify) => {
          mediaQueryList.addListener(notify);
          return () => {
            mediaQueryList.removeListener(notify);
          };
        }];
      }, [getDefaultSnapshot, matchMedia, query]);
      const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      return match2;
    }
    function useMediaQuery(queryInput, options = {}) {
      const theme = useTheme$2();
      const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
      const {
        defaultMatches = false,
        matchMedia = supportMatchMedia ? window.matchMedia : null,
        ssrMatchMedia = null,
        noSsr = false
      } = getThemeProps({
        name: "MuiUseMediaQuery",
        props: options,
        theme
      });
      let query = typeof queryInput === "function" ? queryInput(theme) : queryInput;
      query = query.replace(/^@media( ?)/m, "");
      const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
      const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
      return match2;
    }
    const _excluded$D = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$y = (ownerState) => {
      const {
        classes,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const InputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiInput",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      if (theme.vars) {
        bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
      }
      return _extends$1({
        position: "relative"
      }, ownerState.formControl && {
        "label + &": {
          marginTop: 16
        }
      }, !ownerState.disableUnderline && {
        "&:after": {
          borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${inputClasses$1.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses$1.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&:before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
          borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      });
    });
    const InputInput = styled$1(InputBaseComponent, {
      name: "MuiInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })({});
    const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiInput"
      });
      const {
        disableUnderline,
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$D);
      const classes = useUtilityClasses$y(props);
      const ownerState = {
        disableUnderline
      };
      const inputComponentsProps = {
        root: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        slotProps: componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes
      }));
    });
    Input.muiName = "Input";
    const Input$1 = Input;
    function getInputLabelUtilityClasses(slot) {
      return generateUtilityClass("MuiInputLabel", slot);
    }
    generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
    const _excluded$C = ["disableAnimation", "margin", "shrink", "variant", "className"];
    const useUtilityClasses$x = (ownerState) => {
      const {
        classes,
        formControl,
        size,
        shrink,
        disableAnimation,
        variant,
        required
      } = ownerState;
      const slots = {
        root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size === "small" && "sizeSmall", variant],
        asterisk: [required && "asterisk"]
      };
      const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const InputLabelRoot = styled$1(FormLabel$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiInputLabel",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [{
          [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk
        }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, styles2[ownerState.variant]];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "block",
      transformOrigin: "top left",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      maxWidth: "100%"
    }, ownerState.formControl && {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }, ownerState.size === "small" && {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }, ownerState.shrink && {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }, !ownerState.disableAnimation && {
      transition: theme.transitions.create(["color", "transform", "max-width"], {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      })
    }, ownerState.variant === "filled" && _extends$1({
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(12px, 13px) scale(1)"
    }, ownerState.shrink && _extends$1({
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(12px, 4px) scale(0.75)"
    })), ownerState.variant === "outlined" && _extends$1({
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(14px, 9px) scale(1)"
    }, ownerState.shrink && {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    })));
    const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
      const props = useThemeProps({
        name: "MuiInputLabel",
        props: inProps
      });
      const {
        disableAnimation = false,
        shrink: shrinkProp,
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$C);
      const muiFormControl = useFormControl();
      let shrink = shrinkProp;
      if (typeof shrink === "undefined" && muiFormControl) {
        shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
      }
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["size", "variant", "required"]
      });
      const ownerState = _extends$1({}, props, {
        disableAnimation,
        formControl: muiFormControl,
        shrink,
        size: fcs.size,
        variant: fcs.variant,
        required: fcs.required
      });
      const classes = useUtilityClasses$x(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, _extends$1({
        "data-shrink": shrink,
        ownerState,
        ref,
        className: clsx$1(classes.root, className)
      }, other, {
        classes
      }));
    });
    const InputLabel$1 = InputLabel;
    const ListContext = /* @__PURE__ */ reactExports.createContext({});
    const ListContext$1 = ListContext;
    function getListUtilityClass(slot) {
      return generateUtilityClass("MuiList", slot);
    }
    generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
    const _excluded$B = ["children", "className", "component", "dense", "disablePadding", "subheader"];
    const useUtilityClasses$w = (ownerState) => {
      const {
        classes,
        disablePadding,
        dense,
        subheader
      } = ownerState;
      const slots = {
        root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
      };
      return composeClasses(slots, getListUtilityClass, classes);
    };
    const ListRoot = styled$1("ul", {
      name: "MuiList",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
      }
    })(({
      ownerState
    }) => _extends$1({
      listStyle: "none",
      margin: 0,
      padding: 0,
      position: "relative"
    }, !ownerState.disablePadding && {
      paddingTop: 8,
      paddingBottom: 8
    }, ownerState.subheader && {
      paddingTop: 0
    }));
    const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiList"
      });
      const {
        children,
        className,
        component = "ul",
        dense = false,
        disablePadding = false,
        subheader
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$B);
      const context = reactExports.useMemo(() => ({
        dense
      }), [dense]);
      const ownerState = _extends$1({}, props, {
        component,
        dense,
        disablePadding
      });
      const classes = useUtilityClasses$w(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: context,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$1({
          as: component,
          className: clsx$1(classes.root, className),
          ref,
          ownerState
        }, other, {
          children: [subheader, children]
        }))
      });
    });
    const List$1 = List;
    function getListItemUtilityClass(slot) {
      return generateUtilityClass("MuiListItem", slot);
    }
    const listItemClasses = generateUtilityClasses("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
    const listItemClasses$1 = listItemClasses;
    const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
    const listItemButtonClasses$1 = listItemButtonClasses;
    function getListItemSecondaryActionClassesUtilityClass(slot) {
      return generateUtilityClass("MuiListItemSecondaryAction", slot);
    }
    generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
    const _excluded$A = ["className"];
    const useUtilityClasses$v = (ownerState) => {
      const {
        disableGutters,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disableGutters && "disableGutters"]
      };
      return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
    };
    const ListItemSecondaryActionRoot = styled$1("div", {
      name: "MuiListItemSecondaryAction",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
      }
    })(({
      ownerState
    }) => _extends$1({
      position: "absolute",
      right: 16,
      top: "50%",
      transform: "translateY(-50%)"
    }, ownerState.disableGutters && {
      right: 0
    }));
    const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiListItemSecondaryAction"
      });
      const {
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$A);
      const context = reactExports.useContext(ListContext$1);
      const ownerState = _extends$1({}, props, {
        disableGutters: context.disableGutters
      });
      const classes = useUtilityClasses$v(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, _extends$1({
        className: clsx$1(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
    const ListItemSecondaryAction$1 = ListItemSecondaryAction;
    const _excluded$z = ["className"], _excluded2$5 = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
    const overridesResolver$2 = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.button && styles2.button, ownerState.hasSecondaryAction && styles2.secondaryAction];
    };
    const useUtilityClasses$u = (ownerState) => {
      const {
        alignItems,
        button,
        classes,
        dense,
        disabled,
        disableGutters,
        disablePadding,
        divider,
        hasSecondaryAction,
        selected
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
        container: ["container"]
      };
      return composeClasses(slots, getListItemUtilityClass, classes);
    };
    const ListItemRoot = styled$1("div", {
      name: "MuiListItem",
      slot: "Root",
      overridesResolver: overridesResolver$2
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      width: "100%",
      boxSizing: "border-box",
      textAlign: "left"
    }, !ownerState.disablePadding && _extends$1({
      paddingTop: 8,
      paddingBottom: 8
    }, ownerState.dense && {
      paddingTop: 4,
      paddingBottom: 4
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, !!ownerState.secondaryAction && {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }), !!ownerState.secondaryAction && {
      [`& > .${listItemButtonClasses$1.root}`]: {
        paddingRight: 48
      }
    }, {
      [`&.${listItemClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${listItemClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${listItemClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${listItemClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      }
    }, ownerState.alignItems === "flex-start" && {
      alignItems: "flex-start"
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, ownerState.button && {
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${listItemClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      }
    }, ownerState.hasSecondaryAction && {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }));
    const ListItemContainer = styled$1("li", {
      name: "MuiListItem",
      slot: "Container",
      overridesResolver: (props, styles2) => styles2.container
    })({
      position: "relative"
    });
    const ListItem = /* @__PURE__ */ reactExports.forwardRef(function ListItem2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiListItem"
      });
      const {
        alignItems = "center",
        autoFocus = false,
        button = false,
        children: childrenProp,
        className,
        component: componentProp,
        components = {},
        componentsProps = {},
        ContainerComponent = "li",
        ContainerProps: {
          className: ContainerClassName
        } = {},
        dense = false,
        disabled = false,
        disableGutters = false,
        disablePadding = false,
        divider = false,
        focusVisibleClassName,
        secondaryAction,
        selected = false,
        slotProps = {},
        slots = {}
      } = props, ContainerProps = _objectWithoutPropertiesLoose$1(props.ContainerProps, _excluded$z), other = _objectWithoutPropertiesLoose$1(props, _excluded2$5);
      const context = reactExports.useContext(ListContext$1);
      const childContext = reactExports.useMemo(() => ({
        dense: dense || context.dense || false,
        alignItems,
        disableGutters
      }), [alignItems, context.dense, dense, disableGutters]);
      const listItemRef = reactExports.useRef(null);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          if (listItemRef.current) {
            listItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const children = reactExports.Children.toArray(childrenProp);
      const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
      const ownerState = _extends$1({}, props, {
        alignItems,
        autoFocus,
        button,
        dense: childContext.dense,
        disabled,
        disableGutters,
        disablePadding,
        divider,
        hasSecondaryAction,
        selected
      });
      const classes = useUtilityClasses$u(ownerState);
      const handleRef = useForkRef(listItemRef, ref);
      const Root = slots.root || components.Root || ListItemRoot;
      const rootProps = slotProps.root || componentsProps.root || {};
      const componentProps = _extends$1({
        className: clsx$1(classes.root, rootProps.className, className),
        disabled
      }, other);
      let Component = componentProp || "li";
      if (button) {
        componentProps.component = componentProp || "div";
        componentProps.focusVisibleClassName = clsx$1(listItemClasses$1.focusVisible, focusVisibleClassName);
        Component = ButtonBase$1;
      }
      if (hasSecondaryAction) {
        Component = !componentProps.component && !componentProp ? "div" : Component;
        if (ContainerComponent === "li") {
          if (Component === "li") {
            Component = "div";
          } else if (componentProps.component === "li") {
            componentProps.component = "div";
          }
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
          value: childContext,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, _extends$1({
            as: ContainerComponent,
            className: clsx$1(classes.container, ContainerClassName),
            ref: handleRef,
            ownerState
          }, ContainerProps, {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$1({}, rootProps, !isHostComponent(Root) && {
              as: Component,
              ownerState: _extends$1({}, ownerState, rootProps.ownerState)
            }, componentProps, {
              children
            })), children.pop()]
          }))
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, {
          as: Component,
          ref: handleRef
        }, !isHostComponent(Root) && {
          ownerState: _extends$1({}, ownerState, rootProps.ownerState)
        }, componentProps, {
          children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction$1, {
            children: secondaryAction
          })]
        }))
      });
    });
    const ListItem$1 = ListItem;
    const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
    const listItemIconClasses$1 = listItemIconClasses;
    const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
    const listItemTextClasses$1 = listItemTextClasses;
    const _excluded$y = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
    function nextItem(list, item, disableListWrap) {
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return disableListWrap ? null : list.firstChild;
    }
    function previousItem(list, item, disableListWrap) {
      if (list === item) {
        return disableListWrap ? list.firstChild : list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return disableListWrap ? null : list.lastChild;
    }
    function textCriteriaMatches(nextFocus, textCriteria) {
      if (textCriteria === void 0) {
        return true;
      }
      let text = nextFocus.innerText;
      if (text === void 0) {
        text = nextFocus.textContent;
      }
      text = text.trim().toLowerCase();
      if (text.length === 0) {
        return false;
      }
      if (textCriteria.repeating) {
        return text[0] === textCriteria.keys[0];
      }
      return text.indexOf(textCriteria.keys.join("")) === 0;
    }
    function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
      while (nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return false;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus, disableListWrap);
        } else {
          nextFocus.focus();
          return true;
        }
      }
      return false;
    }
    const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
      const {
        // private
        // eslint-disable-next-line react/prop-types
        actions,
        autoFocus = false,
        autoFocusItem = false,
        children,
        className,
        disabledItemsFocusable = false,
        disableListWrap = false,
        onKeyDown,
        variant = "selectedMenu"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$y);
      const listRef = reactExports.useRef(null);
      const textCriteriaRef = reactExports.useRef({
        keys: [],
        repeating: true,
        previousKeyMatched: true,
        lastTime: null
      });
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          listRef.current.focus();
        }
      }, [autoFocus]);
      reactExports.useImperativeHandle(actions, () => ({
        adjustStyleForScrollbar: (containerElement, theme) => {
          const noExplicitWidth = !listRef.current.style.width;
          if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
            const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
            listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
            listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
          }
          return listRef.current;
        }
      }), []);
      const handleKeyDown2 = (event) => {
        const list = listRef.current;
        const key = event.key;
        const currentFocus = ownerDocument(list).activeElement;
        if (key === "ArrowDown") {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === "ArrowUp") {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key === "Home") {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === "End") {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key.length === 1) {
          const criteria = textCriteriaRef.current;
          const lowerKey = key.toLowerCase();
          const currTime = performance.now();
          if (criteria.keys.length > 0) {
            if (currTime - criteria.lastTime > 500) {
              criteria.keys = [];
              criteria.repeating = true;
              criteria.previousKeyMatched = true;
            } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
              criteria.repeating = false;
            }
          }
          criteria.lastTime = currTime;
          criteria.keys.push(lowerKey);
          const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
          if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
            event.preventDefault();
          } else {
            criteria.previousKeyMatched = false;
          }
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
      };
      const handleRef = useForkRef(listRef, ref);
      let activeItemIndex = -1;
      reactExports.Children.forEach(children, (child, index2) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          if (activeItemIndex === index2) {
            activeItemIndex += 1;
            if (activeItemIndex >= children.length) {
              activeItemIndex = -1;
            }
          }
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index2;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index2;
          }
        }
        if (activeItemIndex === index2 && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
          activeItemIndex += 1;
          if (activeItemIndex >= children.length) {
            activeItemIndex = -1;
          }
        }
      });
      const items = reactExports.Children.map(children, (child, index2) => {
        if (index2 === activeItemIndex) {
          const newChildProps = {};
          if (autoFocusItem) {
            newChildProps.autoFocus = true;
          }
          if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
            newChildProps.tabIndex = 0;
          }
          return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
        }
        return child;
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$1({
        role: "menu",
        ref: handleRef,
        className,
        onKeyDown: handleKeyDown2,
        tabIndex: autoFocus ? 0 : -1
      }, other, {
        children: items
      }));
    });
    const MenuList$1 = MenuList;
    function getPopoverUtilityClass(slot) {
      return generateUtilityClass("MuiPopover", slot);
    }
    generateUtilityClasses("MuiPopover", ["root", "paper"]);
    const _excluded$x = ["onEntering"], _excluded2$4 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"], _excluded3$1 = ["slotProps"];
    function getOffsetTop(rect, vertical) {
      let offset = 0;
      if (typeof vertical === "number") {
        offset = vertical;
      } else if (vertical === "center") {
        offset = rect.height / 2;
      } else if (vertical === "bottom") {
        offset = rect.height;
      }
      return offset;
    }
    function getOffsetLeft(rect, horizontal) {
      let offset = 0;
      if (typeof horizontal === "number") {
        offset = horizontal;
      } else if (horizontal === "center") {
        offset = rect.width / 2;
      } else if (horizontal === "right") {
        offset = rect.width;
      }
      return offset;
    }
    function getTransformOriginValue(transformOrigin) {
      return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
    }
    function resolveAnchorEl(anchorEl) {
      return typeof anchorEl === "function" ? anchorEl() : anchorEl;
    }
    const useUtilityClasses$t = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"]
      };
      return composeClasses(slots, getPopoverUtilityClass, classes);
    };
    const PopoverRoot = styled$1(Modal$1, {
      name: "MuiPopover",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const PopoverPaper = styled$1(Paper$1, {
      name: "MuiPopover",
      slot: "Paper",
      overridesResolver: (props, styles2) => styles2.paper
    })({
      position: "absolute",
      overflowY: "auto",
      overflowX: "hidden",
      // So we see the popover when it's empty.
      // It's most likely on issue on userland.
      minWidth: 16,
      minHeight: 16,
      maxWidth: "calc(100% - 32px)",
      maxHeight: "calc(100% - 32px)",
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    });
    const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
      var _slotProps$paper, _slots$root, _slots$paper;
      const props = useThemeProps({
        props: inProps,
        name: "MuiPopover"
      });
      const {
        action,
        anchorEl,
        anchorOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        anchorPosition,
        anchorReference = "anchorEl",
        children,
        className,
        container: containerProp,
        elevation = 8,
        marginThreshold = 16,
        open: open2,
        PaperProps: PaperPropsProp = {},
        slots,
        slotProps,
        transformOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        TransitionComponent = Grow$1,
        transitionDuration: transitionDurationProp = "auto",
        TransitionProps: {
          onEntering
        } = {}
      } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$x), other = _objectWithoutPropertiesLoose$1(props, _excluded2$4);
      const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
      const paperRef = reactExports.useRef();
      const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
      const ownerState = _extends$1({}, props, {
        anchorOrigin,
        anchorReference,
        elevation,
        marginThreshold,
        externalPaperSlotProps,
        transformOrigin,
        TransitionComponent,
        transitionDuration: transitionDurationProp,
        TransitionProps
      });
      const classes = useUtilityClasses$t(ownerState);
      const getAnchorOffset = reactExports.useCallback(() => {
        if (anchorReference === "anchorPosition") {
          return anchorPosition;
        }
        const resolvedAnchorEl = resolveAnchorEl(anchorEl);
        const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
        const anchorRect = anchorElement.getBoundingClientRect();
        return {
          top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
          left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
        };
      }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
      const getTransformOrigin = reactExports.useCallback((elemRect) => {
        return {
          vertical: getOffsetTop(elemRect, transformOrigin.vertical),
          horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
        };
      }, [transformOrigin.horizontal, transformOrigin.vertical]);
      const getPositioningStyle = reactExports.useCallback((element) => {
        const elemRect = {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
        const elemTransformOrigin = getTransformOrigin(elemRect);
        if (anchorReference === "none") {
          return {
            top: null,
            left: null,
            transformOrigin: getTransformOriginValue(elemTransformOrigin)
          };
        }
        const anchorOffset = getAnchorOffset();
        let top = anchorOffset.top - elemTransformOrigin.vertical;
        let left = anchorOffset.left - elemTransformOrigin.horizontal;
        const bottom = top + elemRect.height;
        const right = left + elemRect.width;
        const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
        const heightThreshold = containerWindow.innerHeight - marginThreshold;
        const widthThreshold = containerWindow.innerWidth - marginThreshold;
        if (top < marginThreshold) {
          const diff = top - marginThreshold;
          top -= diff;
          elemTransformOrigin.vertical += diff;
        } else if (bottom > heightThreshold) {
          const diff = bottom - heightThreshold;
          top -= diff;
          elemTransformOrigin.vertical += diff;
        }
        if (left < marginThreshold) {
          const diff = left - marginThreshold;
          left -= diff;
          elemTransformOrigin.horizontal += diff;
        } else if (right > widthThreshold) {
          const diff = right - widthThreshold;
          left -= diff;
          elemTransformOrigin.horizontal += diff;
        }
        return {
          top: `${Math.round(top)}px`,
          left: `${Math.round(left)}px`,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
      const [isPositioned, setIsPositioned] = reactExports.useState(open2);
      const setPositioningStyles = reactExports.useCallback(() => {
        const element = paperRef.current;
        if (!element) {
          return;
        }
        const positioning = getPositioningStyle(element);
        if (positioning.top !== null) {
          element.style.top = positioning.top;
        }
        if (positioning.left !== null) {
          element.style.left = positioning.left;
        }
        element.style.transformOrigin = positioning.transformOrigin;
        setIsPositioned(true);
      }, [getPositioningStyle]);
      const handleEntering = (element, isAppearing) => {
        if (onEntering) {
          onEntering(element, isAppearing);
        }
        setPositioningStyles();
      };
      const handleExited = () => {
        setIsPositioned(false);
      };
      reactExports.useEffect(() => {
        if (open2) {
          setPositioningStyles();
        }
      });
      reactExports.useImperativeHandle(action, () => open2 ? {
        updatePosition: () => {
          setPositioningStyles();
        }
      } : null, [open2, setPositioningStyles]);
      reactExports.useEffect(() => {
        if (!open2) {
          return void 0;
        }
        const handleResize = debounce(() => {
          setPositioningStyles();
        });
        const containerWindow = ownerWindow(anchorEl);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
        };
      }, [anchorEl, open2, setPositioningStyles]);
      let transitionDuration = transitionDurationProp;
      if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
        transitionDuration = void 0;
      }
      const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
      const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
      const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
      const paperProps = useSlotProps({
        elementType: PaperSlot,
        externalSlotProps: _extends$1({}, externalPaperSlotProps, {
          style: isPositioned ? externalPaperSlotProps.style : _extends$1({}, externalPaperSlotProps.style, {
            opacity: 0
          })
        }),
        additionalProps: {
          elevation,
          ref: handlePaperRef
        },
        ownerState,
        className: clsx$1(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
      });
      const _useSlotProps = useSlotProps({
        elementType: RootSlot,
        externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
        externalForwardedProps: other,
        additionalProps: {
          ref,
          slotProps: {
            backdrop: {
              invisible: true
            }
          },
          container,
          open: open2
        },
        ownerState,
        className: clsx$1(classes.root, className)
      }), {
        slotProps: rootSlotPropsProp
      } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded3$1);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$1({}, rootProps, !isHostComponent(RootSlot) && {
        slotProps: rootSlotPropsProp
      }, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
          appear: true,
          in: open2,
          onEntering: handleEntering,
          onExited: handleExited,
          timeout: transitionDuration
        }, TransitionProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$1({}, paperProps, {
            children
          }))
        }))
      }));
    });
    const Popover$1 = Popover;
    function getMenuUtilityClass(slot) {
      return generateUtilityClass("MuiMenu", slot);
    }
    generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
    const _excluded$w = ["onEntering"], _excluded2$3 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
    const RTL_ORIGIN = {
      vertical: "top",
      horizontal: "right"
    };
    const LTR_ORIGIN = {
      vertical: "top",
      horizontal: "left"
    };
    const useUtilityClasses$s = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"],
        list: ["list"]
      };
      return composeClasses(slots, getMenuUtilityClass, classes);
    };
    const MenuRoot = styled$1(Popover$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiMenu",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const MenuPaper = styled$1(PopoverPaper, {
      name: "MuiMenu",
      slot: "Paper",
      overridesResolver: (props, styles2) => styles2.paper
    })({
      // specZ: The maximum height of a simple menu should be one or more rows less than the view
      // height. This ensures a tappable area outside of the simple menu with which to dismiss
      // the menu.
      maxHeight: "calc(100% - 96px)",
      // Add iOS momentum scrolling for iOS < 13.0
      WebkitOverflowScrolling: "touch"
    });
    const MenuMenuList = styled$1(MenuList$1, {
      name: "MuiMenu",
      slot: "List",
      overridesResolver: (props, styles2) => styles2.list
    })({
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    });
    const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
      var _slots$paper, _slotProps$paper;
      const props = useThemeProps({
        props: inProps,
        name: "MuiMenu"
      });
      const {
        autoFocus = true,
        children,
        className,
        disableAutoFocusItem = false,
        MenuListProps = {},
        onClose,
        open: open2,
        PaperProps = {},
        PopoverClasses,
        transitionDuration = "auto",
        TransitionProps: {
          onEntering
        } = {},
        variant = "selectedMenu",
        slots = {},
        slotProps = {}
      } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$w), other = _objectWithoutPropertiesLoose$1(props, _excluded2$3);
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const ownerState = _extends$1({}, props, {
        autoFocus,
        disableAutoFocusItem,
        MenuListProps,
        onEntering,
        PaperProps,
        transitionDuration,
        TransitionProps,
        variant
      });
      const classes = useUtilityClasses$s(ownerState);
      const autoFocusItem = autoFocus && !disableAutoFocusItem && open2;
      const menuListActionsRef = reactExports.useRef(null);
      const handleEntering = (element, isAppearing) => {
        if (menuListActionsRef.current) {
          menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
        }
        if (onEntering) {
          onEntering(element, isAppearing);
        }
      };
      const handleListKeyDown = (event) => {
        if (event.key === "Tab") {
          event.preventDefault();
          if (onClose) {
            onClose(event, "tabKeyDown");
          }
        }
      };
      let activeItemIndex = -1;
      reactExports.Children.map(children, (child, index2) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index2;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index2;
          }
        }
      });
      const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
      const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
      const rootSlotProps = useSlotProps({
        elementType: slots.root,
        externalSlotProps: slotProps.root,
        ownerState,
        className: [classes.root, className]
      });
      const paperSlotProps = useSlotProps({
        elementType: PaperSlot,
        externalSlotProps: paperExternalSlotProps,
        ownerState,
        className: classes.paper
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$1({
        onClose,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: isRtl ? "right" : "left"
        },
        transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
        slots: {
          paper: PaperSlot,
          root: slots.root
        },
        slotProps: {
          root: rootSlotProps,
          paper: paperSlotProps
        },
        open: open2,
        ref,
        transitionDuration,
        TransitionProps: _extends$1({
          onEntering: handleEntering
        }, TransitionProps),
        ownerState
      }, other, {
        classes: PopoverClasses,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$1({
          onKeyDown: handleListKeyDown,
          actions: menuListActionsRef,
          autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
          autoFocusItem,
          variant
        }, MenuListProps, {
          className: clsx$1(classes.list, MenuListProps.className),
          children
        }))
      }));
    });
    const Menu$1 = Menu;
    function getMenuItemUtilityClass(slot) {
      return generateUtilityClass("MuiMenuItem", slot);
    }
    const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
    const menuItemClasses$1 = menuItemClasses;
    const _excluded$v = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
    const overridesResolver$1 = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
    };
    const useUtilityClasses$r = (ownerState) => {
      const {
        disabled,
        dense,
        divider,
        disableGutters,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
      };
      const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const MenuItemRoot = styled$1(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiMenuItem",
      slot: "Root",
      overridesResolver: overridesResolver$1
    })(({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.body1, {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      minHeight: 48,
      paddingTop: 6,
      paddingBottom: 6,
      boxSizing: "border-box",
      whiteSpace: "nowrap"
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, {
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${menuItemClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${menuItemClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${menuItemClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      },
      [`&.${menuItemClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${menuItemClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      },
      [`& + .${dividerClasses$1.root}`]: {
        marginTop: theme.spacing(1),
        marginBottom: theme.spacing(1)
      },
      [`& + .${dividerClasses$1.inset}`]: {
        marginLeft: 52
      },
      [`& .${listItemTextClasses$1.root}`]: {
        marginTop: 0,
        marginBottom: 0
      },
      [`& .${listItemTextClasses$1.inset}`]: {
        paddingLeft: 36
      },
      [`& .${listItemIconClasses$1.root}`]: {
        minWidth: 36
      }
    }, !ownerState.dense && {
      [theme.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }, ownerState.dense && _extends$1({
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4
    }, theme.typography.body2, {
      [`& .${listItemIconClasses$1.root} svg`]: {
        fontSize: "1.25rem"
      }
    })));
    const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiMenuItem"
      });
      const {
        autoFocus = false,
        component = "li",
        dense = false,
        divider = false,
        disableGutters = false,
        focusVisibleClassName,
        role = "menuitem",
        tabIndex: tabIndexProp,
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$v);
      const context = reactExports.useContext(ListContext$1);
      const childContext = reactExports.useMemo(() => ({
        dense: dense || context.dense || false,
        disableGutters
      }), [context.dense, dense, disableGutters]);
      const menuItemRef = reactExports.useRef(null);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          if (menuItemRef.current) {
            menuItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const ownerState = _extends$1({}, props, {
        dense: childContext.dense,
        divider,
        disableGutters
      });
      const classes = useUtilityClasses$r(props);
      const handleRef = useForkRef(menuItemRef, ref);
      let tabIndex;
      if (!props.disabled) {
        tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$1({
          ref: handleRef,
          role,
          tabIndex,
          component,
          focusVisibleClassName: clsx$1(classes.focusVisible, focusVisibleClassName),
          className: clsx$1(classes.root, className)
        }, other, {
          ownerState,
          classes
        }))
      });
    });
    const MenuItem$1 = MenuItem;
    function getNativeSelectUtilityClasses(slot) {
      return generateUtilityClass("MuiNativeSelect", slot);
    }
    const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
    const nativeSelectClasses$1 = nativeSelectClasses;
    const _excluded$u = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
    const useUtilityClasses$q = (ownerState) => {
      const {
        classes,
        variant,
        disabled,
        multiple,
        open: open2,
        error
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open2 && "iconOpen", disabled && "disabled"]
      };
      return composeClasses(slots, getNativeSelectUtilityClasses, classes);
    };
    const nativeSelectSelectStyles = ({
      ownerState,
      theme
    }) => _extends$1({
      MozAppearance: "none",
      // Reset
      WebkitAppearance: "none",
      // Reset
      // When interacting quickly, the text can end up selected.
      // Native select can't be selected either.
      userSelect: "none",
      borderRadius: 0,
      // Reset
      cursor: "pointer",
      "&:focus": _extends$1({}, theme.vars ? {
        backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
      } : {
        backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
      }, {
        borderRadius: 0
        // Reset Chrome style
      }),
      // Remove IE11 arrow
      "&::-ms-expand": {
        display: "none"
      },
      [`&.${nativeSelectClasses$1.disabled}`]: {
        cursor: "default"
      },
      "&[multiple]": {
        height: "auto"
      },
      "&:not([multiple]) option, &:not([multiple]) optgroup": {
        backgroundColor: (theme.vars || theme).palette.background.paper
      },
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }, ownerState.variant === "filled" && {
      "&&&": {
        paddingRight: 32
      }
    }, ownerState.variant === "outlined" && {
      borderRadius: (theme.vars || theme).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme.vars || theme).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    });
    const NativeSelectSelect = styled$1("select", {
      name: "MuiNativeSelect",
      slot: "Select",
      shouldForwardProp: rootShouldForwardProp,
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
          [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
        }];
      }
    })(nativeSelectSelectStyles);
    const nativeSelectIconStyles = ({
      ownerState,
      theme
    }) => _extends$1({
      // We use a position absolute over a flexbox in order to forward the pointer events
      // to the input and to support wrapping tags..
      position: "absolute",
      right: 0,
      top: "calc(50% - .5em)",
      // Center vertically, height is 1em
      pointerEvents: "none",
      // Don't block pointer events on the select under the icon.
      color: (theme.vars || theme).palette.action.active,
      [`&.${nativeSelectClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.action.disabled
      }
    }, ownerState.open && {
      transform: "rotate(180deg)"
    }, ownerState.variant === "filled" && {
      right: 7
    }, ownerState.variant === "outlined" && {
      right: 7
    });
    const NativeSelectIcon = styled$1("svg", {
      name: "MuiNativeSelect",
      slot: "Icon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
      const {
        className,
        disabled,
        error,
        IconComponent,
        inputRef,
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$u);
      const ownerState = _extends$1({}, props, {
        disabled,
        variant,
        error
      });
      const classes = useUtilityClasses$q(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$1({
          ownerState,
          className: clsx$1(classes.select, className),
          disabled,
          ref: inputRef || ref
        }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
          as: IconComponent,
          ownerState,
          className: classes.icon
        })]
      });
    });
    const NativeSelectInput$1 = NativeSelectInput;
    var _span$1;
    const _excluded$t = ["children", "classes", "className", "label", "notched"];
    const NotchedOutlineRoot$1 = styled$1("fieldset")({
      textAlign: "left",
      position: "absolute",
      bottom: 0,
      right: 0,
      top: -5,
      left: 0,
      margin: 0,
      padding: "0 8px",
      pointerEvents: "none",
      borderRadius: "inherit",
      borderStyle: "solid",
      borderWidth: 1,
      overflow: "hidden",
      minWidth: "0%"
    });
    const NotchedOutlineLegend = styled$1("legend")(({
      ownerState,
      theme
    }) => _extends$1({
      float: "unset",
      // Fix conflict with bootstrap
      width: "auto",
      // Fix conflict with bootstrap
      overflow: "hidden"
    }, !ownerState.withLabel && {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme.transitions.create("width", {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    }, ownerState.withLabel && _extends$1({
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme.transitions.create("max-width", {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }, ownerState.notched && {
      maxWidth: "100%",
      transition: theme.transitions.create("max-width", {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    })));
    function NotchedOutline(props) {
      const {
        className,
        label,
        notched
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$t);
      const withLabel = label != null && label !== "";
      const ownerState = _extends$1({}, props, {
        notched,
        withLabel
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$1({
        "aria-hidden": true,
        className,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
          ownerState,
          children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            children: label
          }) : (
            // notranslate needed while Google Translate will not fix zero-width space issue
            _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: "​"
            }))
          )
        })
      }));
    }
    const _excluded$s = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
    const useUtilityClasses$p = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const OutlinedInputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiOutlinedInput",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return _extends$1({
        position: "relative",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.text.primary
        },
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
            borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
          }
        },
        [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette[ownerState.color].main,
          borderWidth: 2
        },
        [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.error.main
        },
        [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.action.disabled
        }
      }, ownerState.startAdornment && {
        paddingLeft: 14
      }, ownerState.endAdornment && {
        paddingRight: 14
      }, ownerState.multiline && _extends$1({
        padding: "16.5px 14px"
      }, ownerState.size === "small" && {
        padding: "8.5px 14px"
      }));
    });
    const NotchedOutlineRoot = styled$1(NotchedOutline, {
      name: "MuiOutlinedInput",
      slot: "NotchedOutline",
      overridesResolver: (props, styles2) => styles2.notchedOutline
    })(({
      theme
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      };
    });
    const OutlinedInputInput = styled$1(InputBaseComponent, {
      name: "MuiOutlinedInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({
      padding: "16.5px 14px"
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      padding: "8.5px 14px"
    }, ownerState.multiline && {
      padding: 0
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }));
    const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
      const props = useThemeProps({
        props: inProps,
        name: "MuiOutlinedInput"
      });
      const {
        components = {},
        fullWidth = false,
        inputComponent = "input",
        label,
        multiline = false,
        notched,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$s);
      const classes = useUtilityClasses$p(props);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
      });
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        type
      });
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
          ownerState,
          className: classes.notchedOutline,
          label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [label, " ", "*"]
          })) : label,
          notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
        }),
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes: _extends$1({}, classes, {
          notchedOutline: null
        })
      }));
    });
    OutlinedInput.muiName = "Input";
    const OutlinedInput$1 = OutlinedInput;
    function getSelectUtilityClasses(slot) {
      return generateUtilityClass("MuiSelect", slot);
    }
    const selectClasses = generateUtilityClasses("MuiSelect", ["select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
    const selectClasses$1 = selectClasses;
    var _span;
    const _excluded$r = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
    const SelectSelect = styled$1("div", {
      name: "MuiSelect",
      slot: "Select",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [
          // Win specificity over the input base
          {
            [`&.${selectClasses$1.select}`]: styles2.select
          },
          {
            [`&.${selectClasses$1.select}`]: styles2[ownerState.variant]
          },
          {
            [`&.${selectClasses$1.error}`]: styles2.error
          },
          {
            [`&.${selectClasses$1.multiple}`]: styles2.multiple
          }
        ];
      }
    })(nativeSelectSelectStyles, {
      // Win specificity over the input base
      [`&.${selectClasses$1.select}`]: {
        height: "auto",
        // Resets for multiple select with chips
        minHeight: "1.4375em",
        // Required for select\text-field height consistency
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        overflow: "hidden"
      }
    });
    const SelectIcon = styled$1("svg", {
      name: "MuiSelect",
      slot: "Icon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const SelectNativeInput = styled$1("input", {
      shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
      name: "MuiSelect",
      slot: "NativeInput",
      overridesResolver: (props, styles2) => styles2.nativeInput
    })({
      bottom: 0,
      left: 0,
      position: "absolute",
      opacity: 0,
      pointerEvents: "none",
      width: "100%",
      boxSizing: "border-box"
    });
    function areEqualValues(a2, b2) {
      if (typeof b2 === "object" && b2 !== null) {
        return a2 === b2;
      }
      return String(a2) === String(b2);
    }
    function isEmpty(display) {
      return display == null || typeof display === "string" && !display.trim();
    }
    const useUtilityClasses$o = (ownerState) => {
      const {
        classes,
        variant,
        disabled,
        multiple,
        open: open2,
        error
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open2 && "iconOpen", disabled && "disabled"],
        nativeInput: ["nativeInput"]
      };
      return composeClasses(slots, getSelectUtilityClasses, classes);
    };
    const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
      const {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        autoFocus,
        autoWidth,
        children,
        className,
        defaultOpen,
        defaultValue,
        disabled,
        displayEmpty,
        error = false,
        IconComponent,
        inputRef: inputRefProp,
        labelId,
        MenuProps = {},
        multiple,
        name,
        onBlur,
        onChange,
        onClose,
        onFocus,
        onOpen,
        open: openProp,
        readOnly,
        renderValue,
        SelectDisplayProps = {},
        tabIndex: tabIndexProp,
        value: valueProp,
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$r);
      const [value, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: "Select"
      });
      const [openState, setOpenState] = useControlled({
        controlled: openProp,
        default: defaultOpen,
        name: "Select"
      });
      const inputRef = reactExports.useRef(null);
      const displayRef = reactExports.useRef(null);
      const [displayNode, setDisplayNode] = reactExports.useState(null);
      const {
        current: isOpenControlled
      } = reactExports.useRef(openProp != null);
      const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
      const handleRef = useForkRef(ref, inputRefProp);
      const handleDisplayRef = reactExports.useCallback((node2) => {
        displayRef.current = node2;
        if (node2) {
          setDisplayNode(node2);
        }
      }, []);
      const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
      reactExports.useImperativeHandle(handleRef, () => ({
        focus: () => {
          displayRef.current.focus();
        },
        node: inputRef.current,
        value
      }), [value]);
      reactExports.useEffect(() => {
        if (defaultOpen && openState && displayNode && !isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
          displayRef.current.focus();
        }
      }, [displayNode, autoWidth]);
      reactExports.useEffect(() => {
        if (autoFocus) {
          displayRef.current.focus();
        }
      }, [autoFocus]);
      reactExports.useEffect(() => {
        if (!labelId) {
          return void 0;
        }
        const label = ownerDocument(displayRef.current).getElementById(labelId);
        if (label) {
          const handler = () => {
            if (getSelection().isCollapsed) {
              displayRef.current.focus();
            }
          };
          label.addEventListener("click", handler);
          return () => {
            label.removeEventListener("click", handler);
          };
        }
        return void 0;
      }, [labelId]);
      const update = (open3, event) => {
        if (open3) {
          if (onOpen) {
            onOpen(event);
          }
        } else if (onClose) {
          onClose(event);
        }
        if (!isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
          setOpenState(open3);
        }
      };
      const handleMouseDown = (event) => {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        displayRef.current.focus();
        update(true, event);
      };
      const handleClose = (event) => {
        update(false, event);
      };
      const childrenArray = reactExports.Children.toArray(children);
      const handleChange = (event) => {
        const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
        if (child === void 0) {
          return;
        }
        setValueState(child.props.value);
        if (onChange) {
          onChange(event, child);
        }
      };
      const handleItemClick = (child) => (event) => {
        let newValue;
        if (!event.currentTarget.hasAttribute("tabindex")) {
          return;
        }
        if (multiple) {
          newValue = Array.isArray(value) ? value.slice() : [];
          const itemIndex = value.indexOf(child.props.value);
          if (itemIndex === -1) {
            newValue.push(child.props.value);
          } else {
            newValue.splice(itemIndex, 1);
          }
        } else {
          newValue = child.props.value;
        }
        if (child.props.onClick) {
          child.props.onClick(event);
        }
        if (value !== newValue) {
          setValueState(newValue);
          if (onChange) {
            const nativeEvent = event.nativeEvent || event;
            const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
            Object.defineProperty(clonedEvent, "target", {
              writable: true,
              value: {
                value: newValue,
                name
              }
            });
            onChange(clonedEvent, child);
          }
        }
        if (!multiple) {
          update(false, event);
        }
      };
      const handleKeyDown2 = (event) => {
        if (!readOnly) {
          const validKeys = [
            " ",
            "ArrowUp",
            "ArrowDown",
            // The native select doesn't respond to enter on macOS, but it's recommended by
            // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
            "Enter"
          ];
          if (validKeys.indexOf(event.key) !== -1) {
            event.preventDefault();
            update(true, event);
          }
        }
      };
      const open2 = displayNode !== null && openState;
      const handleBlur = (event) => {
        if (!open2 && onBlur) {
          Object.defineProperty(event, "target", {
            writable: true,
            value: {
              value,
              name
            }
          });
          onBlur(event);
        }
      };
      delete other["aria-invalid"];
      let display;
      let displaySingle;
      const displayMultiple = [];
      let computeDisplay = false;
      if (isFilled({
        value
      }) || displayEmpty) {
        if (renderValue) {
          display = renderValue(value);
        } else {
          computeDisplay = true;
        }
      }
      const items = childrenArray.map((child) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          return null;
        }
        let selected;
        if (multiple) {
          if (!Array.isArray(value)) {
            throw new Error(formatMuiErrorMessage(2));
          }
          selected = value.some((v2) => areEqualValues(v2, child.props.value));
          if (selected && computeDisplay) {
            displayMultiple.push(child.props.children);
          }
        } else {
          selected = areEqualValues(value, child.props.value);
          if (selected && computeDisplay) {
            displaySingle = child.props.children;
          }
        }
        return /* @__PURE__ */ reactExports.cloneElement(child, {
          "aria-selected": selected ? "true" : "false",
          onClick: handleItemClick(child),
          onKeyUp: (event) => {
            if (event.key === " ") {
              event.preventDefault();
            }
            if (child.props.onKeyUp) {
              child.props.onKeyUp(event);
            }
          },
          role: "option",
          selected,
          value: void 0,
          // The value is most likely not a valid HTML attribute.
          "data-value": child.props.value
          // Instead, we provide it as a data attribute.
        });
      });
      if (computeDisplay) {
        if (multiple) {
          if (displayMultiple.length === 0) {
            display = null;
          } else {
            display = displayMultiple.reduce((output, child, index2) => {
              output.push(child);
              if (index2 < displayMultiple.length - 1) {
                output.push(", ");
              }
              return output;
            }, []);
          }
        } else {
          display = displaySingle;
        }
      }
      let menuMinWidth = menuMinWidthState;
      if (!autoWidth && isOpenControlled && displayNode) {
        menuMinWidth = anchorElement.clientWidth;
      }
      let tabIndex;
      if (typeof tabIndexProp !== "undefined") {
        tabIndex = tabIndexProp;
      } else {
        tabIndex = disabled ? null : 0;
      }
      const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
      const ownerState = _extends$1({}, props, {
        variant,
        value,
        open: open2,
        error
      });
      const classes = useUtilityClasses$o(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$1({
          ref: handleDisplayRef,
          tabIndex,
          role: "button",
          "aria-disabled": disabled ? "true" : void 0,
          "aria-expanded": open2 ? "true" : "false",
          "aria-haspopup": "listbox",
          "aria-label": ariaLabel,
          "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
          "aria-describedby": ariaDescribedby,
          onKeyDown: handleKeyDown2,
          onMouseDown: disabled || readOnly ? null : handleMouseDown,
          onBlur: handleBlur,
          onFocus
        }, SelectDisplayProps, {
          ownerState,
          className: clsx$1(SelectDisplayProps.className, classes.select, className),
          id: buttonId,
          children: isEmpty(display) ? (
            // notranslate needed while Google Translate will not fix zero-width space issue
            _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: "​"
            }))
          ) : display
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$1({
          "aria-invalid": error,
          value: Array.isArray(value) ? value.join(",") : value,
          name,
          ref: inputRef,
          "aria-hidden": true,
          onChange: handleChange,
          tabIndex: -1,
          disabled,
          className: classes.nativeInput,
          autoFocus,
          ownerState
        }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
          as: IconComponent,
          className: classes.icon,
          ownerState
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends$1({
          id: `menu-${name || ""}`,
          anchorEl: anchorElement,
          open: open2,
          onClose: handleClose,
          anchorOrigin: {
            vertical: "bottom",
            horizontal: "center"
          },
          transformOrigin: {
            vertical: "top",
            horizontal: "center"
          }
        }, MenuProps, {
          MenuListProps: _extends$1({
            "aria-labelledby": labelId,
            role: "listbox",
            disableListWrap: true
          }, MenuProps.MenuListProps),
          PaperProps: _extends$1({}, MenuProps.PaperProps, {
            style: _extends$1({
              minWidth: menuMinWidth
            }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
          }),
          children: items
        }))]
      });
    });
    const SelectInput$1 = SelectInput;
    const _excluded$q = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"];
    const useUtilityClasses$n = (ownerState) => {
      const {
        classes
      } = ownerState;
      return classes;
    };
    const styledRootConfig = {
      name: "MuiSelect",
      overridesResolver: (props, styles2) => styles2.root,
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
      slot: "Root"
    };
    const StyledInput = styled$1(Input$1, styledRootConfig)("");
    const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)("");
    const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)("");
    const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
      const props = useThemeProps({
        name: "MuiSelect",
        props: inProps
      });
      const {
        autoWidth = false,
        children,
        classes: classesProp = {},
        className,
        defaultOpen = false,
        displayEmpty = false,
        IconComponent = ArrowDropDownIcon$1,
        id: id2,
        input,
        inputProps,
        label,
        labelId,
        MenuProps,
        multiple = false,
        native = false,
        onClose,
        onOpen,
        open: open2,
        renderValue,
        SelectDisplayProps,
        variant: variantProp = "outlined"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$q);
      const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["variant", "error"]
      });
      const variant = fcs.variant || variantProp;
      const ownerState = _extends$1({}, props, {
        variant,
        classes: classesProp
      });
      const classes = useUtilityClasses$n(ownerState);
      const InputComponent = input || {
        standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
          ownerState
        }),
        outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
          label,
          ownerState
        }),
        filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
          ownerState
        })
      }[variant];
      const inputComponentRef = useForkRef(ref, InputComponent.ref);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$1({
          // Most of the logic is implemented in `SelectInput`.
          // The `Select` component is a simple API wrapper to expose something better to play with.
          inputComponent,
          inputProps: _extends$1({
            children,
            error: fcs.error,
            IconComponent,
            variant,
            type: void 0,
            // We render a select. We can ignore the type provided by the `Input`.
            multiple
          }, native ? {
            id: id2
          } : {
            autoWidth,
            defaultOpen,
            displayEmpty,
            labelId,
            MenuProps,
            onClose,
            onOpen,
            open: open2,
            renderValue,
            SelectDisplayProps: _extends$1({
              id: id2
            }, SelectDisplayProps)
          }, inputProps, {
            classes: inputProps ? deepmerge(classes, inputProps.classes) : classes
          }, input ? input.props.inputProps : {})
        }, multiple && native && variant === "outlined" ? {
          notched: true
        } : {}, {
          ref: inputComponentRef,
          className: clsx$1(InputComponent.props.className, className)
        }, !input && {
          variant
        }, other))
      });
    });
    Select.muiName = "Select";
    const Select$1 = Select;
    const TableContext = /* @__PURE__ */ reactExports.createContext();
    const TableContext$1 = TableContext;
    function getTableUtilityClass(slot) {
      return generateUtilityClass("MuiTable", slot);
    }
    generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
    const _excluded$p = ["className", "component", "padding", "size", "stickyHeader"];
    const useUtilityClasses$m = (ownerState) => {
      const {
        classes,
        stickyHeader
      } = ownerState;
      const slots = {
        root: ["root", stickyHeader && "stickyHeader"]
      };
      return composeClasses(slots, getTableUtilityClass, classes);
    };
    const TableRoot = styled$1("table", {
      name: "MuiTable",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "table",
      width: "100%",
      borderCollapse: "collapse",
      borderSpacing: 0,
      "& caption": _extends$1({}, theme.typography.body2, {
        padding: theme.spacing(2),
        color: (theme.vars || theme).palette.text.secondary,
        textAlign: "left",
        captionSide: "bottom"
      })
    }, ownerState.stickyHeader && {
      borderCollapse: "separate"
    }));
    const defaultComponent$3 = "table";
    const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTable"
      });
      const {
        className,
        component = defaultComponent$3,
        padding: padding2 = "normal",
        size = "medium",
        stickyHeader = false
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$p);
      const ownerState = _extends$1({}, props, {
        component,
        padding: padding2,
        size,
        stickyHeader
      });
      const classes = useUtilityClasses$m(ownerState);
      const table2 = reactExports.useMemo(() => ({
        padding: padding2,
        size,
        stickyHeader
      }), [padding2, size, stickyHeader]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext$1.Provider, {
        value: table2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, _extends$1({
          as: component,
          role: component === defaultComponent$3 ? null : "table",
          ref,
          className: clsx$1(classes.root, className),
          ownerState
        }, other))
      });
    });
    const Table$1 = Table;
    const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
    const Tablelvl2Context$1 = Tablelvl2Context;
    function getTableBodyUtilityClass(slot) {
      return generateUtilityClass("MuiTableBody", slot);
    }
    generateUtilityClasses("MuiTableBody", ["root"]);
    const _excluded$o = ["className", "component"];
    const useUtilityClasses$l = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getTableBodyUtilityClass, classes);
    };
    const TableBodyRoot = styled$1("tbody", {
      name: "MuiTableBody",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "table-row-group"
    });
    const tablelvl2$1 = {
      variant: "body"
    };
    const defaultComponent$2 = "tbody";
    const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTableBody"
      });
      const {
        className,
        component = defaultComponent$2
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$o);
      const ownerState = _extends$1({}, props, {
        component
      });
      const classes = useUtilityClasses$l(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context$1.Provider, {
        value: tablelvl2$1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, _extends$1({
          className: clsx$1(classes.root, className),
          as: component,
          ref,
          role: component === defaultComponent$2 ? null : "rowgroup",
          ownerState
        }, other))
      });
    });
    const TableBody$1 = TableBody;
    function getTableCellUtilityClass(slot) {
      return generateUtilityClass("MuiTableCell", slot);
    }
    const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
    const tableCellClasses$1 = tableCellClasses;
    const _excluded$n = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"];
    const useUtilityClasses$k = (ownerState) => {
      const {
        classes,
        variant,
        align,
        padding: padding2,
        size,
        stickyHeader
      } = ownerState;
      const slots = {
        root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize(align)}`, padding2 !== "normal" && `padding${capitalize(padding2)}`, `size${capitalize(size)}`]
      };
      return composeClasses(slots, getTableCellUtilityClass, classes);
    };
    const TableCellRoot = styled$1("td", {
      name: "MuiTableCell",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.body2, {
      display: "table-cell",
      verticalAlign: "inherit",
      // Workaround for a rendering bug with spanned columns in Chrome 62.0.
      // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
      borderBottom: theme.vars ? `1px solid ${theme.vars.palette.TableCell.border}` : `1px solid
    ${theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68)}`,
      textAlign: "left",
      padding: 16
    }, ownerState.variant === "head" && {
      color: (theme.vars || theme).palette.text.primary,
      lineHeight: theme.typography.pxToRem(24),
      fontWeight: theme.typography.fontWeightMedium
    }, ownerState.variant === "body" && {
      color: (theme.vars || theme).palette.text.primary
    }, ownerState.variant === "footer" && {
      color: (theme.vars || theme).palette.text.secondary,
      lineHeight: theme.typography.pxToRem(21),
      fontSize: theme.typography.pxToRem(12)
    }, ownerState.size === "small" && {
      padding: "6px 16px",
      [`&.${tableCellClasses$1.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }, ownerState.padding === "checkbox" && {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }, ownerState.padding === "none" && {
      padding: 0
    }, ownerState.align === "left" && {
      textAlign: "left"
    }, ownerState.align === "center" && {
      textAlign: "center"
    }, ownerState.align === "right" && {
      textAlign: "right",
      flexDirection: "row-reverse"
    }, ownerState.align === "justify" && {
      textAlign: "justify"
    }, ownerState.stickyHeader && {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (theme.vars || theme).palette.background.default
    }));
    const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTableCell"
      });
      const {
        align = "inherit",
        className,
        component: componentProp,
        padding: paddingProp,
        scope: scopeProp,
        size: sizeProp,
        sortDirection,
        variant: variantProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$n);
      const table2 = reactExports.useContext(TableContext$1);
      const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
      const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
      let component;
      if (componentProp) {
        component = componentProp;
      } else {
        component = isHeadCell ? "th" : "td";
      }
      let scope = scopeProp;
      if (component === "td") {
        scope = void 0;
      } else if (!scope && isHeadCell) {
        scope = "col";
      }
      const variant = variantProp || tablelvl22 && tablelvl22.variant;
      const ownerState = _extends$1({}, props, {
        align,
        component,
        padding: paddingProp || (table2 && table2.padding ? table2.padding : "normal"),
        size: sizeProp || (table2 && table2.size ? table2.size : "medium"),
        sortDirection,
        stickyHeader: variant === "head" && table2 && table2.stickyHeader,
        variant
      });
      const classes = useUtilityClasses$k(ownerState);
      let ariaSort = null;
      if (sortDirection) {
        ariaSort = sortDirection === "asc" ? "ascending" : "descending";
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, _extends$1({
        as: component,
        ref,
        className: clsx$1(classes.root, className),
        "aria-sort": ariaSort,
        scope,
        ownerState
      }, other));
    });
    const TableCell$1 = TableCell;
    function getTableContainerUtilityClass(slot) {
      return generateUtilityClass("MuiTableContainer", slot);
    }
    generateUtilityClasses("MuiTableContainer", ["root"]);
    const _excluded$m = ["className", "component"];
    const useUtilityClasses$j = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getTableContainerUtilityClass, classes);
    };
    const TableContainerRoot = styled$1("div", {
      name: "MuiTableContainer",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      width: "100%",
      overflowX: "auto"
    });
    const TableContainer = /* @__PURE__ */ reactExports.forwardRef(function TableContainer2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTableContainer"
      });
      const {
        className,
        component = "div"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$m);
      const ownerState = _extends$1({}, props, {
        component
      });
      const classes = useUtilityClasses$j(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainerRoot, _extends$1({
        ref,
        as: component,
        className: clsx$1(classes.root, className),
        ownerState
      }, other));
    });
    const TableContainer$1 = TableContainer;
    function getTableHeadUtilityClass(slot) {
      return generateUtilityClass("MuiTableHead", slot);
    }
    generateUtilityClasses("MuiTableHead", ["root"]);
    const _excluded$l = ["className", "component"];
    const useUtilityClasses$i = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getTableHeadUtilityClass, classes);
    };
    const TableHeadRoot = styled$1("thead", {
      name: "MuiTableHead",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "table-header-group"
    });
    const tablelvl2 = {
      variant: "head"
    };
    const defaultComponent$1 = "thead";
    const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTableHead"
      });
      const {
        className,
        component = defaultComponent$1
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$l);
      const ownerState = _extends$1({}, props, {
        component
      });
      const classes = useUtilityClasses$i(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context$1.Provider, {
        value: tablelvl2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, _extends$1({
          as: component,
          className: clsx$1(classes.root, className),
          ref,
          role: component === defaultComponent$1 ? null : "rowgroup",
          ownerState
        }, other))
      });
    });
    const TableHead$1 = TableHead;
    function getToolbarUtilityClass(slot) {
      return generateUtilityClass("MuiToolbar", slot);
    }
    generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
    const _excluded$k = ["className", "component", "disableGutters", "variant"];
    const useUtilityClasses$h = (ownerState) => {
      const {
        classes,
        disableGutters,
        variant
      } = ownerState;
      const slots = {
        root: ["root", !disableGutters && "gutters", variant]
      };
      return composeClasses(slots, getToolbarUtilityClass, classes);
    };
    const ToolbarRoot = styled$1("div", {
      name: "MuiToolbar",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      position: "relative",
      display: "flex",
      alignItems: "center"
    }, !ownerState.disableGutters && {
      paddingLeft: theme.spacing(2),
      paddingRight: theme.spacing(2),
      [theme.breakpoints.up("sm")]: {
        paddingLeft: theme.spacing(3),
        paddingRight: theme.spacing(3)
      }
    }, ownerState.variant === "dense" && {
      minHeight: 48
    }), ({
      theme,
      ownerState
    }) => ownerState.variant === "regular" && theme.mixins.toolbar);
    const Toolbar = /* @__PURE__ */ reactExports.forwardRef(function Toolbar2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiToolbar"
      });
      const {
        className,
        component = "div",
        disableGutters = false,
        variant = "regular"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$k);
      const ownerState = _extends$1({}, props, {
        component,
        disableGutters,
        variant
      });
      const classes = useUtilityClasses$h(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarRoot, _extends$1({
        as: component,
        className: clsx$1(classes.root, className),
        ref,
        ownerState
      }, other));
    });
    const Toolbar$1 = Toolbar;
    function getTableRowUtilityClass(slot) {
      return generateUtilityClass("MuiTableRow", slot);
    }
    const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
    const tableRowClasses$1 = tableRowClasses;
    const _excluded$j = ["className", "component", "hover", "selected"];
    const useUtilityClasses$g = (ownerState) => {
      const {
        classes,
        selected,
        hover,
        head,
        footer
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
      };
      return composeClasses(slots, getTableRowUtilityClass, classes);
    };
    const TableRowRoot = styled$1("tr", {
      name: "MuiTableRow",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
      }
    })(({
      theme
    }) => ({
      color: "inherit",
      display: "table-row",
      verticalAlign: "middle",
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      [`&.${tableRowClasses$1.hover}:hover`]: {
        backgroundColor: (theme.vars || theme).palette.action.hover
      },
      [`&.${tableRowClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
        }
      }
    }));
    const defaultComponent = "tr";
    const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTableRow"
      });
      const {
        className,
        component = defaultComponent,
        hover = false,
        selected = false
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$j);
      const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
      const ownerState = _extends$1({}, props, {
        component,
        hover,
        selected,
        head: tablelvl22 && tablelvl22.variant === "head",
        footer: tablelvl22 && tablelvl22.variant === "footer"
      });
      const classes = useUtilityClasses$g(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, _extends$1({
        as: component,
        ref,
        className: clsx$1(classes.root, className),
        role: component === defaultComponent ? null : "row",
        ownerState
      }, other));
    });
    const TableRow$1 = TableRow;
    function getTextFieldUtilityClass(slot) {
      return generateUtilityClass("MuiTextField", slot);
    }
    generateUtilityClasses("MuiTextField", ["root"]);
    const _excluded$i = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
    const variantComponent = {
      standard: Input$1,
      filled: FilledInput$1,
      outlined: OutlinedInput$1
    };
    const useUtilityClasses$f = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getTextFieldUtilityClass, classes);
    };
    const TextFieldRoot = styled$1(FormControl$1, {
      name: "MuiTextField",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTextField"
      });
      const {
        autoComplete,
        autoFocus = false,
        children,
        className,
        color: color2 = "primary",
        defaultValue,
        disabled = false,
        error = false,
        FormHelperTextProps,
        fullWidth = false,
        helperText,
        id: idOverride,
        InputLabelProps,
        inputProps,
        InputProps,
        inputRef,
        label,
        maxRows,
        minRows,
        multiline = false,
        name,
        onBlur,
        onChange,
        onClick,
        onFocus,
        placeholder,
        required = false,
        rows,
        select = false,
        SelectProps,
        type,
        value,
        variant = "outlined"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$i);
      const ownerState = _extends$1({}, props, {
        autoFocus,
        color: color2,
        disabled,
        error,
        fullWidth,
        multiline,
        required,
        select,
        variant
      });
      const classes = useUtilityClasses$f(ownerState);
      const InputMore = {};
      if (variant === "outlined") {
        if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
          InputMore.notched = InputLabelProps.shrink;
        }
        InputMore.label = label;
      }
      if (select) {
        if (!SelectProps || !SelectProps.native) {
          InputMore.id = void 0;
        }
        InputMore["aria-describedby"] = void 0;
      }
      const id2 = useId(idOverride);
      const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
      const inputLabelId = label && id2 ? `${id2}-label` : void 0;
      const InputComponent = variantComponent[variant];
      const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, _extends$1({
        "aria-describedby": helperTextId,
        autoComplete,
        autoFocus,
        defaultValue,
        fullWidth,
        multiline,
        name,
        rows,
        maxRows,
        minRows,
        type,
        value,
        id: id2,
        inputRef,
        onBlur,
        onChange,
        onFocus,
        onClick,
        placeholder,
        inputProps
      }, InputMore, InputProps));
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, _extends$1({
        className: clsx$1(classes.root, className),
        disabled,
        error,
        fullWidth,
        ref,
        required,
        color: color2,
        variant,
        ownerState
      }, other, {
        children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, _extends$1({
          htmlFor: id2,
          id: inputLabelId
        }, InputLabelProps, {
          children: label
        })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, _extends$1({
          "aria-describedby": helperTextId,
          id: id2,
          labelId: inputLabelId,
          value,
          input: InputElement
        }, SelectProps, {
          children
        })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, _extends$1({
          id: helperTextId
        }, FormHelperTextProps, {
          children: helperText
        }))]
      }));
    });
    const TextField$1 = TextField;
    var dayjs_min = { exports: {} };
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date())
            return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = function(t3) {
          return t3 instanceof b2;
        }, S2 = function t3(e3, n3, r3) {
          var i3;
          if (!e3)
            return g2;
          if ("string" == typeof e3) {
            var s3 = e3.toLowerCase();
            D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
            var u3 = e3.split("-");
            if (!i3 && u3.length > 1)
              return t3(u3[0]);
          } else {
            var a3 = e3.name;
            D2[a3] = e3, i3 = a3;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, w2 = function(t3, e3) {
          if (p2(t3))
            return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new b2(n3);
        }, O2 = v2;
        O2.l = S2, O2.i = p2, O2.w = function(t3, e3) {
          return w2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var b2 = function() {
          function M3(t3) {
            this.$L = S2(t3.locale, null, true), this.parse(t3);
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3)
                return /* @__PURE__ */ new Date(NaN);
              if (O2.u(e3))
                return /* @__PURE__ */ new Date();
              if (e3 instanceof Date)
                return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                }
              }
              return new Date(e3);
            }(t3), this.$x = t3.x || {}, this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return O2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e3) {
            var n3 = w2(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return w2(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < w2(t3);
          }, m3.$g = function(t3, e3, n3) {
            return O2.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!O2.u(e3) || e3, f3 = O2.p(t3), l3 = function(t4, e4) {
              var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i3 : i3.endOf(a2);
            }, $2 = function(t4, e4) {
              return O2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c2:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a2:
              case d2:
                return $2(v3 + "Hours", 0);
              case u2:
                return $2(v3 + "Minutes", 1);
              case s2:
                return $2(v3 + "Seconds", 2);
              case i2:
                return $2(v3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = O2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
            if (o3 === c2 || o3 === h2) {
              var y3 = this.clone().set(d2, 1);
              y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
            } else
              l3 && this.$d[l3]($2);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[O2.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $2 = O2.p(f3), y3 = function(t3) {
              var e3 = w2(l3);
              return O2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
            };
            if ($2 === c2)
              return this.set(c2, this.$M + r3);
            if ($2 === h2)
              return this.set(h2, this.$y + r3);
            if ($2 === a2)
              return y3(1);
            if ($2 === o2)
              return y3(7);
            var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
            return O2.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid())
              return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
              return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
            }, d3 = function(t4) {
              return O2.s(s3 % 12 || 12, t4, "0");
            }, $2 = f3 || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y2, function(t4, r4) {
              return r4 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return O2.s(e3.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return O2.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a3, c3, 3);
                  case "MMMM":
                    return h3(c3, a3);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return O2.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e3.$W, o3, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e3.$W, o3, 3);
                  case "dddd":
                    return o3[e3.$W];
                  case "H":
                    return String(s3);
                  case "HH":
                    return O2.s(s3, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $2(s3, u3, true);
                  case "A":
                    return $2(s3, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return O2.s(u3, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return O2.s(e3.$s, 2, "0");
                  case "SSS":
                    return O2.s(e3.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              }(t4) || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $2, y3 = this, M4 = O2.p(d3), m4 = w2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
              return O2.m(y3, m4);
            };
            switch (M4) {
              case h2:
                $2 = D3() / 12;
                break;
              case c2:
                $2 = D3();
                break;
              case f2:
                $2 = D3() / 3;
                break;
              case o2:
                $2 = (g3 - v3) / 6048e5;
                break;
              case a2:
                $2 = (g3 - v3) / 864e5;
                break;
              case u2:
                $2 = g3 / n2;
                break;
              case s2:
                $2 = g3 / e2;
                break;
              case i2:
                $2 = g3 / t2;
                break;
              default:
                $2 = g3;
            }
            return l3 ? $2 : O2.a($2);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3)
              return this.$L;
            var n3 = this.clone(), r3 = S2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return O2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), _2 = b2.prototype;
        return w2.prototype = _2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
          _2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), w2.extend = function(t3, e3) {
          return t3.$i || (t3(e3, b2, w2), t3.$i = true), w2;
        }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t3) {
          return w2(1e3 * t3);
        }, w2.en = D2[g2], w2.Ls = D2, w2.p = {}, w2;
      });
    })(dayjs_min);
    var dayjs_minExports = dayjs_min.exports;
    const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
    var weekOfYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = "week", t2 = "year";
        return function(i2, n2, r2) {
          var f2 = n2.prototype;
          f2.week = function(i3) {
            if (void 0 === i3 && (i3 = null), null !== i3)
              return this.add(7 * (i3 - this.week()), "day");
            var n3 = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
              var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s2 = r2(this).endOf(e2);
              if (f3.isBefore(s2))
                return 1;
            }
            var a2 = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a2, e2, true);
            return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
          }, f2.weeks = function(e3) {
            return void 0 === e3 && (e3 = null), this.week(e3);
          };
        };
      });
    })(weekOfYear$1);
    var weekOfYearExports = weekOfYear$1.exports;
    const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
    var customParseFormat = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i2 = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e3) {
          return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
        };
        var a2 = function(e3) {
          return function(t3) {
            this[e3] = +t3;
          };
        }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
          (this.zone || (this.zone = {})).offset = function(e4) {
            if (!e4)
              return 0;
            if ("Z" === e4)
              return 0;
            var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
            return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
          }(e3);
        }], h2 = function(e3) {
          var t3 = o2[e3];
          return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
        }, u2 = function(e3, t3) {
          var n3, r3 = o2.meridiem;
          if (r3) {
            for (var i3 = 1; i3 <= 24; i3 += 1)
              if (e3.indexOf(r3(i3, 0, t3)) > -1) {
                n3 = i3 > 12;
                break;
              }
          } else
            n3 = e3 === (t3 ? "pm" : "PM");
          return n3;
        }, d2 = { A: [i2, function(e3) {
          this.afternoon = u2(e3, false);
        }], a: [i2, function(e3) {
          this.afternoon = u2(e3, true);
        }], S: [/\d/, function(e3) {
          this.milliseconds = 100 * +e3;
        }], SS: [n2, function(e3) {
          this.milliseconds = 10 * +e3;
        }], SSS: [/\d{3}/, function(e3) {
          this.milliseconds = +e3;
        }], s: [r2, a2("seconds")], ss: [r2, a2("seconds")], m: [r2, a2("minutes")], mm: [r2, a2("minutes")], H: [r2, a2("hours")], h: [r2, a2("hours")], HH: [r2, a2("hours")], hh: [r2, a2("hours")], D: [r2, a2("day")], DD: [n2, a2("day")], Do: [i2, function(e3) {
          var t3 = o2.ordinal, n3 = e3.match(/\d+/);
          if (this.day = n3[0], t3)
            for (var r3 = 1; r3 <= 31; r3 += 1)
              t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
        }], M: [r2, a2("month")], MM: [n2, a2("month")], MMM: [i2, function(e3) {
          var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
            return e4.slice(0, 3);
          })).indexOf(e3) + 1;
          if (n3 < 1)
            throw new Error();
          this.month = n3 % 12 || n3;
        }], MMMM: [i2, function(e3) {
          var t3 = h2("months").indexOf(e3) + 1;
          if (t3 < 1)
            throw new Error();
          this.month = t3 % 12 || t3;
        }], Y: [/[+-]?\d+/, a2("year")], YY: [n2, function(e3) {
          this.year = s2(e3);
        }], YYYY: [/\d{4}/, a2("year")], Z: f2, ZZ: f2 };
        function c2(n3) {
          var r3, i3;
          r3 = n3, i3 = o2 && o2.formats;
          for (var s3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
            var o3 = r4 && r4.toUpperCase();
            return n4 || i3[r4] || e2[r4] || i3[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
              return t4 || n5.slice(1);
            });
          })).match(t2), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
            var h3 = s3[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
            s3[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
          }
          return function(e3) {
            for (var t3 = {}, n4 = 0, r4 = 0; n4 < a3; n4 += 1) {
              var i4 = s3[n4];
              if ("string" == typeof i4)
                r4 += i4.length;
              else {
                var o3 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = o3.exec(h4)[0];
                f4.call(t3, u4), e3 = e3.replace(u4, "");
              }
            }
            return function(e4) {
              var t4 = e4.afternoon;
              if (void 0 !== t4) {
                var n5 = e4.hours;
                t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
              }
            }(t3), t3;
          };
        }
        return function(e3, t3, n3) {
          n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s2 = e3.parseTwoDigitYear);
          var r3 = t3.prototype, i3 = r3.parse;
          r3.parse = function(e4) {
            var t4 = e4.date, r4 = e4.utc, s3 = e4.args;
            this.$u = r4;
            var a3 = s3[1];
            if ("string" == typeof a3) {
              var f3 = true === s3[2], h3 = true === s3[3], u3 = f3 || h3, d3 = s3[2];
              h3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
                try {
                  if (["x", "X"].indexOf(t5) > -1)
                    return new Date(("X" === t5 ? 1e3 : 1) * e5);
                  var r5 = c2(t5)(e5), i4 = r5.year, o3 = r5.month, s4 = r5.day, a4 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = /* @__PURE__ */ new Date(), m3 = s4 || (i4 || o3 ? 1 : l3.getDate()), M3 = i4 || l3.getFullYear(), Y2 = 0;
                  i4 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
                  var p2 = a4 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
                  return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
                } catch (e6) {
                  return /* @__PURE__ */ new Date("");
                }
              }(t4, a3, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a3) && (this.$d = /* @__PURE__ */ new Date("")), o2 = {};
            } else if (a3 instanceof Array)
              for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
                s3[1] = a3[m2 - 1];
                var M2 = n3.apply(this, s3);
                if (M2.isValid()) {
                  this.$d = M2.$d, this.$L = M2.$L, this.init();
                  break;
                }
                m2 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
              }
            else
              i3.call(this, e4);
          };
        };
      });
    })(customParseFormat);
    var customParseFormatExports = customParseFormat.exports;
    const customParseFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
    var localizedFormat = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
        return function(t2, o2, n2) {
          var r2 = o2.prototype, i2 = r2.format;
          n2.en.formats = e2, r2.format = function(t3) {
            void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
            var o3 = this.$locale().formats, n3 = function(t4, o4) {
              return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n4, r3) {
                var i3 = r3 && r3.toUpperCase();
                return n4 || o4[r3] || e2[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o5) {
                  return t6 || o5.slice(1);
                });
              });
            }(t3, void 0 === o3 ? {} : o3);
            return i2.call(this, n3);
          };
        };
      });
    })(localizedFormat);
    var localizedFormatExports = localizedFormat.exports;
    const localizedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
    var isBetween = { exports: {} };
    (function(module2, exports2) {
      !function(e2, i2) {
        module2.exports = i2();
      }(commonjsGlobal, function() {
        return function(e2, i2, t2) {
          i2.prototype.isBetween = function(e3, i3, s2, f2) {
            var n2 = t2(e3), o2 = t2(i3), r2 = "(" === (f2 = f2 || "()")[0], u2 = ")" === f2[1];
            return (r2 ? this.isAfter(n2, s2) : !this.isBefore(n2, s2)) && (u2 ? this.isBefore(o2, s2) : !this.isAfter(o2, s2)) || (r2 ? this.isBefore(n2, s2) : !this.isAfter(n2, s2)) && (u2 ? this.isAfter(o2, s2) : !this.isBefore(o2, s2));
          };
        };
      });
    })(isBetween);
    var isBetweenExports = isBetween.exports;
    const isBetweenPlugin = /* @__PURE__ */ getDefaultExportFromCjs(isBetweenExports);
    const buildWarning = (message, gravity = "warning") => {
      let alreadyWarned = false;
      const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
      return () => {
        if (!alreadyWarned) {
          alreadyWarned = true;
          if (gravity === "error") {
            console.error(cleanMessage);
          } else {
            console.warn(cleanMessage);
          }
        }
      };
    };
    dayjs.extend(customParseFormatPlugin);
    dayjs.extend(localizedFormatPlugin);
    dayjs.extend(isBetweenPlugin);
    const localeNotFoundWarning = buildWarning(["Your locale has not been found.", "Either the locale key is not a supported one. Locales supported by dayjs are available here: https://github.com/iamkun/dayjs/tree/dev/src/locale", "Or you forget to import the locale from 'dayjs/locale/{localeUsed}'", "fallback on English locale"]);
    const formatTokenMap = {
      // Year
      YY: "year",
      YYYY: {
        sectionType: "year",
        contentType: "digit",
        maxLength: 4
      },
      // Month
      M: {
        sectionType: "month",
        contentType: "digit",
        maxLength: 2
      },
      MM: "month",
      MMM: {
        sectionType: "month",
        contentType: "letter"
      },
      MMMM: {
        sectionType: "month",
        contentType: "letter"
      },
      // Day of the month
      D: {
        sectionType: "day",
        contentType: "digit",
        maxLength: 2
      },
      DD: "day",
      Do: {
        sectionType: "day",
        contentType: "digit-with-letter"
      },
      // Day of the week
      d: {
        sectionType: "weekDay",
        contentType: "digit",
        maxLength: 2
      },
      dd: {
        sectionType: "weekDay",
        contentType: "letter"
      },
      ddd: {
        sectionType: "weekDay",
        contentType: "letter"
      },
      dddd: {
        sectionType: "weekDay",
        contentType: "letter"
      },
      // Meridiem
      A: "meridiem",
      a: "meridiem",
      // Hours
      H: {
        sectionType: "hours",
        contentType: "digit",
        maxLength: 2
      },
      HH: "hours",
      h: {
        sectionType: "hours",
        contentType: "digit",
        maxLength: 2
      },
      hh: "hours",
      // Minutes
      m: {
        sectionType: "minutes",
        contentType: "digit",
        maxLength: 2
      },
      mm: "minutes",
      // Seconds
      s: {
        sectionType: "seconds",
        contentType: "digit",
        maxLength: 2
      },
      ss: "seconds"
    };
    const defaultFormats = {
      year: "YYYY",
      month: "MMMM",
      monthShort: "MMM",
      dayOfMonth: "D",
      weekday: "dddd",
      weekdayShort: "ddd",
      hours24h: "HH",
      hours12h: "hh",
      meridiem: "A",
      minutes: "mm",
      seconds: "ss",
      fullDate: "ll",
      fullDateWithWeekday: "dddd, LL",
      keyboardDate: "L",
      shortDate: "MMM D",
      normalDate: "D MMMM",
      normalDateWithWeekday: "ddd, MMM D",
      monthAndYear: "MMMM YYYY",
      monthAndDate: "MMMM D",
      fullTime: "LT",
      fullTime12h: "hh:mm A",
      fullTime24h: "HH:mm",
      fullDateTime: "lll",
      fullDateTime12h: "ll hh:mm A",
      fullDateTime24h: "ll HH:mm",
      keyboardDateTime: "L LT",
      keyboardDateTime12h: "L hh:mm A",
      keyboardDateTime24h: "L HH:mm"
    };
    const MISSING_UTC_PLUGIN = ["Missing UTC plugin", "To be able to use UTC or timezones, you have to enable the `utc` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n");
    const MISSING_TIMEZONE_PLUGIN = ["Missing timezone plugin", "To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");
    const withLocale = (dayjs2, locale) => !locale ? dayjs2 : (...args) => dayjs2(...args).locale(locale);
    class AdapterDayjs {
      constructor({
        locale: _locale,
        formats,
        instance
      } = {}) {
        var _this$rawDayJsInstanc;
        this.isMUIAdapter = true;
        this.isTimezoneCompatible = true;
        this.lib = "dayjs";
        this.rawDayJsInstance = void 0;
        this.dayjs = void 0;
        this.locale = void 0;
        this.formats = void 0;
        this.escapedCharacters = {
          start: "[",
          end: "]"
        };
        this.formatTokenMap = formatTokenMap;
        this.setLocaleToValue = (value) => {
          const expectedLocale = this.getCurrentLocaleCode();
          if (expectedLocale === value.locale()) {
            return value;
          }
          return value.locale(expectedLocale);
        };
        this.hasUTCPlugin = () => typeof dayjs.utc !== "undefined";
        this.hasTimezonePlugin = () => typeof dayjs.tz !== "undefined";
        this.isSame = (value, comparing, comparisonTemplate) => {
          const comparingInValueTimezone = this.setTimezone(comparing, this.getTimezone(value));
          return value.format(comparisonTemplate) === comparingInValueTimezone.format(comparisonTemplate);
        };
        this.cleanTimezone = (timezone) => {
          switch (timezone) {
            case "default": {
              return void 0;
            }
            case "system": {
              return dayjs.tz.guess();
            }
            default: {
              return timezone;
            }
          }
        };
        this.createSystemDate = (value) => {
          if (this.rawDayJsInstance) {
            return this.rawDayJsInstance(value);
          }
          if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
            const timezone = dayjs.tz.guess();
            if (timezone !== "UTC") {
              return dayjs.tz(value, timezone);
            }
            return dayjs(value);
          }
          return dayjs(value);
        };
        this.createUTCDate = (value) => {
          if (!this.hasUTCPlugin()) {
            throw new Error(MISSING_UTC_PLUGIN);
          }
          return dayjs.utc(value);
        };
        this.createTZDate = (value, timezone) => {
          if (!this.hasUTCPlugin()) {
            throw new Error(MISSING_UTC_PLUGIN);
          }
          if (!this.hasTimezonePlugin()) {
            throw new Error(MISSING_TIMEZONE_PLUGIN);
          }
          const keepLocalTime = value !== void 0 && !value.endsWith("Z");
          return dayjs(value).tz(this.cleanTimezone(timezone), keepLocalTime);
        };
        this.getLocaleFormats = () => {
          const locales = dayjs.Ls;
          const locale = this.locale || "en";
          let localeObject = locales[locale];
          if (localeObject === void 0) {
            localeNotFoundWarning();
            localeObject = locales.en;
          }
          return localeObject.formats;
        };
        this.adjustOffset = (value) => {
          if (!this.hasTimezonePlugin()) {
            return value;
          }
          const timezone = this.getTimezone(value);
          if (timezone !== "UTC") {
            var _fixedValue$$offset, _value$$offset;
            const fixedValue = value.tz(this.cleanTimezone(timezone), true);
            if (((_fixedValue$$offset = fixedValue.$offset) != null ? _fixedValue$$offset : 0) === ((_value$$offset = value.$offset) != null ? _value$$offset : 0)) {
              return value;
            }
            return fixedValue;
          }
          return value;
        };
        this.date = (value) => {
          if (value === null) {
            return null;
          }
          return this.dayjs(value);
        };
        this.dateWithTimezone = (value, timezone) => {
          if (value === null) {
            return null;
          }
          let parsedValue;
          if (timezone === "UTC") {
            parsedValue = this.createUTCDate(value);
          } else if (timezone === "system" || timezone === "default" && !this.hasTimezonePlugin()) {
            parsedValue = this.createSystemDate(value);
          } else {
            parsedValue = this.createTZDate(value, timezone);
          }
          if (this.locale === void 0) {
            return parsedValue;
          }
          return parsedValue.locale(this.locale);
        };
        this.getTimezone = (value) => {
          if (this.hasUTCPlugin() && value.isUTC()) {
            return "UTC";
          }
          if (this.hasTimezonePlugin()) {
            var _value$$x;
            const zone = (_value$$x = value.$x) == null ? void 0 : _value$$x.$timezone;
            return zone != null ? zone : "system";
          }
          return "system";
        };
        this.setTimezone = (value, timezone) => {
          if (this.getTimezone(value) === timezone) {
            return value;
          }
          if (timezone === "UTC") {
            if (!this.hasUTCPlugin()) {
              throw new Error(MISSING_UTC_PLUGIN);
            }
            return value.utc();
          }
          if (timezone === "system") {
            return value.local();
          }
          if (!this.hasTimezonePlugin()) {
            if (timezone === "default") {
              return value;
            }
            throw new Error(MISSING_TIMEZONE_PLUGIN);
          }
          return dayjs.tz(value, this.cleanTimezone(timezone));
        };
        this.toJsDate = (value) => {
          return value.toDate();
        };
        this.parseISO = (isoString) => {
          return this.dayjs(isoString);
        };
        this.toISO = (value) => {
          return value.toISOString();
        };
        this.parse = (value, format) => {
          if (value === "") {
            return null;
          }
          return this.dayjs(value, format, this.locale, true);
        };
        this.getCurrentLocaleCode = () => {
          return this.locale || "en";
        };
        this.is12HourCycleInCurrentLocale = () => {
          return /A|a/.test(this.getLocaleFormats().LT || "");
        };
        this.expandFormat = (format) => {
          const localeFormats = this.getLocaleFormats();
          const t2 = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_2, a2, b2) => a2 || b2.slice(1));
          return format.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_2, a2, b2) => {
            const B2 = b2 && b2.toUpperCase();
            return a2 || localeFormats[b2] || t2(localeFormats[B2]);
          });
        };
        this.getFormatHelperText = (format) => {
          return this.expandFormat(format).replace(/a/gi, "(a|p)m").toLocaleLowerCase();
        };
        this.isNull = (value) => {
          return value === null;
        };
        this.isValid = (value) => {
          return this.dayjs(value).isValid();
        };
        this.format = (value, formatKey) => {
          return this.formatByString(value, this.formats[formatKey]);
        };
        this.formatByString = (value, formatString) => {
          return this.dayjs(value).format(formatString);
        };
        this.formatNumber = (numberToFormat) => {
          return numberToFormat;
        };
        this.getDiff = (value, comparing, unit) => {
          return value.diff(comparing, unit);
        };
        this.isEqual = (value, comparing) => {
          if (value === null && comparing === null) {
            return true;
          }
          return this.dayjs(value).toDate().getTime() === this.dayjs(comparing).toDate().getTime();
        };
        this.isSameYear = (value, comparing) => {
          return this.isSame(value, comparing, "YYYY");
        };
        this.isSameMonth = (value, comparing) => {
          return this.isSame(value, comparing, "YYYY-MM");
        };
        this.isSameDay = (value, comparing) => {
          return this.isSame(value, comparing, "YYYY-MM-DD");
        };
        this.isSameHour = (value, comparing) => {
          return value.isSame(comparing, "hour");
        };
        this.isAfter = (value, comparing) => {
          return value > comparing;
        };
        this.isAfterYear = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isAfter(comparing, "year");
          }
          return !this.isSameYear(value, comparing) && value.utc() > comparing.utc();
        };
        this.isAfterDay = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isAfter(comparing, "day");
          }
          return !this.isSameDay(value, comparing) && value.utc() > comparing.utc();
        };
        this.isBefore = (value, comparing) => {
          return value < comparing;
        };
        this.isBeforeYear = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isBefore(comparing, "year");
          }
          return !this.isSameYear(value, comparing) && value.utc() < comparing.utc();
        };
        this.isBeforeDay = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isBefore(comparing, "day");
          }
          return !this.isSameDay(value, comparing) && value.utc() < comparing.utc();
        };
        this.isWithinRange = (value, [start, end]) => {
          return value >= start && value <= end;
        };
        this.startOfYear = (value) => {
          return this.adjustOffset(value.startOf("year"));
        };
        this.startOfMonth = (value) => {
          return this.adjustOffset(value.startOf("month"));
        };
        this.startOfWeek = (value) => {
          return this.adjustOffset(value.startOf("week"));
        };
        this.startOfDay = (value) => {
          return this.adjustOffset(value.startOf("day"));
        };
        this.endOfYear = (value) => {
          return this.adjustOffset(value.endOf("year"));
        };
        this.endOfMonth = (value) => {
          return this.adjustOffset(value.endOf("month"));
        };
        this.endOfWeek = (value) => {
          return this.adjustOffset(value.endOf("week"));
        };
        this.endOfDay = (value) => {
          return this.adjustOffset(value.endOf("day"));
        };
        this.addYears = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "year") : value.add(amount, "year"));
        };
        this.addMonths = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "month") : value.add(amount, "month"));
        };
        this.addWeeks = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "week") : value.add(amount, "week"));
        };
        this.addDays = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "day") : value.add(amount, "day"));
        };
        this.addHours = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "hour") : value.add(amount, "hour"));
        };
        this.addMinutes = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "minute") : value.add(amount, "minute"));
        };
        this.addSeconds = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "second") : value.add(amount, "second"));
        };
        this.getYear = (value) => {
          return value.year();
        };
        this.getMonth = (value) => {
          return value.month();
        };
        this.getDate = (value) => {
          return value.date();
        };
        this.getHours = (value) => {
          return value.hour();
        };
        this.getMinutes = (value) => {
          return value.minute();
        };
        this.getSeconds = (value) => {
          return value.second();
        };
        this.getMilliseconds = (value) => {
          return value.millisecond();
        };
        this.setYear = (value, year) => {
          return this.adjustOffset(value.set("year", year));
        };
        this.setMonth = (value, month) => {
          return this.adjustOffset(value.set("month", month));
        };
        this.setDate = (value, date) => {
          return this.adjustOffset(value.set("date", date));
        };
        this.setHours = (value, hours) => {
          return this.adjustOffset(value.set("hour", hours));
        };
        this.setMinutes = (value, minutes) => {
          return this.adjustOffset(value.set("minute", minutes));
        };
        this.setSeconds = (value, seconds) => {
          return this.adjustOffset(value.set("second", seconds));
        };
        this.setMilliseconds = (value, milliseconds) => {
          return this.adjustOffset(value.set("millisecond", milliseconds));
        };
        this.getDaysInMonth = (value) => {
          return value.daysInMonth();
        };
        this.getNextMonth = (value) => {
          return this.addMonths(value, 1);
        };
        this.getPreviousMonth = (value) => {
          return this.addMonths(value, -1);
        };
        this.getMonthArray = (value) => {
          const firstMonth = value.startOf("year");
          const monthArray = [firstMonth];
          while (monthArray.length < 12) {
            const prevMonth = monthArray[monthArray.length - 1];
            monthArray.push(this.addMonths(prevMonth, 1));
          }
          return monthArray;
        };
        this.mergeDateAndTime = (dateParam, timeParam) => {
          return dateParam.hour(timeParam.hour()).minute(timeParam.minute()).second(timeParam.second());
        };
        this.getWeekdays = () => {
          const start = this.dayjs().startOf("week");
          return [0, 1, 2, 3, 4, 5, 6].map((diff) => this.formatByString(this.addDays(start, diff), "dd"));
        };
        this.getWeekArray = (value) => {
          const cleanValue = this.setLocaleToValue(value);
          const start = cleanValue.startOf("month").startOf("week");
          const end = cleanValue.endOf("month").endOf("week");
          let count = 0;
          let current = start;
          const nestedWeeks = [];
          while (current < end) {
            const weekNumber = Math.floor(count / 7);
            nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
            nestedWeeks[weekNumber].push(current);
            current = this.addDays(current, 1);
            count += 1;
          }
          return nestedWeeks;
        };
        this.getWeekNumber = (value) => {
          return value.week();
        };
        this.getYearRange = (start, end) => {
          const startDate = start.startOf("year");
          const endDate = end.endOf("year");
          const years = [];
          let current = startDate;
          while (current < endDate) {
            years.push(current);
            current = this.addYears(current, 1);
          }
          return years;
        };
        this.getMeridiemText = (ampm) => {
          return ampm === "am" ? "AM" : "PM";
        };
        this.rawDayJsInstance = instance;
        this.dayjs = withLocale((_this$rawDayJsInstanc = this.rawDayJsInstance) != null ? _this$rawDayJsInstanc : dayjs, _locale);
        this.locale = _locale;
        this.formats = _extends$1({}, defaultFormats, formats);
        dayjs.extend(weekOfYear);
      }
    }
    function r$1(e2) {
      var t2, f2, n2 = "";
      if ("string" == typeof e2 || "number" == typeof e2)
        n2 += e2;
      else if ("object" == typeof e2)
        if (Array.isArray(e2))
          for (t2 = 0; t2 < e2.length; t2++)
            e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
        else
          for (t2 in e2)
            e2[t2] && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    function clsx() {
      for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
        (e2 = arguments[f2++]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    const _excluded$h = ["localeText"];
    const MuiPickersAdapterContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocalizationProvider = function LocalizationProvider2(inProps) {
      var _React$useContext;
      const {
        localeText: inLocaleText
      } = inProps, otherInProps = _objectWithoutPropertiesLoose$1(inProps, _excluded$h);
      const {
        utils: parentUtils,
        localeText: parentLocaleText
      } = (_React$useContext = reactExports.useContext(MuiPickersAdapterContext)) != null ? _React$useContext : {
        utils: void 0,
        localeText: void 0
      };
      const props = useThemeProps({
        // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
        // We will then merge this theme value with our value manually
        props: otherInProps,
        name: "MuiLocalizationProvider"
      });
      const {
        children,
        dateAdapter: DateAdapter,
        dateFormats,
        dateLibInstance,
        adapterLocale,
        localeText: themeLocaleText
      } = props;
      const localeText = reactExports.useMemo(() => _extends$1({}, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
      const utils2 = reactExports.useMemo(() => {
        if (!DateAdapter) {
          if (parentUtils) {
            return parentUtils;
          }
          return null;
        }
        const adapter = new DateAdapter({
          locale: adapterLocale,
          formats: dateFormats,
          instance: dateLibInstance
        });
        if (!adapter.isMUIAdapter) {
          throw new Error(["MUI: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
        }
        return adapter;
      }, [DateAdapter, adapterLocale, dateFormats, dateLibInstance, parentUtils]);
      const defaultDates = reactExports.useMemo(() => {
        if (!utils2) {
          return null;
        }
        return {
          minDate: utils2.date("1900-01-01T00:00:00.000"),
          maxDate: utils2.date("2099-12-31T00:00:00.000")
        };
      }, [utils2]);
      const contextValue = reactExports.useMemo(() => {
        return {
          utils: utils2,
          defaultDates,
          localeText
        };
      }, [defaultDates, utils2, localeText]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPickersAdapterContext.Provider, {
        value: contextValue,
        children
      });
    };
    const getPickersLocalization = (pickersTranslations) => {
      return {
        components: {
          MuiLocalizationProvider: {
            defaultProps: {
              localeText: _extends$1({}, pickersTranslations)
            }
          }
        }
      };
    };
    const enUSPickers = {
      // Calendar navigation
      previousMonth: "Previous month",
      nextMonth: "Next month",
      // View navigation
      openPreviousView: "open previous view",
      openNextView: "open next view",
      calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
      // DateRange placeholders
      start: "Start",
      end: "End",
      // Action bar
      cancelButtonLabel: "Cancel",
      clearButtonLabel: "Clear",
      okButtonLabel: "OK",
      todayButtonLabel: "Today",
      // Toolbar titles
      datePickerToolbarTitle: "Select date",
      dateTimePickerToolbarTitle: "Select date & time",
      timePickerToolbarTitle: "Select time",
      dateRangePickerToolbarTitle: "Select date range",
      // Clock labels
      clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? "No time selected" : `Selected time is ${adapter.format(time, "fullTime")}`}`,
      hoursClockNumberText: (hours) => `${hours} hours`,
      minutesClockNumberText: (minutes) => `${minutes} minutes`,
      secondsClockNumberText: (seconds) => `${seconds} seconds`,
      // Digital clock labels
      selectViewText: (view) => `Select ${view}`,
      // Calendar labels
      calendarWeekNumberHeaderLabel: "Week number",
      calendarWeekNumberHeaderText: "#",
      calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
      calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
      // Open picker labels
      openDatePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose date, selected date is ${utils2.format(value, "fullDate")}` : "Choose date",
      openTimePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose time, selected time is ${utils2.format(value, "fullTime")}` : "Choose time",
      // Table labels
      timeTableLabel: "pick time",
      dateTableLabel: "pick date",
      // Field section placeholders
      fieldYearPlaceholder: (params) => "Y".repeat(params.digitAmount),
      fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
      fieldDayPlaceholder: () => "DD",
      fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
      fieldHoursPlaceholder: () => "hh",
      fieldMinutesPlaceholder: () => "mm",
      fieldSecondsPlaceholder: () => "ss",
      fieldMeridiemPlaceholder: () => "aa"
    };
    const DEFAULT_LOCALE = enUSPickers;
    getPickersLocalization(enUSPickers);
    const useLocalizationContext = () => {
      const localization = reactExports.useContext(MuiPickersAdapterContext);
      if (localization === null) {
        throw new Error(["MUI: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));
      }
      if (localization.utils === null) {
        throw new Error(["MUI: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));
      }
      const localeText = reactExports.useMemo(() => _extends$1({}, DEFAULT_LOCALE, localization.localeText), [localization.localeText]);
      return reactExports.useMemo(() => _extends$1({}, localization, {
        localeText
      }), [localization, localeText]);
    };
    const useUtils = () => useLocalizationContext().utils;
    const useDefaultDates = () => useLocalizationContext().defaultDates;
    const useLocaleText = () => useLocalizationContext().localeText;
    const useNow = (timezone) => {
      const utils2 = useUtils();
      const now = reactExports.useRef();
      if (now.current === void 0) {
        now.current = utils2.dateWithTimezone(void 0, timezone);
      }
      return now.current;
    };
    const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    const ArrowLeftIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
    }), "ArrowLeft");
    const ArrowRightIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
    }), "ArrowRight");
    createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
    }), "Calendar");
    createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Clock");
    createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
    }), "DateRange");
    createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Time");
    function getPickersArrowSwitcherUtilityClass(slot) {
      return generateUtilityClass("MuiPickersArrowSwitcher", slot);
    }
    generateUtilityClasses("MuiPickersArrowSwitcher", ["root", "spacer", "button"]);
    const _excluded$g = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel"], _excluded2$2 = ["ownerState"], _excluded3 = ["ownerState"];
    const PickersArrowSwitcherRoot = styled$1("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "flex"
    });
    const PickersArrowSwitcherSpacer = styled$1("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Spacer",
      overridesResolver: (props, styles2) => styles2.spacer
    })(({
      theme
    }) => ({
      width: theme.spacing(3)
    }));
    const PickersArrowSwitcherButton = styled$1(IconButton$1, {
      name: "MuiPickersArrowSwitcher",
      slot: "Button",
      overridesResolver: (props, styles2) => styles2.button
    })(({
      ownerState
    }) => _extends$1({}, ownerState.hidden && {
      visibility: "hidden"
    }));
    const useUtilityClasses$e = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        spacer: ["spacer"],
        button: ["button"]
      };
      return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
    };
    const PickersArrowSwitcher = /* @__PURE__ */ reactExports.forwardRef(function PickersArrowSwitcher2(inProps, ref) {
      var _slots$previousIconBu, _slots$nextIconButton, _slots$leftArrowIcon, _slots$rightArrowIcon;
      const theme = useTheme();
      const isRTL = theme.direction === "rtl";
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersArrowSwitcher"
      });
      const {
        children,
        className,
        slots,
        slotProps,
        isNextDisabled,
        isNextHidden,
        onGoToNext,
        nextLabel,
        isPreviousDisabled,
        isPreviousHidden,
        onGoToPrevious,
        previousLabel
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$g);
      const ownerState = props;
      const classes = useUtilityClasses$e(ownerState);
      const nextProps = {
        isDisabled: isNextDisabled,
        isHidden: isNextHidden,
        goTo: onGoToNext,
        label: nextLabel
      };
      const previousProps = {
        isDisabled: isPreviousDisabled,
        isHidden: isPreviousHidden,
        goTo: onGoToPrevious,
        label: previousLabel
      };
      const [leftProps, rightProps] = isRTL ? [nextProps, previousProps] : [previousProps, nextProps];
      const PreviousIconButton = (_slots$previousIconBu = slots == null ? void 0 : slots.previousIconButton) != null ? _slots$previousIconBu : PickersArrowSwitcherButton;
      const previousIconButtonProps = useSlotProps({
        elementType: PreviousIconButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.previousIconButton,
        additionalProps: {
          size: "medium",
          title: leftProps.label,
          "aria-label": leftProps.label,
          disabled: leftProps.isDisabled,
          edge: "end",
          onClick: leftProps.goTo
        },
        ownerState: _extends$1({}, ownerState, {
          hidden: leftProps.isHidden
        }),
        className: classes.button
      });
      const NextIconButton = (_slots$nextIconButton = slots == null ? void 0 : slots.nextIconButton) != null ? _slots$nextIconButton : PickersArrowSwitcherButton;
      const nextIconButtonProps = useSlotProps({
        elementType: NextIconButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.nextIconButton,
        additionalProps: {
          size: "medium",
          title: rightProps.label,
          "aria-label": rightProps.label,
          disabled: rightProps.isDisabled,
          edge: "start",
          onClick: rightProps.goTo
        },
        ownerState: _extends$1({}, ownerState, {
          hidden: rightProps.isHidden
        }),
        className: classes.button
      });
      const LeftArrowIcon = (_slots$leftArrowIcon = slots == null ? void 0 : slots.leftArrowIcon) != null ? _slots$leftArrowIcon : ArrowLeftIcon;
      const _useSlotProps = useSlotProps({
        elementType: LeftArrowIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.leftArrowIcon,
        additionalProps: {
          fontSize: "inherit"
        },
        ownerState: void 0
      }), leftArrowIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$2);
      const RightArrowIcon = (_slots$rightArrowIcon = slots == null ? void 0 : slots.rightArrowIcon) != null ? _slots$rightArrowIcon : ArrowRightIcon;
      const _useSlotProps2 = useSlotProps({
        elementType: RightArrowIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.rightArrowIcon,
        additionalProps: {
          fontSize: "inherit"
        },
        ownerState: void 0
      }), rightArrowIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps2, _excluded3);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersArrowSwitcherRoot, _extends$1({
        ref,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PreviousIconButton, _extends$1({}, previousIconButtonProps, {
          children: isRTL ? /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps))
        })), children ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
          variant: "subtitle1",
          component: "span",
          children
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcherSpacer, {
          className: classes.spacer,
          ownerState
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(NextIconButton, _extends$1({}, nextIconButtonProps, {
          children: isRTL ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps))
        }))]
      }));
    });
    const areViewsEqual = (views, expectedViews) => {
      if (views.length !== expectedViews.length) {
        return false;
      }
      return expectedViews.every((expectedView) => views.includes(expectedView));
    };
    const applyDefaultViewProps = ({
      openTo,
      defaultOpenTo,
      views,
      defaultViews
    }) => {
      const viewsWithDefault = views != null ? views : defaultViews;
      let openToWithDefault;
      if (openTo != null) {
        openToWithDefault = openTo;
      } else if (viewsWithDefault.includes(defaultOpenTo)) {
        openToWithDefault = defaultOpenTo;
      } else if (viewsWithDefault.length > 0) {
        openToWithDefault = viewsWithDefault[0];
      } else {
        throw new Error("MUI: The `views` prop must contain at least one view");
      }
      return {
        views: viewsWithDefault,
        openTo: openToWithDefault
      };
    };
    const timeViews = ["hours", "minutes", "seconds"];
    const isTimeView = (view) => timeViews.includes(view);
    const getSecondsInDay = (date, utils2) => {
      return utils2.getHours(date) * 3600 + utils2.getMinutes(date) * 60 + utils2.getSeconds(date);
    };
    const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils2) => (dateLeft, dateRight) => {
      if (disableIgnoringDatePartForTimeValidation) {
        return utils2.isAfter(dateLeft, dateRight);
      }
      return getSecondsInDay(dateLeft, utils2) > getSecondsInDay(dateRight, utils2);
    };
    function useViews({
      onChange,
      onViewChange,
      openTo,
      view: inView,
      views,
      autoFocus,
      focusedView: inFocusedView,
      onFocusedViewChange
    }) {
      var _views, _views2;
      const previousOpenTo = reactExports.useRef(openTo);
      const previousViews = reactExports.useRef(views);
      const defaultView = reactExports.useRef(views.includes(openTo) ? openTo : views[0]);
      const [view, setView] = useControlled({
        name: "useViews",
        state: "view",
        controlled: inView,
        default: defaultView.current
      });
      const defaultFocusedView = reactExports.useRef(autoFocus ? view : null);
      const [focusedView, setFocusedView] = useControlled({
        name: "useViews",
        state: "focusedView",
        controlled: inFocusedView,
        default: defaultFocusedView.current
      });
      reactExports.useEffect(() => {
        if (previousOpenTo.current && previousOpenTo.current !== openTo || previousViews.current && previousViews.current.some((previousView2) => !views.includes(previousView2))) {
          setView(views.includes(openTo) ? openTo : views[0]);
          previousViews.current = views;
          previousOpenTo.current = openTo;
        }
      }, [openTo, setView, view, views]);
      const viewIndex = views.indexOf(view);
      const previousView = (_views = views[viewIndex - 1]) != null ? _views : null;
      const nextView = (_views2 = views[viewIndex + 1]) != null ? _views2 : null;
      const handleFocusedViewChange = useEventCallback((viewToFocus, hasFocus) => {
        if (hasFocus) {
          setFocusedView(viewToFocus);
        } else {
          setFocusedView(
            (prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView
            // If false the blur is due to view switching
          );
        }
        onFocusedViewChange == null ? void 0 : onFocusedViewChange(viewToFocus, hasFocus);
      });
      const handleChangeView = useEventCallback((newView) => {
        if (newView === view) {
          return;
        }
        setView(newView);
        handleFocusedViewChange(newView, true);
        if (onViewChange) {
          onViewChange(newView);
        }
      });
      const goToNextView = useEventCallback(() => {
        if (nextView) {
          handleChangeView(nextView);
        }
        handleFocusedViewChange(nextView, true);
      });
      const setValueAndGoToNextView = useEventCallback((value, currentViewSelectionState, selectedView) => {
        const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
        const hasMoreViews = selectedView ? (
          // handles case like `DateTimePicker`, where a view might return a `finish` selection state
          // but we it's not the final view given all `views` -> overall selection state should be `partial`.
          views.indexOf(selectedView) < views.length - 1
        ) : Boolean(nextView);
        const globalSelectionState = isSelectionFinishedOnCurrentView && hasMoreViews ? "partial" : currentViewSelectionState;
        onChange(value, globalSelectionState);
        if (isSelectionFinishedOnCurrentView) {
          goToNextView();
        }
      });
      const setValueAndGoToView = useEventCallback((value, newView, selectedView) => {
        onChange(value, newView ? "partial" : "finish", selectedView);
        if (newView) {
          handleChangeView(newView);
          handleFocusedViewChange(newView, true);
        }
      });
      return {
        view,
        setView: handleChangeView,
        focusedView,
        setFocusedView: handleFocusedViewChange,
        nextView,
        previousView,
        defaultView: defaultView.current,
        goToNextView,
        setValueAndGoToNextView,
        setValueAndGoToView
      };
    }
    function useNextMonthDisabled(month, {
      disableFuture,
      maxDate,
      timezone
    }) {
      const utils2 = useUtils();
      return reactExports.useMemo(() => {
        const now = utils2.dateWithTimezone(void 0, timezone);
        const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now, maxDate) ? now : maxDate);
        return !utils2.isAfter(lastEnabledMonth, month);
      }, [disableFuture, maxDate, month, utils2, timezone]);
    }
    function usePreviousMonthDisabled(month, {
      disablePast,
      minDate,
      timezone
    }) {
      const utils2 = useUtils();
      return reactExports.useMemo(() => {
        const now = utils2.dateWithTimezone(void 0, timezone);
        const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now, minDate) ? now : minDate);
        return !utils2.isBefore(firstEnabledMonth, month);
      }, [disablePast, minDate, month, utils2, timezone]);
    }
    const DAY_SIZE = 36;
    const DAY_MARGIN = 2;
    const DIALOG_WIDTH = 320;
    const VIEW_HEIGHT = 358;
    const PickerViewRoot = styled$1("div")({
      overflow: "hidden",
      width: DIALOG_WIDTH,
      maxHeight: VIEW_HEIGHT,
      display: "flex",
      flexDirection: "column",
      margin: "0 auto"
    });
    const useValueWithTimezone = ({
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager
    }) => {
      var _ref, _ref2;
      const utils2 = useUtils();
      const firstDefaultValue = reactExports.useRef(defaultValue);
      const inputValue = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : valueManager.emptyValue;
      const inputTimezone = reactExports.useMemo(() => valueManager.getTimezone(utils2, inputValue), [utils2, valueManager, inputValue]);
      const setInputTimezone = useEventCallback((newValue) => {
        if (inputTimezone == null) {
          return newValue;
        }
        return valueManager.setTimezone(utils2, inputTimezone, newValue);
      });
      const timezoneToRender = (_ref2 = timezoneProp != null ? timezoneProp : inputTimezone) != null ? _ref2 : "default";
      const valueWithTimezoneToRender = reactExports.useMemo(() => valueManager.setTimezone(utils2, timezoneToRender, inputValue), [valueManager, utils2, timezoneToRender, inputValue]);
      const handleValueChange = useEventCallback((newValue, ...otherParams) => {
        const newValueWithInputTimezone = setInputTimezone(newValue);
        onChange == null ? void 0 : onChange(newValueWithInputTimezone, ...otherParams);
      });
      return {
        value: valueWithTimezoneToRender,
        handleValueChange,
        timezone: timezoneToRender
      };
    };
    const useControlledValueWithTimezone = ({
      name,
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange: onChangeProp,
      valueManager
    }) => {
      const [valueWithInputTimezone, setValue] = useControlled({
        name,
        state: "value",
        controlled: valueProp,
        default: defaultValue != null ? defaultValue : valueManager.emptyValue
      });
      const onChange = useEventCallback((newValue, ...otherParams) => {
        setValue(newValue);
        onChangeProp == null ? void 0 : onChangeProp(newValue, ...otherParams);
      });
      return useValueWithTimezone({
        timezone: timezoneProp,
        value: valueWithInputTimezone,
        defaultValue: void 0,
        onChange,
        valueManager
      });
    };
    const findClosestEnabledDate = ({
      date,
      disableFuture,
      disablePast,
      maxDate,
      minDate,
      isDateDisabled,
      utils: utils2,
      timezone
    }) => {
      const today = utils2.startOfDay(utils2.dateWithTimezone(void 0, timezone));
      if (disablePast && utils2.isBefore(minDate, today)) {
        minDate = today;
      }
      if (disableFuture && utils2.isAfter(maxDate, today)) {
        maxDate = today;
      }
      let forward = date;
      let backward = date;
      if (utils2.isBefore(date, minDate)) {
        forward = minDate;
        backward = null;
      }
      if (utils2.isAfter(date, maxDate)) {
        if (backward) {
          backward = maxDate;
        }
        forward = null;
      }
      while (forward || backward) {
        if (forward && utils2.isAfter(forward, maxDate)) {
          forward = null;
        }
        if (backward && utils2.isBefore(backward, minDate)) {
          backward = null;
        }
        if (forward) {
          if (!isDateDisabled(forward)) {
            return forward;
          }
          forward = utils2.addDays(forward, 1);
        }
        if (backward) {
          if (!isDateDisabled(backward)) {
            return backward;
          }
          backward = utils2.addDays(backward, -1);
        }
      }
      return null;
    };
    const replaceInvalidDateByNull = (utils2, value) => value == null || !utils2.isValid(value) ? null : value;
    const applyDefaultDate = (utils2, value, defaultValue) => {
      if (value == null || !utils2.isValid(value)) {
        return defaultValue;
      }
      return value;
    };
    const areDatesEqual = (utils2, a2, b2) => {
      if (!utils2.isValid(a2) && a2 != null && !utils2.isValid(b2) && b2 != null) {
        return true;
      }
      return utils2.isEqual(a2, b2);
    };
    const getMonthsInYear = (utils2, year) => {
      const firstMonth = utils2.startOfYear(year);
      const months = [firstMonth];
      while (months.length < 12) {
        const prevMonth = months[months.length - 1];
        months.push(utils2.addMonths(prevMonth, 1));
      }
      return months;
    };
    const mergeDateAndTime = (utils2, dateParam, timeParam) => {
      let mergedDate = dateParam;
      mergedDate = utils2.setHours(mergedDate, utils2.getHours(timeParam));
      mergedDate = utils2.setMinutes(mergedDate, utils2.getMinutes(timeParam));
      mergedDate = utils2.setSeconds(mergedDate, utils2.getSeconds(timeParam));
      return mergedDate;
    };
    const getTodayDate = (utils2, timezone, valueType) => valueType === "date" ? utils2.startOfDay(utils2.dateWithTimezone(void 0, timezone)) : utils2.dateWithTimezone(void 0, timezone);
    const dateViews = ["year", "month", "day"];
    const isDatePickerView = (view) => dateViews.includes(view);
    const resolveDateFormat = (utils2, {
      format,
      views
    }, isInToolbar) => {
      if (format != null) {
        return format;
      }
      const formats = utils2.formats;
      if (areViewsEqual(views, ["year"])) {
        return formats.year;
      }
      if (areViewsEqual(views, ["month"])) {
        return formats.month;
      }
      if (areViewsEqual(views, ["day"])) {
        return formats.dayOfMonth;
      }
      if (areViewsEqual(views, ["month", "year"])) {
        return `${formats.month} ${formats.year}`;
      }
      if (areViewsEqual(views, ["day", "month"])) {
        return `${formats.month} ${formats.dayOfMonth}`;
      }
      if (isInToolbar) {
        return /en/.test(utils2.getCurrentLocaleCode()) ? formats.normalDateWithWeekday : formats.normalDate;
      }
      return formats.keyboardDate;
    };
    const SECTION_TYPE_GRANULARITY = {
      year: 1,
      month: 2,
      day: 3,
      hours: 4,
      minutes: 5,
      seconds: 6,
      milliseconds: 7
    };
    const roundDate = (utils2, granularity, date) => {
      if (granularity === SECTION_TYPE_GRANULARITY.year) {
        return utils2.startOfYear(date);
      }
      if (granularity === SECTION_TYPE_GRANULARITY.month) {
        return utils2.startOfMonth(date);
      }
      if (granularity === SECTION_TYPE_GRANULARITY.day) {
        return utils2.startOfDay(date);
      }
      let roundedDate = date;
      if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
        roundedDate = utils2.setMinutes(roundedDate, 0);
      }
      if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
        roundedDate = utils2.setSeconds(roundedDate, 0);
      }
      if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
        roundedDate = utils2.setMilliseconds(roundedDate, 0);
      }
      return roundedDate;
    };
    const getDefaultReferenceDate = ({
      props,
      utils: utils2,
      granularity,
      timezone,
      getTodayDate: inGetTodayDate
    }) => {
      var _props$disableIgnorin;
      let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils2, granularity, getTodayDate(utils2, timezone));
      if (props.minDate != null && utils2.isAfterDay(props.minDate, referenceDate)) {
        referenceDate = roundDate(utils2, granularity, props.minDate);
      }
      if (props.maxDate != null && utils2.isBeforeDay(props.maxDate, referenceDate)) {
        referenceDate = roundDate(utils2, granularity, props.maxDate);
      }
      const isAfter = createIsAfterIgnoreDatePart((_props$disableIgnorin = props.disableIgnoringDatePartForTimeValidation) != null ? _props$disableIgnorin : false, utils2);
      if (props.minTime != null && isAfter(props.minTime, referenceDate)) {
        referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils2, referenceDate, props.minTime));
      }
      if (props.maxTime != null && isAfter(referenceDate, props.maxTime)) {
        referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils2, referenceDate, props.maxTime));
      }
      return referenceDate;
    };
    const _excluded$f = ["value", "referenceDate"];
    const singleItemValueManager = {
      emptyValue: null,
      getTodayValue: getTodayDate,
      getInitialReferenceValue: (_ref) => {
        let {
          value,
          referenceDate
        } = _ref, params = _objectWithoutPropertiesLoose$1(_ref, _excluded$f);
        if (value != null && params.utils.isValid(value)) {
          return value;
        }
        if (referenceDate != null) {
          return referenceDate;
        }
        return getDefaultReferenceDate(params);
      },
      cleanValue: replaceInvalidDateByNull,
      areValuesEqual: areDatesEqual,
      isSameError: (a2, b2) => a2 === b2,
      hasError: (error) => error != null,
      defaultErrorState: null,
      getTimezone: (utils2, value) => value == null || !utils2.isValid(value) ? null : utils2.getTimezone(value),
      setTimezone: (utils2, timezone, value) => value == null ? null : utils2.setTimezone(value, timezone)
    };
    const uncapitalizeObjectKeys = (capitalizedObject) => {
      if (capitalizedObject === void 0) {
        return void 0;
      }
      return Object.keys(capitalizedObject).reduce((acc, key) => _extends$1({}, acc, {
        [`${key.slice(0, 1).toLowerCase()}${key.slice(1)}`]: capitalizedObject[key]
      }), {});
    };
    function getPickersDayUtilityClass(slot) {
      return generateUtilityClass("MuiPickersDay", slot);
    }
    const pickersDayClasses = generateUtilityClasses("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]);
    const _excluded$e = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"];
    const useUtilityClasses$d = (ownerState) => {
      const {
        selected,
        disableMargin,
        disableHighlightToday,
        today,
        disabled,
        outsideCurrentMonth,
        showDaysOutsideCurrentMonth,
        classes
      } = ownerState;
      const isHiddenDaySpacingFiller = outsideCurrentMonth && !showDaysOutsideCurrentMonth;
      const slots = {
        root: ["root", selected && !isHiddenDaySpacingFiller && "selected", disabled && "disabled", !disableMargin && "dayWithMargin", !disableHighlightToday && today && "today", outsideCurrentMonth && showDaysOutsideCurrentMonth && "dayOutsideMonth", isHiddenDaySpacingFiller && "hiddenDaySpacingFiller"],
        hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
      };
      return composeClasses(slots, getPickersDayUtilityClass, classes);
    };
    const styleArg = ({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.caption, {
      width: DAY_SIZE,
      height: DAY_SIZE,
      borderRadius: "50%",
      padding: 0,
      // explicitly setting to `transparent` to avoid potentially getting impacted by change from the overridden component
      backgroundColor: "transparent",
      color: (theme.vars || theme).palette.text.primary,
      "@media (pointer: fine)": {
        "&:hover": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
        }
      },
      "&:focus": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity),
        [`&.${pickersDayClasses.selected}`]: {
          willChange: "background-color",
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      },
      [`&.${pickersDayClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        fontWeight: theme.typography.fontWeightMedium,
        transition: theme.transitions.create("background-color", {
          duration: theme.transitions.duration.short
        }),
        "&:hover": {
          willChange: "background-color",
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      },
      [`&.${pickersDayClasses.disabled}:not(.${pickersDayClasses.selected})`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${pickersDayClasses.disabled}&.${pickersDayClasses.selected}`]: {
        opacity: 0.6
      }
    }, !ownerState.disableMargin && {
      margin: `0 ${DAY_MARGIN}px`
    }, ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && {
      color: (theme.vars || theme).palette.text.secondary
    }, !ownerState.disableHighlightToday && ownerState.today && {
      [`&:not(.${pickersDayClasses.selected})`]: {
        border: `1px solid ${(theme.vars || theme).palette.text.secondary}`
      }
    });
    const overridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.disableMargin && styles2.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles2.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles2.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles2.hiddenDaySpacingFiller];
    };
    const PickersDayRoot = styled$1(ButtonBase$1, {
      name: "MuiPickersDay",
      slot: "Root",
      overridesResolver
    })(styleArg);
    const PickersDayFiller = styled$1("div", {
      name: "MuiPickersDay",
      slot: "Root",
      overridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({}, styleArg({
      theme,
      ownerState
    }), {
      // visibility: 'hidden' does not work here as it hides the element from screen readers as well
      opacity: 0,
      pointerEvents: "none"
    }));
    const noop = () => {
    };
    const PickersDayRaw = /* @__PURE__ */ reactExports.forwardRef(function PickersDay2(inProps, forwardedRef) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersDay"
      });
      const {
        autoFocus = false,
        className,
        day,
        disabled = false,
        disableHighlightToday = false,
        disableMargin = false,
        isAnimating,
        onClick,
        onDaySelect,
        onFocus = noop,
        onBlur = noop,
        onKeyDown = noop,
        onMouseDown = noop,
        onMouseEnter = noop,
        outsideCurrentMonth,
        selected = false,
        showDaysOutsideCurrentMonth = false,
        children,
        today: isToday = false
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$e);
      const ownerState = _extends$1({}, props, {
        autoFocus,
        disabled,
        disableHighlightToday,
        disableMargin,
        selected,
        showDaysOutsideCurrentMonth,
        today: isToday
      });
      const classes = useUtilityClasses$d(ownerState);
      const utils2 = useUtils();
      const ref = reactExports.useRef(null);
      const handleRef = useForkRef(ref, forwardedRef);
      useEnhancedEffect$1(() => {
        if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
          ref.current.focus();
        }
      }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
      const handleMouseDown = (event) => {
        onMouseDown(event);
        if (outsideCurrentMonth) {
          event.preventDefault();
        }
      };
      const handleClick = (event) => {
        if (!disabled) {
          onDaySelect(day);
        }
        if (outsideCurrentMonth) {
          event.currentTarget.focus();
        }
        if (onClick) {
          onClick(event);
        }
      };
      if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayFiller, {
          className: clsx(classes.root, classes.hiddenDaySpacingFiller, className),
          ownerState,
          role: other.role
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayRoot, _extends$1({
        className: clsx(classes.root, className),
        ref: handleRef,
        centerRipple: true,
        disabled,
        tabIndex: selected ? 0 : -1,
        onKeyDown: (event) => onKeyDown(event, day),
        onFocus: (event) => onFocus(event, day),
        onBlur: (event) => onBlur(event, day),
        onMouseEnter: (event) => onMouseEnter(event, day),
        onClick: handleClick,
        onMouseDown: handleMouseDown
      }, other, {
        ownerState,
        children: !children ? utils2.format(day, "dayOfMonth") : children
      }));
    });
    const PickersDay = /* @__PURE__ */ reactExports.memo(PickersDayRaw);
    function useValidation(props, validate, isSameError, defaultErrorState) {
      const {
        value,
        onError
      } = props;
      const adapter = useLocalizationContext();
      const previousValidationErrorRef = reactExports.useRef(defaultErrorState);
      const validationError = validate({
        adapter,
        value,
        props
      });
      reactExports.useEffect(() => {
        if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
          onError(validationError, value);
        }
        previousValidationErrorRef.current = validationError;
      }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
      return validationError;
    }
    function arrayIncludes$1(array, itemOrItems) {
      if (Array.isArray(itemOrItems)) {
        return itemOrItems.every((item) => array.indexOf(item) !== -1);
      }
      return array.indexOf(itemOrItems) !== -1;
    }
    const validateDate = ({
      props,
      value,
      adapter
    }) => {
      if (value === null) {
        return null;
      }
      const {
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        disablePast,
        disableFuture,
        timezone
      } = props;
      const now = adapter.utils.dateWithTimezone(void 0, timezone);
      const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
      const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
      switch (true) {
        case !adapter.utils.isValid(value):
          return "invalidDate";
        case Boolean(shouldDisableDate && shouldDisableDate(value)):
          return "shouldDisableDate";
        case Boolean(shouldDisableMonth && shouldDisableMonth(value)):
          return "shouldDisableMonth";
        case Boolean(shouldDisableYear && shouldDisableYear(value)):
          return "shouldDisableYear";
        case Boolean(disableFuture && adapter.utils.isAfterDay(value, now)):
          return "disableFuture";
        case Boolean(disablePast && adapter.utils.isBeforeDay(value, now)):
          return "disablePast";
        case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
          return "minDate";
        case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
          return "maxDate";
        default:
          return null;
      }
    };
    const useIsDateDisabled = ({
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      minDate,
      maxDate,
      disableFuture,
      disablePast,
      timezone
    }) => {
      const adapter = useLocalizationContext();
      return reactExports.useCallback((day) => validateDate({
        adapter,
        value: day,
        props: {
          shouldDisableDate,
          shouldDisableMonth,
          shouldDisableYear,
          minDate,
          maxDate,
          disableFuture,
          disablePast,
          timezone
        }
      }) !== null, [adapter, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, timezone]);
    };
    const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils2) => (state, action) => {
      switch (action.type) {
        case "changeMonth":
          return _extends$1({}, state, {
            slideDirection: action.direction,
            currentMonth: action.newMonth,
            isMonthSwitchingAnimating: !reduceAnimations
          });
        case "finishMonthSwitchingAnimation":
          return _extends$1({}, state, {
            isMonthSwitchingAnimating: false
          });
        case "changeFocusedDay": {
          if (state.focusedDay != null && action.focusedDay != null && utils2.isSameDay(action.focusedDay, state.focusedDay)) {
            return state;
          }
          const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils2.isSameMonth(state.currentMonth, action.focusedDay);
          return _extends$1({}, state, {
            focusedDay: action.focusedDay,
            isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
            currentMonth: needMonthSwitch ? utils2.startOfMonth(action.focusedDay) : state.currentMonth,
            slideDirection: action.focusedDay != null && utils2.isAfterDay(action.focusedDay, state.currentMonth) ? "left" : "right"
          });
        }
        default:
          throw new Error("missing support");
      }
    };
    const useCalendarState = (params) => {
      const {
        value,
        referenceDate: referenceDateProp,
        defaultCalendarMonth,
        disableFuture,
        disablePast,
        disableSwitchToMonthOnDayFocus = false,
        maxDate,
        minDate,
        onMonthChange,
        reduceAnimations,
        shouldDisableDate,
        timezone
      } = params;
      const now = useNow(timezone);
      const utils2 = useUtils();
      const reducerFn = reactExports.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils2)).current;
      const referenceDate = reactExports.useMemo(
        () => {
          let externalReferenceDate = null;
          if (referenceDateProp) {
            externalReferenceDate = referenceDateProp;
          } else if (defaultCalendarMonth) {
            externalReferenceDate = utils2.startOfMonth(defaultCalendarMonth);
          }
          return singleItemValueManager.getInitialReferenceValue({
            value,
            utils: utils2,
            timezone,
            props: params,
            referenceDate: externalReferenceDate,
            granularity: SECTION_TYPE_GRANULARITY.day
          });
        },
        []
        // eslint-disable-line react-hooks/exhaustive-deps
      );
      const [calendarState, dispatch] = reactExports.useReducer(reducerFn, {
        isMonthSwitchingAnimating: false,
        focusedDay: value || now,
        currentMonth: utils2.startOfMonth(referenceDate),
        slideDirection: "left"
      });
      const handleChangeMonth = reactExports.useCallback((payload) => {
        dispatch(_extends$1({
          type: "changeMonth"
        }, payload));
        if (onMonthChange) {
          onMonthChange(payload.newMonth);
        }
      }, [onMonthChange]);
      const changeMonth = reactExports.useCallback((newDate) => {
        const newDateRequested = newDate;
        if (utils2.isSameMonth(newDateRequested, calendarState.currentMonth)) {
          return;
        }
        handleChangeMonth({
          newMonth: utils2.startOfMonth(newDateRequested),
          direction: utils2.isAfterDay(newDateRequested, calendarState.currentMonth) ? "left" : "right"
        });
      }, [calendarState.currentMonth, handleChangeMonth, utils2]);
      const isDateDisabled = useIsDateDisabled({
        shouldDisableDate,
        minDate,
        maxDate,
        disableFuture,
        disablePast,
        timezone
      });
      const onMonthSwitchingAnimationEnd = reactExports.useCallback(() => {
        dispatch({
          type: "finishMonthSwitchingAnimation"
        });
      }, []);
      const changeFocusedDay = useEventCallback((newFocusedDate, withoutMonthSwitchingAnimation) => {
        if (!isDateDisabled(newFocusedDate)) {
          dispatch({
            type: "changeFocusedDay",
            focusedDay: newFocusedDate,
            withoutMonthSwitchingAnimation
          });
        }
      });
      return {
        referenceDate,
        calendarState,
        changeMonth,
        changeFocusedDay,
        isDateDisabled,
        onMonthSwitchingAnimationEnd,
        handleChangeMonth
      };
    };
    const getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass("MuiPickersFadeTransitionGroup", slot);
    generateUtilityClasses("MuiPickersFadeTransitionGroup", ["root"]);
    const useUtilityClasses$c = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
    };
    const animationDuration = 500;
    const PickersFadeTransitionGroupRoot = styled$1(TransitionGroup$1, {
      name: "MuiPickersFadeTransitionGroup",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })({
      display: "block",
      position: "relative"
    });
    function PickersFadeTransitionGroup(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersFadeTransitionGroup"
      });
      const {
        children,
        className,
        reduceAnimations,
        transKey
      } = props;
      const classes = useUtilityClasses$c(props);
      if (reduceAnimations) {
        return children;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroupRoot, {
        className: clsx(classes.root, className),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade$1, {
          appear: false,
          mountOnEnter: true,
          unmountOnExit: true,
          timeout: {
            appear: animationDuration,
            enter: animationDuration / 2,
            exit: 0
          },
          children
        }, transKey)
      });
    }
    const getPickersSlideTransitionUtilityClass = (slot) => generateUtilityClass("MuiPickersSlideTransition", slot);
    const pickersSlideTransitionClasses = generateUtilityClasses("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]);
    const _excluded$d = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"];
    const useUtilityClasses$b = (ownerState) => {
      const {
        classes,
        slideDirection
      } = ownerState;
      const slots = {
        root: ["root"],
        exit: ["slideExit"],
        enterActive: ["slideEnterActive"],
        enter: [`slideEnter-${slideDirection}`],
        exitActive: [`slideExitActiveLeft-${slideDirection}`]
      };
      return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
    };
    const slideAnimationDuration = 350;
    const PickersSlideTransitionRoot = styled$1(TransitionGroup$1, {
      name: "MuiPickersSlideTransition",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root, {
        [`.${pickersSlideTransitionClasses["slideEnter-left"]}`]: styles2["slideEnter-left"]
      }, {
        [`.${pickersSlideTransitionClasses["slideEnter-right"]}`]: styles2["slideEnter-right"]
      }, {
        [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles2.slideEnterActive
      }, {
        [`.${pickersSlideTransitionClasses.slideExit}`]: styles2.slideExit
      }, {
        [`.${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: styles2["slideExitActiveLeft-left"]
      }, {
        [`.${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: styles2["slideExitActiveLeft-right"]
      }]
    })(({
      theme
    }) => {
      const slideTransition = theme.transitions.create("transform", {
        duration: slideAnimationDuration,
        easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
      });
      return {
        display: "block",
        position: "relative",
        overflowX: "hidden",
        "& > *": {
          position: "absolute",
          top: 0,
          right: 0,
          left: 0
        },
        [`& .${pickersSlideTransitionClasses["slideEnter-left"]}`]: {
          willChange: "transform",
          transform: "translate(100%)",
          zIndex: 1
        },
        [`& .${pickersSlideTransitionClasses["slideEnter-right"]}`]: {
          willChange: "transform",
          transform: "translate(-100%)",
          zIndex: 1
        },
        [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
          transform: "translate(0%)",
          transition: slideTransition
        },
        [`& .${pickersSlideTransitionClasses.slideExit}`]: {
          transform: "translate(0%)"
        },
        [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: {
          willChange: "transform",
          transform: "translate(-100%)",
          transition: slideTransition,
          zIndex: 0
        },
        [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: {
          willChange: "transform",
          transform: "translate(100%)",
          transition: slideTransition,
          zIndex: 0
        }
      };
    });
    function PickersSlideTransition(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersSlideTransition"
      });
      const {
        children,
        className,
        reduceAnimations,
        transKey
        // extracting `classes` from `other`
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$d);
      const classes = useUtilityClasses$b(props);
      if (reduceAnimations) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: clsx(classes.root, className),
          children
        });
      }
      const transitionClasses = {
        exit: classes.exit,
        enterActive: classes.enterActive,
        enter: classes.enter,
        exitActive: classes.exitActive
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSlideTransitionRoot, {
        className: clsx(classes.root, className),
        childFactory: (element) => /* @__PURE__ */ reactExports.cloneElement(element, {
          classNames: transitionClasses
        }),
        role: "presentation",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransition$1, _extends$1({
          mountOnEnter: true,
          unmountOnExit: true,
          timeout: slideAnimationDuration,
          classNames: transitionClasses
        }, other, {
          children
        }), transKey)
      });
    }
    const getDayCalendarUtilityClass = (slot) => generateUtilityClass("MuiDayCalendar", slot);
    generateUtilityClasses("MuiDayCalendar", ["header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
    const _excluded$c = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"], _excluded2$1 = ["ownerState"];
    const useUtilityClasses$a = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        header: ["header"],
        weekDayLabel: ["weekDayLabel"],
        loadingContainer: ["loadingContainer"],
        slideTransition: ["slideTransition"],
        monthContainer: ["monthContainer"],
        weekContainer: ["weekContainer"],
        weekNumberLabel: ["weekNumberLabel"],
        weekNumber: ["weekNumber"]
      };
      return composeClasses(slots, getDayCalendarUtilityClass, classes);
    };
    const defaultDayOfWeekFormatter = (day) => day.charAt(0).toUpperCase();
    const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
    const PickersCalendarDayHeader = styled$1("div", {
      name: "MuiDayCalendar",
      slot: "Header",
      overridesResolver: (_2, styles2) => styles2.header
    })({
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    });
    const PickersCalendarWeekDayLabel = styled$1(Typography$1, {
      name: "MuiDayCalendar",
      slot: "WeekDayLabel",
      overridesResolver: (_2, styles2) => styles2.weekDayLabel
    })(({
      theme
    }) => ({
      width: 36,
      height: 40,
      margin: "0 2px",
      textAlign: "center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      color: (theme.vars || theme).palette.text.secondary
    }));
    const PickersCalendarWeekNumberLabel = styled$1(Typography$1, {
      name: "MuiDayPicker",
      slot: "WeekNumberLabel",
      overridesResolver: (_2, styles2) => styles2.weekNumberLabel
    })(({
      theme
    }) => ({
      width: 36,
      height: 40,
      margin: "0 2px",
      textAlign: "center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      color: theme.palette.text.disabled
    }));
    const PickersCalendarWeekNumber = styled$1(Typography$1, {
      name: "MuiDayPicker",
      slot: "WeekNumber",
      overridesResolver: (_2, styles2) => styles2.weekNumber
    })(({
      theme
    }) => _extends$1({}, theme.typography.caption, {
      width: DAY_SIZE,
      height: DAY_SIZE,
      padding: 0,
      margin: `0 ${DAY_MARGIN}px`,
      color: theme.palette.text.disabled,
      fontSize: "0.75rem",
      alignItems: "center",
      justifyContent: "center",
      display: "inline-flex"
    }));
    const PickersCalendarLoadingContainer = styled$1("div", {
      name: "MuiDayCalendar",
      slot: "LoadingContainer",
      overridesResolver: (_2, styles2) => styles2.loadingContainer
    })({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      minHeight: weeksContainerHeight
    });
    const PickersCalendarSlideTransition = styled$1(PickersSlideTransition, {
      name: "MuiDayCalendar",
      slot: "SlideTransition",
      overridesResolver: (_2, styles2) => styles2.slideTransition
    })({
      minHeight: weeksContainerHeight
    });
    const PickersCalendarWeekContainer = styled$1("div", {
      name: "MuiDayCalendar",
      slot: "MonthContainer",
      overridesResolver: (_2, styles2) => styles2.monthContainer
    })({
      overflow: "hidden"
    });
    const PickersCalendarWeek = styled$1("div", {
      name: "MuiDayCalendar",
      slot: "WeekContainer",
      overridesResolver: (_2, styles2) => styles2.weekContainer
    })({
      margin: `${DAY_MARGIN}px 0`,
      display: "flex",
      justifyContent: "center"
    });
    function WrappedDay(_ref) {
      var _ref2, _slots$day, _slotProps$day;
      let {
        parentProps,
        day,
        focusableDay,
        selectedDays,
        isDateDisabled,
        currentMonthNumber,
        isViewFocused
      } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$c);
      const {
        disabled,
        disableHighlightToday,
        isMonthSwitchingAnimating,
        showDaysOutsideCurrentMonth,
        components,
        componentsProps,
        slots,
        slotProps,
        timezone
      } = parentProps;
      const utils2 = useUtils();
      const now = useNow(timezone);
      const isFocusableDay = focusableDay !== null && utils2.isSameDay(day, focusableDay);
      const isSelected = selectedDays.some((selectedDay) => utils2.isSameDay(selectedDay, day));
      const isToday = utils2.isSameDay(day, now);
      const Day = (_ref2 = (_slots$day = slots == null ? void 0 : slots.day) != null ? _slots$day : components == null ? void 0 : components.Day) != null ? _ref2 : PickersDay;
      const _useSlotProps = useSlotProps({
        elementType: Day,
        externalSlotProps: (_slotProps$day = slotProps == null ? void 0 : slotProps.day) != null ? _slotProps$day : componentsProps == null ? void 0 : componentsProps.day,
        additionalProps: _extends$1({
          disableHighlightToday,
          showDaysOutsideCurrentMonth,
          role: "gridcell",
          isAnimating: isMonthSwitchingAnimating,
          // it is used in date range dragging logic by accessing `dataset.timestamp`
          "data-timestamp": utils2.toJsDate(day).valueOf()
        }, other),
        ownerState: _extends$1({}, parentProps, {
          day,
          selected: isSelected
        })
      }), dayProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$1);
      const isDisabled = reactExports.useMemo(() => disabled || isDateDisabled(day), [disabled, isDateDisabled, day]);
      const outsideCurrentMonth = reactExports.useMemo(() => utils2.getMonth(day) !== currentMonthNumber, [utils2, day, currentMonthNumber]);
      const isFirstVisibleCell = reactExports.useMemo(() => {
        const startOfMonth = utils2.startOfMonth(utils2.setMonth(day, currentMonthNumber));
        if (!showDaysOutsideCurrentMonth) {
          return utils2.isSameDay(day, startOfMonth);
        }
        return utils2.isSameDay(day, utils2.startOfWeek(startOfMonth));
      }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
      const isLastVisibleCell = reactExports.useMemo(() => {
        const endOfMonth = utils2.endOfMonth(utils2.setMonth(day, currentMonthNumber));
        if (!showDaysOutsideCurrentMonth) {
          return utils2.isSameDay(day, endOfMonth);
        }
        return utils2.isSameDay(day, utils2.endOfWeek(endOfMonth));
      }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Day, _extends$1({}, dayProps, {
        day,
        disabled: isDisabled,
        autoFocus: isViewFocused && isFocusableDay,
        today: isToday,
        outsideCurrentMonth,
        isFirstVisibleCell,
        isLastVisibleCell,
        selected: isSelected,
        tabIndex: isFocusableDay ? 0 : -1,
        "aria-selected": isSelected,
        "aria-current": isToday ? "date" : void 0
      }));
    }
    function DayCalendar(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDayCalendar"
      });
      const {
        onFocusedDayChange,
        className,
        currentMonth,
        selectedDays,
        focusedDay,
        loading,
        onSelectedDaysChange,
        onMonthSwitchingAnimationEnd,
        readOnly,
        reduceAnimations,
        renderLoading = () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          children: "..."
        }),
        slideDirection,
        TransitionProps,
        disablePast,
        disableFuture,
        minDate,
        maxDate,
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        dayOfWeekFormatter = defaultDayOfWeekFormatter,
        hasFocus,
        onFocusedViewChange,
        gridLabelId,
        displayWeekNumber,
        fixedWeekNumber,
        autoFocus,
        timezone
      } = props;
      const now = useNow(timezone);
      const utils2 = useUtils();
      const classes = useUtilityClasses$a(props);
      const theme = useTheme();
      const isRTL = theme.direction === "rtl";
      const isDateDisabled = useIsDateDisabled({
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        minDate,
        maxDate,
        disablePast,
        disableFuture,
        timezone
      });
      const localeText = useLocaleText();
      const [internalHasFocus, setInternalHasFocus] = useControlled({
        name: "DayCalendar",
        state: "hasFocus",
        controlled: hasFocus,
        default: autoFocus != null ? autoFocus : false
      });
      const [internalFocusedDay, setInternalFocusedDay] = reactExports.useState(() => focusedDay || now);
      const handleDaySelect = useEventCallback((day) => {
        if (readOnly) {
          return;
        }
        onSelectedDaysChange(day);
      });
      const focusDay = (day) => {
        if (!isDateDisabled(day)) {
          onFocusedDayChange(day);
          setInternalFocusedDay(day);
          onFocusedViewChange == null ? void 0 : onFocusedViewChange(true);
          setInternalHasFocus(true);
        }
      };
      const handleKeyDown2 = useEventCallback((event, day) => {
        switch (event.key) {
          case "ArrowUp":
            focusDay(utils2.addDays(day, -7));
            event.preventDefault();
            break;
          case "ArrowDown":
            focusDay(utils2.addDays(day, 7));
            event.preventDefault();
            break;
          case "ArrowLeft": {
            const newFocusedDayDefault = utils2.addDays(day, isRTL ? 1 : -1);
            const nextAvailableMonth = utils2.addMonths(day, isRTL ? 1 : -1);
            const closestDayToFocus = findClosestEnabledDate({
              utils: utils2,
              date: newFocusedDayDefault,
              minDate: isRTL ? newFocusedDayDefault : utils2.startOfMonth(nextAvailableMonth),
              maxDate: isRTL ? utils2.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
              isDateDisabled,
              timezone
            });
            focusDay(closestDayToFocus || newFocusedDayDefault);
            event.preventDefault();
            break;
          }
          case "ArrowRight": {
            const newFocusedDayDefault = utils2.addDays(day, isRTL ? -1 : 1);
            const nextAvailableMonth = utils2.addMonths(day, isRTL ? -1 : 1);
            const closestDayToFocus = findClosestEnabledDate({
              utils: utils2,
              date: newFocusedDayDefault,
              minDate: isRTL ? utils2.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
              maxDate: isRTL ? newFocusedDayDefault : utils2.endOfMonth(nextAvailableMonth),
              isDateDisabled,
              timezone
            });
            focusDay(closestDayToFocus || newFocusedDayDefault);
            event.preventDefault();
            break;
          }
          case "Home":
            focusDay(utils2.startOfWeek(day));
            event.preventDefault();
            break;
          case "End":
            focusDay(utils2.endOfWeek(day));
            event.preventDefault();
            break;
          case "PageUp":
            focusDay(utils2.addMonths(day, 1));
            event.preventDefault();
            break;
          case "PageDown":
            focusDay(utils2.addMonths(day, -1));
            event.preventDefault();
            break;
        }
      });
      const handleFocus = useEventCallback((event, day) => focusDay(day));
      const handleBlur = useEventCallback((event, day) => {
        if (internalHasFocus && utils2.isSameDay(internalFocusedDay, day)) {
          onFocusedViewChange == null ? void 0 : onFocusedViewChange(false);
        }
      });
      const currentMonthNumber = utils2.getMonth(currentMonth);
      const validSelectedDays = reactExports.useMemo(() => selectedDays.filter((day) => !!day).map((day) => utils2.startOfDay(day)), [utils2, selectedDays]);
      const transitionKey = currentMonthNumber;
      const slideNodeRef = reactExports.useMemo(() => /* @__PURE__ */ reactExports.createRef(), [transitionKey]);
      const startOfCurrentWeek = utils2.startOfWeek(now);
      const focusableDay = reactExports.useMemo(() => {
        const startOfMonth = utils2.startOfMonth(currentMonth);
        const endOfMonth = utils2.endOfMonth(currentMonth);
        if (isDateDisabled(internalFocusedDay) || utils2.isAfterDay(internalFocusedDay, endOfMonth) || utils2.isBeforeDay(internalFocusedDay, startOfMonth)) {
          return findClosestEnabledDate({
            utils: utils2,
            date: internalFocusedDay,
            minDate: startOfMonth,
            maxDate: endOfMonth,
            disablePast,
            disableFuture,
            isDateDisabled,
            timezone
          });
        }
        return internalFocusedDay;
      }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils2, timezone]);
      const weeksToDisplay = reactExports.useMemo(() => {
        const currentMonthWithTimezone = utils2.setTimezone(currentMonth, timezone);
        const toDisplay = utils2.getWeekArray(currentMonthWithTimezone);
        let nextMonth = utils2.addMonths(currentMonthWithTimezone, 1);
        while (fixedWeekNumber && toDisplay.length < fixedWeekNumber) {
          const additionalWeeks = utils2.getWeekArray(nextMonth);
          const hasCommonWeek = utils2.isSameDay(toDisplay[toDisplay.length - 1][0], additionalWeeks[0][0]);
          additionalWeeks.slice(hasCommonWeek ? 1 : 0).forEach((week) => {
            if (toDisplay.length < fixedWeekNumber) {
              toDisplay.push(week);
            }
          });
          nextMonth = utils2.addMonths(nextMonth, 1);
        }
        return toDisplay;
      }, [currentMonth, fixedWeekNumber, utils2, timezone]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        role: "grid",
        "aria-labelledby": gridLabelId,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarDayHeader, {
          role: "row",
          className: classes.header,
          children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumberLabel, {
            variant: "caption",
            role: "columnheader",
            "aria-label": localeText.calendarWeekNumberHeaderLabel,
            className: classes.weekNumberLabel,
            children: localeText.calendarWeekNumberHeaderText
          }), utils2.getWeekdays().map((day, i2) => {
            var _dayOfWeekFormatter;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekDayLabel, {
              variant: "caption",
              role: "columnheader",
              "aria-label": utils2.format(utils2.addDays(startOfCurrentWeek, i2), "weekday"),
              className: classes.weekDayLabel,
              children: (_dayOfWeekFormatter = dayOfWeekFormatter == null ? void 0 : dayOfWeekFormatter(day)) != null ? _dayOfWeekFormatter : day
            }, day + i2.toString());
          })]
        }), loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarLoadingContainer, {
          className: classes.loadingContainer,
          children: renderLoading()
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarSlideTransition, _extends$1({
          transKey: transitionKey,
          onExited: onMonthSwitchingAnimationEnd,
          reduceAnimations,
          slideDirection,
          className: clsx(className, classes.slideTransition)
        }, TransitionProps, {
          nodeRef: slideNodeRef,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekContainer, {
            ref: slideNodeRef,
            role: "rowgroup",
            className: classes.monthContainer,
            children: weeksToDisplay.map((week, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarWeek, {
              role: "row",
              className: classes.weekContainer,
              "aria-rowindex": index2 + 1,
              children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumber, {
                className: classes.weekNumber,
                role: "rowheader",
                "aria-label": localeText.calendarWeekNumberAriaLabelText(utils2.getWeekNumber(week[0])),
                children: localeText.calendarWeekNumberText(utils2.getWeekNumber(week[0]))
              }), week.map((day, dayIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedDay, {
                parentProps: props,
                day,
                selectedDays: validSelectedDays,
                focusableDay,
                onKeyDown: handleKeyDown2,
                onFocus: handleFocus,
                onBlur: handleBlur,
                onDaySelect: handleDaySelect,
                isDateDisabled,
                currentMonthNumber,
                isViewFocused: internalHasFocus,
                "aria-colindex": dayIndex + 1
              }, day.toString()))]
            }, `week-${week[0]}`))
          })
        }))]
      });
    }
    function getPickersMonthUtilityClass(slot) {
      return generateUtilityClass("MuiPickersMonth", slot);
    }
    const pickersMonthClasses = generateUtilityClasses("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"]);
    const _excluded$b = ["autoFocus", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "monthsPerRow"];
    const useUtilityClasses$9 = (ownerState) => {
      const {
        disabled,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        monthButton: ["monthButton", disabled && "disabled", selected && "selected"]
      };
      return composeClasses(slots, getPickersMonthUtilityClass, classes);
    };
    const PickersMonthRoot = styled$1("div", {
      name: "MuiPickersMonth",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root]
    })(({
      ownerState
    }) => ({
      flexBasis: ownerState.monthsPerRow === 3 ? "33.3%" : "25%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }));
    const PickersMonthButton = styled$1("button", {
      name: "MuiPickersMonth",
      slot: "MonthButton",
      overridesResolver: (_2, styles2) => [styles2.monthButton, {
        [`&.${pickersMonthClasses.disabled}`]: styles2.disabled
      }, {
        [`&.${pickersMonthClasses.selected}`]: styles2.selected
      }]
    })(({
      theme
    }) => _extends$1({
      color: "unset",
      backgroundColor: "transparent",
      border: 0,
      outline: 0
    }, theme.typography.subtitle1, {
      margin: "8px 0",
      height: 36,
      width: 72,
      borderRadius: 18,
      cursor: "pointer",
      "&:focus": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:disabled": {
        cursor: "auto",
        pointerEvents: "none"
      },
      [`&.${pickersMonthClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.secondary
      },
      [`&.${pickersMonthClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        "&:focus, &:hover": {
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      }
    }));
    const PickersMonth = /* @__PURE__ */ reactExports.memo(function PickersMonth2(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersMonth"
      });
      const {
        autoFocus,
        children,
        disabled,
        value,
        tabIndex,
        onClick,
        onKeyDown,
        onFocus,
        onBlur,
        "aria-current": ariaCurrent
        // We don't want to forward this prop to the root element
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$b);
      const ref = reactExports.useRef(null);
      const classes = useUtilityClasses$9(props);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          var _ref$current;
          (_ref$current = ref.current) == null ? void 0 : _ref$current.focus();
        }
      }, [autoFocus]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonthRoot, _extends$1({
        className: classes.root,
        ownerState: props
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonthButton, {
          ref,
          disabled,
          type: "button",
          tabIndex: disabled ? -1 : tabIndex,
          "aria-current": ariaCurrent,
          onClick: (event) => onClick(event, value),
          onKeyDown: (event) => onKeyDown(event, value),
          onFocus: (event) => onFocus(event, value),
          onBlur: (event) => onBlur(event, value),
          className: classes.monthButton,
          ownerState: props,
          children
        })
      }));
    });
    function getMonthCalendarUtilityClass(slot) {
      return generateUtilityClass("MuiMonthCalendar", slot);
    }
    generateUtilityClasses("MuiMonthCalendar", ["root"]);
    const _excluded$a = ["className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow", "timezone"];
    const useUtilityClasses$8 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getMonthCalendarUtilityClass, classes);
    };
    function useMonthCalendarDefaultizedProps(props, name) {
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const themeProps = useThemeProps({
        props,
        name
      });
      return _extends$1({
        disableFuture: false,
        disablePast: false
      }, themeProps, {
        minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
      });
    }
    const MonthCalendarRoot = styled$1("div", {
      name: "MuiMonthCalendar",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "flex",
      flexWrap: "wrap",
      alignContent: "stretch",
      padding: "0 4px",
      width: 320
    });
    const MonthCalendar = /* @__PURE__ */ reactExports.forwardRef(function MonthCalendar2(inProps, ref) {
      const props = useMonthCalendarDefaultizedProps(inProps, "MuiMonthCalendar");
      const {
        className,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onChange,
        shouldDisableMonth,
        readOnly,
        disableHighlightToday,
        autoFocus = false,
        onMonthFocus,
        hasFocus,
        onFocusedViewChange,
        monthsPerRow = 3,
        timezone: timezoneProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$a);
      const {
        value,
        handleValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "MonthCalendar",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const now = useNow(timezone);
      const theme = useTheme$1();
      const utils2 = useUtils();
      const referenceDate = reactExports.useMemo(
        () => singleItemValueManager.getInitialReferenceValue({
          value,
          utils: utils2,
          props,
          timezone,
          referenceDate: referenceDateProp,
          granularity: SECTION_TYPE_GRANULARITY.month
        }),
        []
        // eslint-disable-line react-hooks/exhaustive-deps
      );
      const ownerState = props;
      const classes = useUtilityClasses$8(ownerState);
      const todayMonth = reactExports.useMemo(() => utils2.getMonth(now), [utils2, now]);
      const selectedMonth = reactExports.useMemo(() => {
        if (value != null) {
          return utils2.getMonth(value);
        }
        if (disableHighlightToday) {
          return null;
        }
        return utils2.getMonth(referenceDate);
      }, [value, utils2, disableHighlightToday, referenceDate]);
      const [focusedMonth, setFocusedMonth] = reactExports.useState(() => selectedMonth || todayMonth);
      const [internalHasFocus, setInternalHasFocus] = useControlled({
        name: "MonthCalendar",
        state: "hasFocus",
        controlled: hasFocus,
        default: autoFocus != null ? autoFocus : false
      });
      const changeHasFocus = useEventCallback((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
          onFocusedViewChange(newHasFocus);
        }
      });
      const isMonthDisabled = reactExports.useCallback((dateToValidate) => {
        const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now, minDate) ? now : minDate);
        const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now, maxDate) ? now : maxDate);
        const monthToValidate = utils2.startOfMonth(dateToValidate);
        if (utils2.isBefore(monthToValidate, firstEnabledMonth)) {
          return true;
        }
        if (utils2.isAfter(monthToValidate, lastEnabledMonth)) {
          return true;
        }
        if (!shouldDisableMonth) {
          return false;
        }
        return shouldDisableMonth(monthToValidate);
      }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableMonth, utils2]);
      const handleMonthSelection = useEventCallback((event, month) => {
        if (readOnly) {
          return;
        }
        const newDate = utils2.setMonth(value != null ? value : referenceDate, month);
        handleValueChange(newDate);
      });
      const focusMonth = useEventCallback((month) => {
        if (!isMonthDisabled(utils2.setMonth(value != null ? value : referenceDate, month))) {
          setFocusedMonth(month);
          changeHasFocus(true);
          if (onMonthFocus) {
            onMonthFocus(month);
          }
        }
      });
      reactExports.useEffect(() => {
        setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
      }, [selectedMonth]);
      const handleKeyDown2 = useEventCallback((event, month) => {
        const monthsInYear = 12;
        const monthsInRow = 3;
        switch (event.key) {
          case "ArrowUp":
            focusMonth((monthsInYear + month - monthsInRow) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowDown":
            focusMonth((monthsInYear + month + monthsInRow) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowLeft":
            focusMonth((monthsInYear + month + (theme.direction === "ltr" ? -1 : 1)) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowRight":
            focusMonth((monthsInYear + month + (theme.direction === "ltr" ? 1 : -1)) % monthsInYear);
            event.preventDefault();
            break;
        }
      });
      const handleMonthFocus = useEventCallback((event, month) => {
        focusMonth(month);
      });
      const handleMonthBlur = useEventCallback((event, month) => {
        if (focusedMonth === month) {
          changeHasFocus(false);
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendarRoot, _extends$1({
        ref,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: getMonthsInYear(utils2, value != null ? value : referenceDate).map((month) => {
          const monthNumber = utils2.getMonth(month);
          const monthText = utils2.format(month, "monthShort");
          const isSelected = monthNumber === selectedMonth;
          const isDisabled = disabled || isMonthDisabled(month);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonth, {
            selected: isSelected,
            value: monthNumber,
            onClick: handleMonthSelection,
            onKeyDown: handleKeyDown2,
            autoFocus: internalHasFocus && monthNumber === focusedMonth,
            disabled: isDisabled,
            tabIndex: monthNumber === focusedMonth ? 0 : -1,
            onFocus: handleMonthFocus,
            onBlur: handleMonthBlur,
            "aria-current": todayMonth === monthNumber ? "date" : void 0,
            monthsPerRow,
            children: monthText
          }, monthText);
        })
      }));
    });
    function getPickersYearUtilityClass(slot) {
      return generateUtilityClass("MuiPickersYear", slot);
    }
    const pickersYearClasses = generateUtilityClasses("MuiPickersYear", ["root", "yearButton", "selected", "disabled"]);
    const _excluded$9 = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow"];
    const useUtilityClasses$7 = (ownerState) => {
      const {
        disabled,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        yearButton: ["yearButton", disabled && "disabled", selected && "selected"]
      };
      return composeClasses(slots, getPickersYearUtilityClass, classes);
    };
    const PickersYearRoot = styled$1("div", {
      name: "MuiPickersYear",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root]
    })(({
      ownerState
    }) => ({
      flexBasis: ownerState.yearsPerRow === 3 ? "33.3%" : "25%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }));
    const PickersYearButton = styled$1("button", {
      name: "MuiPickersYear",
      slot: "YearButton",
      overridesResolver: (_2, styles2) => [styles2.yearButton, {
        [`&.${pickersYearClasses.disabled}`]: styles2.disabled
      }, {
        [`&.${pickersYearClasses.selected}`]: styles2.selected
      }]
    })(({
      theme
    }) => _extends$1({
      color: "unset",
      backgroundColor: "transparent",
      border: 0,
      outline: 0
    }, theme.typography.subtitle1, {
      margin: "8px 0",
      height: 36,
      width: 72,
      borderRadius: 18,
      cursor: "pointer",
      "&:focus": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.action.active, theme.palette.action.focusOpacity)
      },
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:disabled": {
        cursor: "auto",
        pointerEvents: "none"
      },
      [`&.${pickersYearClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.secondary
      },
      [`&.${pickersYearClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        "&:focus, &:hover": {
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      }
    }));
    const PickersYear = /* @__PURE__ */ reactExports.memo(function PickersYear2(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersYear"
      });
      const {
        autoFocus,
        className,
        children,
        disabled,
        value,
        tabIndex,
        onClick,
        onKeyDown,
        onFocus,
        onBlur,
        "aria-current": ariaCurrent
        // We don't want to forward this prop to the root element
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$9);
      const ref = reactExports.useRef(null);
      const classes = useUtilityClasses$7(props);
      reactExports.useEffect(() => {
        if (autoFocus) {
          ref.current.focus();
        }
      }, [autoFocus]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYearRoot, _extends$1({
        className: clsx(classes.root, className),
        ownerState: props
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYearButton, {
          ref,
          disabled,
          type: "button",
          tabIndex: disabled ? -1 : tabIndex,
          "aria-current": ariaCurrent,
          onClick: (event) => onClick(event, value),
          onKeyDown: (event) => onKeyDown(event, value),
          onFocus: (event) => onFocus(event, value),
          onBlur: (event) => onBlur(event, value),
          className: classes.yearButton,
          ownerState: props,
          children
        })
      }));
    });
    function getYearCalendarUtilityClass(slot) {
      return generateUtilityClass("MuiYearCalendar", slot);
    }
    generateUtilityClasses("MuiYearCalendar", ["root"]);
    const _excluded$8 = ["autoFocus", "className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsPerRow", "timezone"];
    const useUtilityClasses$6 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getYearCalendarUtilityClass, classes);
    };
    function useYearCalendarDefaultizedProps(props, name) {
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const themeProps = useThemeProps({
        props,
        name
      });
      return _extends$1({
        disablePast: false,
        disableFuture: false
      }, themeProps, {
        minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
      });
    }
    const YearCalendarRoot = styled$1("div", {
      name: "MuiYearCalendar",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      overflowY: "auto",
      height: "100%",
      padding: "0 4px",
      width: 320,
      maxHeight: 304
    });
    const YearCalendar = /* @__PURE__ */ reactExports.forwardRef(function YearCalendar2(inProps, ref) {
      const props = useYearCalendarDefaultizedProps(inProps, "MuiYearCalendar");
      const {
        autoFocus,
        className,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onChange,
        readOnly,
        shouldDisableYear,
        disableHighlightToday,
        onYearFocus,
        hasFocus,
        onFocusedViewChange,
        yearsPerRow = 3,
        timezone: timezoneProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$8);
      const {
        value,
        handleValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "YearCalendar",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const now = useNow(timezone);
      const theme = useTheme$1();
      const utils2 = useUtils();
      const referenceDate = reactExports.useMemo(
        () => singleItemValueManager.getInitialReferenceValue({
          value,
          utils: utils2,
          props,
          timezone,
          referenceDate: referenceDateProp,
          granularity: SECTION_TYPE_GRANULARITY.year
        }),
        []
        // eslint-disable-line react-hooks/exhaustive-deps
      );
      const ownerState = props;
      const classes = useUtilityClasses$6(ownerState);
      const todayYear = reactExports.useMemo(() => utils2.getYear(now), [utils2, now]);
      const selectedYear = reactExports.useMemo(() => {
        if (value != null) {
          return utils2.getYear(value);
        }
        if (disableHighlightToday) {
          return null;
        }
        return utils2.getYear(referenceDate);
      }, [value, utils2, disableHighlightToday, referenceDate]);
      const [focusedYear, setFocusedYear] = reactExports.useState(() => selectedYear || todayYear);
      const [internalHasFocus, setInternalHasFocus] = useControlled({
        name: "YearCalendar",
        state: "hasFocus",
        controlled: hasFocus,
        default: autoFocus != null ? autoFocus : false
      });
      const changeHasFocus = useEventCallback((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
          onFocusedViewChange(newHasFocus);
        }
      });
      const isYearDisabled = reactExports.useCallback((dateToValidate) => {
        if (disablePast && utils2.isBeforeYear(dateToValidate, now)) {
          return true;
        }
        if (disableFuture && utils2.isAfterYear(dateToValidate, now)) {
          return true;
        }
        if (minDate && utils2.isBeforeYear(dateToValidate, minDate)) {
          return true;
        }
        if (maxDate && utils2.isAfterYear(dateToValidate, maxDate)) {
          return true;
        }
        if (!shouldDisableYear) {
          return false;
        }
        const yearToValidate = utils2.startOfYear(dateToValidate);
        return shouldDisableYear(yearToValidate);
      }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableYear, utils2]);
      const handleYearSelection = useEventCallback((event, year) => {
        if (readOnly) {
          return;
        }
        const newDate = utils2.setYear(value != null ? value : referenceDate, year);
        handleValueChange(newDate);
      });
      const focusYear = useEventCallback((year) => {
        if (!isYearDisabled(utils2.setYear(value != null ? value : referenceDate, year))) {
          setFocusedYear(year);
          changeHasFocus(true);
          onYearFocus == null ? void 0 : onYearFocus(year);
        }
      });
      reactExports.useEffect(() => {
        setFocusedYear((prevFocusedYear) => selectedYear !== null && prevFocusedYear !== selectedYear ? selectedYear : prevFocusedYear);
      }, [selectedYear]);
      const handleKeyDown2 = useEventCallback((event, year) => {
        switch (event.key) {
          case "ArrowUp":
            focusYear(year - yearsPerRow);
            event.preventDefault();
            break;
          case "ArrowDown":
            focusYear(year + yearsPerRow);
            event.preventDefault();
            break;
          case "ArrowLeft":
            focusYear(year + (theme.direction === "ltr" ? -1 : 1));
            event.preventDefault();
            break;
          case "ArrowRight":
            focusYear(year + (theme.direction === "ltr" ? 1 : -1));
            event.preventDefault();
            break;
        }
      });
      const handleYearFocus = useEventCallback((event, year) => {
        focusYear(year);
      });
      const handleYearBlur = useEventCallback((event, year) => {
        if (focusedYear === year) {
          changeHasFocus(false);
        }
      });
      const scrollerRef = reactExports.useRef(null);
      const handleRef = useForkRef(ref, scrollerRef);
      reactExports.useEffect(() => {
        if (autoFocus || scrollerRef.current === null) {
          return;
        }
        const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
        if (!tabbableButton) {
          return;
        }
        const offsetHeight = tabbableButton.offsetHeight;
        const offsetTop = tabbableButton.offsetTop;
        const clientHeight = scrollerRef.current.clientHeight;
        const scrollTop = scrollerRef.current.scrollTop;
        const elementBottom = offsetTop + offsetHeight;
        if (offsetHeight > clientHeight || offsetTop < scrollTop) {
          return;
        }
        scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
      }, [autoFocus]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendarRoot, _extends$1({
        ref: handleRef,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: utils2.getYearRange(minDate, maxDate).map((year) => {
          const yearNumber = utils2.getYear(year);
          const isSelected = yearNumber === selectedYear;
          const isDisabled = disabled || isYearDisabled(year);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYear, {
            selected: isSelected,
            value: yearNumber,
            onClick: handleYearSelection,
            onKeyDown: handleKeyDown2,
            autoFocus: internalHasFocus && yearNumber === focusedYear,
            disabled: isDisabled,
            tabIndex: yearNumber === focusedYear ? 0 : -1,
            onFocus: handleYearFocus,
            onBlur: handleYearBlur,
            "aria-current": todayYear === yearNumber ? "date" : void 0,
            yearsPerRow,
            children: utils2.format(year, "year")
          }, utils2.format(year, "year"));
        })
      }));
    });
    const getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass("MuiPickersCalendarHeader", slot);
    const pickersCalendarHeaderClasses = generateUtilityClasses("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]);
    const _excluded$7 = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone"], _excluded2 = ["ownerState"];
    const useUtilityClasses$5 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        labelContainer: ["labelContainer"],
        label: ["label"],
        switchViewButton: ["switchViewButton"],
        switchViewIcon: ["switchViewIcon"]
      };
      return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
    };
    const PickersCalendarHeaderRoot = styled$1("div", {
      name: "MuiPickersCalendarHeader",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })({
      display: "flex",
      alignItems: "center",
      marginTop: 16,
      marginBottom: 8,
      paddingLeft: 24,
      paddingRight: 12,
      // prevent jumping in safari
      maxHeight: 30,
      minHeight: 30
    });
    const PickersCalendarHeaderLabelContainer = styled$1("div", {
      name: "MuiPickersCalendarHeader",
      slot: "LabelContainer",
      overridesResolver: (_2, styles2) => styles2.labelContainer
    })(({
      theme
    }) => _extends$1({
      display: "flex",
      overflow: "hidden",
      alignItems: "center",
      cursor: "pointer",
      marginRight: "auto"
    }, theme.typography.body1, {
      fontWeight: theme.typography.fontWeightMedium
    }));
    const PickersCalendarHeaderLabel = styled$1("div", {
      name: "MuiPickersCalendarHeader",
      slot: "Label",
      overridesResolver: (_2, styles2) => styles2.label
    })({
      marginRight: 6
    });
    const PickersCalendarHeaderSwitchViewButton = styled$1(IconButton$1, {
      name: "MuiPickersCalendarHeader",
      slot: "SwitchViewButton",
      overridesResolver: (_2, styles2) => styles2.switchViewButton
    })(({
      ownerState
    }) => _extends$1({
      marginRight: "auto"
    }, ownerState.view === "year" && {
      [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
        transform: "rotate(180deg)"
      }
    }));
    const PickersCalendarHeaderSwitchViewIcon = styled$1(ArrowDropDownIcon, {
      name: "MuiPickersCalendarHeader",
      slot: "SwitchViewIcon",
      overridesResolver: (_2, styles2) => styles2.switchViewIcon
    })(({
      theme
    }) => ({
      willChange: "transform",
      transition: theme.transitions.create("transform"),
      transform: "rotate(0deg)"
    }));
    const PickersCalendarHeader = /* @__PURE__ */ reactExports.forwardRef(function PickersCalendarHeader2(inProps, ref) {
      var _slots$switchViewButt, _slots$switchViewIcon;
      const localeText = useLocaleText();
      const utils2 = useUtils();
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersCalendarHeader"
      });
      const {
        slots,
        slotProps,
        currentMonth: month,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onMonthChange,
        onViewChange,
        view,
        reduceAnimations,
        views,
        labelId,
        className,
        timezone
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$7);
      const ownerState = props;
      const classes = useUtilityClasses$5(props);
      const SwitchViewButton = (_slots$switchViewButt = slots == null ? void 0 : slots.switchViewButton) != null ? _slots$switchViewButt : PickersCalendarHeaderSwitchViewButton;
      const switchViewButtonProps = useSlotProps({
        elementType: SwitchViewButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewButton,
        additionalProps: {
          size: "small",
          "aria-label": localeText.calendarViewSwitchingButtonAriaLabel(view)
        },
        ownerState,
        className: classes.switchViewButton
      });
      const SwitchViewIcon = (_slots$switchViewIcon = slots == null ? void 0 : slots.switchViewIcon) != null ? _slots$switchViewIcon : PickersCalendarHeaderSwitchViewIcon;
      const _useSlotProps = useSlotProps({
        elementType: SwitchViewIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewIcon,
        ownerState: void 0,
        className: classes.switchViewIcon
      }), switchViewIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2);
      const selectNextMonth = () => onMonthChange(utils2.addMonths(month, 1), "left");
      const selectPreviousMonth = () => onMonthChange(utils2.addMonths(month, -1), "right");
      const isNextMonthDisabled = useNextMonthDisabled(month, {
        disableFuture,
        maxDate,
        timezone
      });
      const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
        disablePast,
        minDate,
        timezone
      });
      const handleToggleView = () => {
        if (views.length === 1 || !onViewChange || disabled) {
          return;
        }
        if (views.length === 2) {
          onViewChange(views.find((el2) => el2 !== view) || views[0]);
        } else {
          const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
          onViewChange(views[nextIndexToOpen]);
        }
      };
      if (views.length === 1 && views[0] === "year") {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderRoot, _extends$1({}, other, {
        ownerState,
        className: clsx(className, classes.root),
        ref,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderLabelContainer, {
          role: "presentation",
          onClick: handleToggleView,
          ownerState,
          "aria-live": "polite",
          className: classes.labelContainer,
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroup, {
            reduceAnimations,
            transKey: utils2.format(month, "monthAndYear"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarHeaderLabel, {
              id: labelId,
              ownerState,
              className: classes.label,
              children: utils2.format(month, "monthAndYear")
            })
          }), views.length > 1 && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewButton, _extends$1({}, switchViewButtonProps, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewIcon, _extends$1({}, switchViewIconProps))
          }))]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Fade$1, {
          in: view === "day",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcher, {
            slots,
            slotProps,
            onGoToPrevious: selectPreviousMonth,
            isPreviousDisabled: isPreviousMonthDisabled,
            previousLabel: localeText.previousMonth,
            onGoToNext: selectNextMonth,
            isNextDisabled: isNextMonthDisabled,
            nextLabel: localeText.nextMonth
          })
        })]
      }));
    });
    const PREFERS_REDUCED_MOTION = "@media (prefers-reduced-motion: reduce)";
    const defaultReduceAnimations = typeof navigator !== "undefined" && /(android)/i.test(navigator.userAgent);
    const useDefaultReduceAnimations = () => {
      const prefersReduced = useMediaQuery(PREFERS_REDUCED_MOTION, {
        defaultMatches: false
      });
      return prefersReduced || defaultReduceAnimations;
    };
    const getDateCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateCalendar", slot);
    generateUtilityClasses("MuiDateCalendar", ["root", "viewTransitionContainer"]);
    const _excluded$6 = ["autoFocus", "onViewChange", "value", "defaultValue", "referenceDate", "disableFuture", "disablePast", "defaultCalendarMonth", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "components", "componentsProps", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsPerRow", "monthsPerRow", "timezone"];
    const useUtilityClasses$4 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        viewTransitionContainer: ["viewTransitionContainer"]
      };
      return composeClasses(slots, getDateCalendarUtilityClass, classes);
    };
    function useDateCalendarDefaultizedProps(props, name) {
      var _themeProps$loading, _themeProps$disablePa, _themeProps$disableFu, _themeProps$openTo, _themeProps$views, _themeProps$reduceAni, _themeProps$renderLoa;
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const defaultReduceAnimations2 = useDefaultReduceAnimations();
      const themeProps = useThemeProps({
        props,
        name
      });
      return _extends$1({}, themeProps, {
        loading: (_themeProps$loading = themeProps.loading) != null ? _themeProps$loading : false,
        disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
        disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
        openTo: (_themeProps$openTo = themeProps.openTo) != null ? _themeProps$openTo : "day",
        views: (_themeProps$views = themeProps.views) != null ? _themeProps$views : ["year", "day"],
        reduceAnimations: (_themeProps$reduceAni = themeProps.reduceAnimations) != null ? _themeProps$reduceAni : defaultReduceAnimations2,
        renderLoading: (_themeProps$renderLoa = themeProps.renderLoading) != null ? _themeProps$renderLoa : () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          children: "..."
        }),
        minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
      });
    }
    const DateCalendarRoot = styled$1(PickerViewRoot, {
      name: "MuiDateCalendar",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "flex",
      flexDirection: "column"
    });
    const DateCalendarViewTransitionContainer = styled$1(PickersFadeTransitionGroup, {
      name: "MuiDateCalendar",
      slot: "ViewTransitionContainer",
      overridesResolver: (props, styles2) => styles2.viewTransitionContainer
    })({});
    const DateCalendar = /* @__PURE__ */ reactExports.forwardRef(function DateCalendar2(inProps, ref) {
      var _ref, _slots$calendarHeader, _slotProps$calendarHe;
      const utils2 = useUtils();
      const id2 = useId();
      const props = useDateCalendarDefaultizedProps(inProps, "MuiDateCalendar");
      const {
        autoFocus,
        onViewChange,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disableFuture,
        disablePast,
        defaultCalendarMonth,
        onChange,
        onYearChange,
        onMonthChange,
        reduceAnimations,
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        view: inView,
        views,
        openTo,
        className,
        disabled,
        readOnly,
        minDate,
        maxDate,
        disableHighlightToday,
        focusedView: inFocusedView,
        onFocusedViewChange,
        showDaysOutsideCurrentMonth,
        fixedWeekNumber,
        dayOfWeekFormatter,
        components,
        componentsProps,
        slots,
        slotProps,
        loading,
        renderLoading,
        displayWeekNumber,
        yearsPerRow,
        monthsPerRow,
        timezone: timezoneProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$6);
      const {
        value,
        handleValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "DateCalendar",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const {
        view,
        setView,
        focusedView,
        setFocusedView,
        goToNextView,
        setValueAndGoToNextView
      } = useViews({
        view: inView,
        views,
        openTo,
        onChange: handleValueChange,
        onViewChange,
        autoFocus,
        focusedView: inFocusedView,
        onFocusedViewChange
      });
      const {
        referenceDate,
        calendarState,
        changeFocusedDay,
        changeMonth,
        handleChangeMonth,
        isDateDisabled,
        onMonthSwitchingAnimationEnd
      } = useCalendarState({
        value,
        defaultCalendarMonth,
        referenceDate: referenceDateProp,
        reduceAnimations,
        onMonthChange,
        minDate,
        maxDate,
        shouldDisableDate,
        disablePast,
        disableFuture,
        timezone
      });
      const minDateWithDisabled = disabled && value || minDate;
      const maxDateWithDisabled = disabled && value || maxDate;
      const gridLabelId = `${id2}-grid-label`;
      const hasFocus = focusedView !== null;
      const CalendarHeader = (_ref = (_slots$calendarHeader = slots == null ? void 0 : slots.calendarHeader) != null ? _slots$calendarHeader : components == null ? void 0 : components.CalendarHeader) != null ? _ref : PickersCalendarHeader;
      const calendarHeaderProps = useSlotProps({
        elementType: CalendarHeader,
        externalSlotProps: (_slotProps$calendarHe = slotProps == null ? void 0 : slotProps.calendarHeader) != null ? _slotProps$calendarHe : componentsProps == null ? void 0 : componentsProps.calendarHeader,
        additionalProps: {
          views,
          view,
          currentMonth: calendarState.currentMonth,
          onViewChange: setView,
          onMonthChange: (newMonth, direction) => handleChangeMonth({
            newMonth,
            direction
          }),
          minDate: minDateWithDisabled,
          maxDate: maxDateWithDisabled,
          disabled,
          disablePast,
          disableFuture,
          reduceAnimations,
          timezone,
          labelId: gridLabelId,
          slots,
          slotProps
        },
        ownerState: props
      });
      const handleDateMonthChange = useEventCallback((newDate) => {
        const startOfMonth = utils2.startOfMonth(newDate);
        const endOfMonth = utils2.endOfMonth(newDate);
        const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
          utils: utils2,
          date: newDate,
          minDate: utils2.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
          maxDate: utils2.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
          disablePast,
          disableFuture,
          isDateDisabled,
          timezone
        }) : newDate;
        if (closestEnabledDate) {
          setValueAndGoToNextView(closestEnabledDate, "finish");
          onMonthChange == null ? void 0 : onMonthChange(startOfMonth);
        } else {
          goToNextView();
          changeMonth(startOfMonth);
        }
        changeFocusedDay(closestEnabledDate, true);
      });
      const handleDateYearChange = useEventCallback((newDate) => {
        const startOfYear = utils2.startOfYear(newDate);
        const endOfYear = utils2.endOfYear(newDate);
        const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
          utils: utils2,
          date: newDate,
          minDate: utils2.isBefore(minDate, startOfYear) ? startOfYear : minDate,
          maxDate: utils2.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
          disablePast,
          disableFuture,
          isDateDisabled,
          timezone
        }) : newDate;
        if (closestEnabledDate) {
          setValueAndGoToNextView(closestEnabledDate, "finish");
          onYearChange == null ? void 0 : onYearChange(closestEnabledDate);
        } else {
          goToNextView();
          changeMonth(startOfYear);
        }
        changeFocusedDay(closestEnabledDate, true);
      });
      const handleSelectedDayChange = useEventCallback((day) => {
        if (day) {
          return handleValueChange(mergeDateAndTime(utils2, day, value != null ? value : referenceDate), "finish");
        }
        return handleValueChange(day, "finish");
      });
      reactExports.useEffect(() => {
        if (value != null && utils2.isValid(value)) {
          changeMonth(value);
        }
      }, [value]);
      const ownerState = props;
      const classes = useUtilityClasses$4(ownerState);
      const baseDateValidationProps = {
        disablePast,
        disableFuture,
        maxDate,
        minDate
      };
      const commonViewProps = {
        disableHighlightToday,
        readOnly,
        disabled,
        timezone
      };
      const prevOpenViewRef = reactExports.useRef(view);
      reactExports.useEffect(() => {
        if (prevOpenViewRef.current === view) {
          return;
        }
        if (focusedView === prevOpenViewRef.current) {
          setFocusedView(view, true);
        }
        prevOpenViewRef.current = view;
      }, [focusedView, setFocusedView, view]);
      const selectedDays = reactExports.useMemo(() => [value], [value]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateCalendarRoot, _extends$1({
        ref,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(CalendarHeader, _extends$1({}, calendarHeaderProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendarViewTransitionContainer, {
          reduceAnimations,
          className: classes.viewTransitionContainer,
          transKey: view,
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            children: [view === "year" && /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendar, _extends$1({}, baseDateValidationProps, commonViewProps, {
              value,
              onChange: handleDateYearChange,
              shouldDisableYear,
              hasFocus,
              onFocusedViewChange: (isViewFocused) => setFocusedView("year", isViewFocused),
              yearsPerRow,
              referenceDate
            })), view === "month" && /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendar, _extends$1({}, baseDateValidationProps, commonViewProps, {
              hasFocus,
              className,
              value,
              onChange: handleDateMonthChange,
              shouldDisableMonth,
              onFocusedViewChange: (isViewFocused) => setFocusedView("month", isViewFocused),
              monthsPerRow,
              referenceDate
            })), view === "day" && /* @__PURE__ */ jsxRuntimeExports.jsx(DayCalendar, _extends$1({}, calendarState, baseDateValidationProps, commonViewProps, {
              onMonthSwitchingAnimationEnd,
              onFocusedDayChange: changeFocusedDay,
              reduceAnimations,
              selectedDays,
              onSelectedDaysChange: handleSelectedDayChange,
              shouldDisableDate,
              shouldDisableMonth,
              shouldDisableYear,
              hasFocus,
              onFocusedViewChange: (isViewFocused) => setFocusedView("day", isViewFocused),
              gridLabelId,
              showDaysOutsideCurrentMonth,
              fixedWeekNumber,
              dayOfWeekFormatter,
              displayWeekNumber,
              components,
              componentsProps,
              slots,
              slotProps,
              loading,
              renderLoading
            }))]
          })
        })]
      }));
    });
    function getPickersToolbarUtilityClass(slot) {
      return generateUtilityClass("MuiPickersToolbar", slot);
    }
    generateUtilityClasses("MuiPickersToolbar", ["root", "content"]);
    const useUtilityClasses$3 = (ownerState) => {
      const {
        classes,
        isLandscape
      } = ownerState;
      const slots = {
        root: ["root"],
        content: ["content"],
        penIconButton: ["penIconButton", isLandscape && "penIconButtonLandscape"]
      };
      return composeClasses(slots, getPickersToolbarUtilityClass, classes);
    };
    const PickersToolbarRoot = styled$1("div", {
      name: "MuiPickersToolbar",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      justifyContent: "space-between",
      padding: theme.spacing(2, 3)
    }, ownerState.isLandscape && {
      height: "auto",
      maxWidth: 160,
      padding: 16,
      justifyContent: "flex-start",
      flexWrap: "wrap"
    }));
    const PickersToolbarContent = styled$1(Grid$1, {
      name: "MuiPickersToolbar",
      slot: "Content",
      overridesResolver: (props, styles2) => styles2.content
    })(({
      ownerState
    }) => _extends$1({
      flex: 1
    }, !ownerState.isLandscape && {
      alignItems: "center"
    }));
    const PickersToolbar = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbar2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersToolbar"
      });
      const {
        children,
        className,
        isLandscape,
        landscapeDirection = "column",
        toolbarTitle,
        hidden,
        titleId
      } = props;
      const ownerState = props;
      const classes = useUtilityClasses$3(ownerState);
      if (hidden) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersToolbarRoot, {
        ref,
        className: clsx(classes.root, className),
        ownerState,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
          color: "text.secondary",
          variant: "overline",
          id: titleId,
          children: toolbarTitle
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarContent, {
          container: true,
          justifyContent: isLandscape ? "flex-start" : "space-between",
          className: classes.content,
          ownerState,
          direction: isLandscape ? landscapeDirection : "row",
          alignItems: isLandscape ? "flex-start" : "flex-end",
          children
        })]
      });
    });
    function getDatePickerToolbarUtilityClass(slot) {
      return generateUtilityClass("MuiDatePickerToolbar", slot);
    }
    generateUtilityClasses("MuiDatePickerToolbar", ["root", "title"]);
    const _excluded$5 = ["value", "isLandscape", "onChange", "toolbarFormat", "toolbarPlaceholder", "views"];
    const useUtilityClasses$2 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        title: ["title"]
      };
      return composeClasses(slots, getDatePickerToolbarUtilityClass, classes);
    };
    const DatePickerToolbarRoot = styled$1(PickersToolbar, {
      name: "MuiDatePickerToolbar",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })({});
    const DatePickerToolbarTitle = styled$1(Typography$1, {
      name: "MuiDatePickerToolbar",
      slot: "Title",
      overridesResolver: (_2, styles2) => styles2.title
    })(({
      ownerState
    }) => _extends$1({}, ownerState.isLandscape && {
      margin: "auto 16px auto auto"
    }));
    const DatePickerToolbar = /* @__PURE__ */ reactExports.forwardRef(function DatePickerToolbar2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDatePickerToolbar"
      });
      const {
        value,
        isLandscape,
        toolbarFormat,
        toolbarPlaceholder = "––",
        views
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$5);
      const utils2 = useUtils();
      const localeText = useLocaleText();
      const classes = useUtilityClasses$2(props);
      const dateText = reactExports.useMemo(() => {
        if (!value) {
          return toolbarPlaceholder;
        }
        const formatFromViews = resolveDateFormat(utils2, {
          format: toolbarFormat,
          views
        }, true);
        return utils2.formatByString(value, formatFromViews);
      }, [value, toolbarFormat, toolbarPlaceholder, utils2, views]);
      const ownerState = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarRoot, _extends$1({
        ref,
        toolbarTitle: localeText.datePickerToolbarTitle,
        isLandscape,
        className: classes.root
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarTitle, {
          variant: "h4",
          align: isLandscape ? "left" : "center",
          ownerState,
          className: classes.title,
          children: dateText
        })
      }));
    });
    function useDatePickerDefaultizedProps(props, name) {
      var _themeProps$slots, _themeProps$disableFu, _themeProps$disablePa, _themeProps$slotProps;
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const themeProps = useThemeProps({
        props,
        name
      });
      const localeText = reactExports.useMemo(() => {
        var _themeProps$localeTex;
        if (((_themeProps$localeTex = themeProps.localeText) == null ? void 0 : _themeProps$localeTex.toolbarTitle) == null) {
          return themeProps.localeText;
        }
        return _extends$1({}, themeProps.localeText, {
          datePickerToolbarTitle: themeProps.localeText.toolbarTitle
        });
      }, [themeProps.localeText]);
      const slots = (_themeProps$slots = themeProps.slots) != null ? _themeProps$slots : uncapitalizeObjectKeys(themeProps.components);
      return _extends$1({}, themeProps, {
        localeText
      }, applyDefaultViewProps({
        views: themeProps.views,
        openTo: themeProps.openTo,
        defaultViews: ["year", "day"],
        defaultOpenTo: "day"
      }), {
        disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
        disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
        minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate),
        slots: _extends$1({
          toolbar: DatePickerToolbar
        }, slots),
        slotProps: (_themeProps$slotProps = themeProps.slotProps) != null ? _themeProps$slotProps : themeProps.componentsProps
      });
    }
    const useOpenState = ({
      open: open2,
      onOpen,
      onClose
    }) => {
      const isControllingOpenProp = reactExports.useRef(typeof open2 === "boolean").current;
      const [openState, setIsOpenState] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (isControllingOpenProp) {
          if (typeof open2 !== "boolean") {
            throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
          }
          setIsOpenState(open2);
        }
      }, [isControllingOpenProp, open2]);
      const setIsOpen = reactExports.useCallback((newIsOpen) => {
        if (!isControllingOpenProp) {
          setIsOpenState(newIsOpen);
        }
        if (newIsOpen && onOpen) {
          onOpen();
        }
        if (!newIsOpen && onClose) {
          onClose();
        }
      }, [isControllingOpenProp, onOpen, onClose]);
      return {
        isOpen: openState,
        setIsOpen
      };
    };
    const shouldPublishValue = (params) => {
      const {
        action,
        hasChanged,
        dateState,
        isControlled
      } = params;
      const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
      if (action.name === "setValueFromField") {
        return true;
      }
      if (action.name === "setValueFromAction") {
        if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
          return true;
        }
        return hasChanged(dateState.lastPublishedValue);
      }
      if (action.name === "setValueFromView" && action.selectionState !== "shallow") {
        if (isCurrentValueTheDefaultValue) {
          return true;
        }
        return hasChanged(dateState.lastPublishedValue);
      }
      if (action.name === "setValueFromShortcut" && action.changeImportance === "accept") {
        if (isCurrentValueTheDefaultValue) {
          return true;
        }
        return hasChanged(dateState.lastPublishedValue);
      }
      return false;
    };
    const shouldCommitValue = (params) => {
      const {
        action,
        hasChanged,
        dateState,
        isControlled,
        closeOnSelect
      } = params;
      const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
      if (action.name === "setValueFromAction") {
        if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
          return true;
        }
        return hasChanged(dateState.lastCommittedValue);
      }
      if (action.name === "setValueFromView" && action.selectionState === "finish" && closeOnSelect) {
        if (isCurrentValueTheDefaultValue) {
          return true;
        }
        return hasChanged(dateState.lastCommittedValue);
      }
      if (action.name === "setValueFromShortcut") {
        return action.changeImportance === "accept" && hasChanged(dateState.lastCommittedValue);
      }
      return false;
    };
    const shouldClosePicker = (params) => {
      const {
        action,
        closeOnSelect
      } = params;
      if (action.name === "setValueFromAction") {
        return true;
      }
      if (action.name === "setValueFromView") {
        return action.selectionState === "finish" && closeOnSelect;
      }
      if (action.name === "setValueFromShortcut") {
        return action.changeImportance === "accept";
      }
      return false;
    };
    const usePickerValue = ({
      props,
      valueManager,
      valueType,
      wrapperVariant,
      validator
    }) => {
      const {
        onAccept,
        onChange,
        value: inValue,
        defaultValue: inDefaultValue,
        closeOnSelect = wrapperVariant === "desktop",
        selectedSections: selectedSectionsProp,
        onSelectedSectionsChange,
        timezone: timezoneProp
      } = props;
      const {
        current: defaultValue
      } = reactExports.useRef(inDefaultValue);
      const {
        current: isControlled
      } = reactExports.useRef(inValue !== void 0);
      const utils2 = useUtils();
      const adapter = useLocalizationContext();
      const [selectedSections, setSelectedSections] = useControlled({
        controlled: selectedSectionsProp,
        default: null,
        name: "usePickerValue",
        state: "selectedSections"
      });
      const {
        isOpen,
        setIsOpen
      } = useOpenState(props);
      const [dateState, setDateState] = reactExports.useState(() => {
        let initialValue;
        if (inValue !== void 0) {
          initialValue = inValue;
        } else if (defaultValue !== void 0) {
          initialValue = defaultValue;
        } else {
          initialValue = valueManager.emptyValue;
        }
        return {
          draft: initialValue,
          lastPublishedValue: initialValue,
          lastCommittedValue: initialValue,
          lastControlledValue: inValue,
          hasBeenModifiedSinceMount: false
        };
      });
      const {
        timezone,
        handleValueChange
      } = useValueWithTimezone({
        timezone: timezoneProp,
        value: inValue,
        defaultValue,
        onChange,
        valueManager
      });
      useValidation(_extends$1({}, props, {
        value: dateState.draft,
        timezone
      }), validator, valueManager.isSameError, valueManager.defaultErrorState);
      const updateDate = useEventCallback((action) => {
        const updaterParams = {
          action,
          dateState,
          hasChanged: (comparison) => !valueManager.areValuesEqual(utils2, action.value, comparison),
          isControlled,
          closeOnSelect
        };
        const shouldPublish = shouldPublishValue(updaterParams);
        const shouldCommit = shouldCommitValue(updaterParams);
        const shouldClose = shouldClosePicker(updaterParams);
        setDateState((prev2) => _extends$1({}, prev2, {
          draft: action.value,
          lastPublishedValue: shouldPublish ? action.value : prev2.lastPublishedValue,
          lastCommittedValue: shouldCommit ? action.value : prev2.lastCommittedValue,
          hasBeenModifiedSinceMount: true
        }));
        if (shouldPublish) {
          const validationError = action.name === "setValueFromField" ? action.context.validationError : validator({
            adapter,
            value: action.value,
            props: _extends$1({}, props, {
              value: action.value,
              timezone
            })
          });
          const context = {
            validationError
          };
          handleValueChange(action.value, context);
        }
        if (shouldCommit && onAccept) {
          onAccept(action.value);
        }
        if (shouldClose) {
          setIsOpen(false);
        }
      });
      if (inValue !== void 0 && (dateState.lastControlledValue === void 0 || !valueManager.areValuesEqual(utils2, dateState.lastControlledValue, inValue))) {
        const isUpdateComingFromPicker = valueManager.areValuesEqual(utils2, dateState.draft, inValue);
        setDateState((prev2) => _extends$1({}, prev2, {
          lastControlledValue: inValue
        }, isUpdateComingFromPicker ? {} : {
          lastCommittedValue: inValue,
          lastPublishedValue: inValue,
          draft: inValue,
          hasBeenModifiedSinceMount: true
        }));
      }
      const handleClear = useEventCallback(() => {
        updateDate({
          value: valueManager.emptyValue,
          name: "setValueFromAction",
          pickerAction: "clear"
        });
      });
      const handleAccept = useEventCallback(() => {
        updateDate({
          value: dateState.lastPublishedValue,
          name: "setValueFromAction",
          pickerAction: "accept"
        });
      });
      const handleDismiss = useEventCallback(() => {
        updateDate({
          value: dateState.lastPublishedValue,
          name: "setValueFromAction",
          pickerAction: "dismiss"
        });
      });
      const handleCancel = useEventCallback(() => {
        updateDate({
          value: dateState.lastCommittedValue,
          name: "setValueFromAction",
          pickerAction: "cancel"
        });
      });
      const handleSetToday = useEventCallback(() => {
        updateDate({
          value: valueManager.getTodayValue(utils2, timezone, valueType),
          name: "setValueFromAction",
          pickerAction: "today"
        });
      });
      const handleOpen = useEventCallback(() => setIsOpen(true));
      const handleClose = useEventCallback(() => setIsOpen(false));
      const handleChange = useEventCallback((newValue, selectionState = "partial") => updateDate({
        name: "setValueFromView",
        value: newValue,
        selectionState
      }));
      const handleSelectShortcut = useEventCallback((newValue, changeImportance) => updateDate({
        name: "setValueFromShortcut",
        value: newValue,
        changeImportance: changeImportance != null ? changeImportance : "accept"
      }));
      const handleChangeFromField = useEventCallback((newValue, context) => updateDate({
        name: "setValueFromField",
        value: newValue,
        context
      }));
      const handleFieldSelectedSectionsChange = useEventCallback((newSelectedSections) => {
        setSelectedSections(newSelectedSections);
        onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);
      });
      const actions = {
        onClear: handleClear,
        onAccept: handleAccept,
        onDismiss: handleDismiss,
        onCancel: handleCancel,
        onSetToday: handleSetToday,
        onOpen: handleOpen,
        onClose: handleClose
      };
      const fieldResponse = {
        value: dateState.draft,
        onChange: handleChangeFromField,
        selectedSections,
        onSelectedSectionsChange: handleFieldSelectedSectionsChange
      };
      const viewValue = reactExports.useMemo(() => valueManager.cleanValue(utils2, dateState.draft), [utils2, valueManager, dateState.draft]);
      const viewResponse = {
        value: viewValue,
        onChange: handleChange,
        onClose: handleClose,
        open: isOpen,
        onSelectedSectionsChange: handleFieldSelectedSectionsChange
      };
      const isValid = (testedValue) => {
        const error = validator({
          adapter,
          value: testedValue,
          props: _extends$1({}, props, {
            value: testedValue,
            timezone
          })
        });
        return !valueManager.hasError(error);
      };
      const layoutResponse = _extends$1({}, actions, {
        value: viewValue,
        onChange: handleChange,
        onSelectShortcut: handleSelectShortcut,
        isValid
      });
      return {
        open: isOpen,
        fieldProps: fieldResponse,
        viewProps: viewResponse,
        layoutProps: layoutResponse,
        actions
      };
    };
    const _excluded$4 = ["className", "sx"];
    const usePickerViews = ({
      props,
      propsFromPickerValue,
      additionalViewProps,
      inputRef,
      autoFocusView
    }) => {
      const {
        onChange,
        open: open2,
        onSelectedSectionsChange,
        onClose
      } = propsFromPickerValue;
      const {
        views,
        openTo,
        onViewChange,
        disableOpenPicker,
        viewRenderers,
        timezone
      } = props;
      const propsToForwardToView = _objectWithoutPropertiesLoose$1(props, _excluded$4);
      const {
        view,
        setView,
        defaultView,
        focusedView,
        setFocusedView,
        setValueAndGoToNextView
      } = useViews({
        view: void 0,
        views,
        openTo,
        onChange,
        onViewChange,
        autoFocus: autoFocusView
      });
      const {
        hasUIView,
        viewModeLookup
      } = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
        let viewMode;
        if (disableOpenPicker) {
          viewMode = "field";
        } else if (viewRenderers[viewForReduce] != null) {
          viewMode = "UI";
        } else {
          viewMode = "field";
        }
        acc.viewModeLookup[viewForReduce] = viewMode;
        if (viewMode === "UI") {
          acc.hasUIView = true;
        }
        return acc;
      }, {
        hasUIView: false,
        viewModeLookup: {}
      }), [disableOpenPicker, viewRenderers, views]);
      const timeViewsCount = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
        if (viewRenderers[viewForReduce] != null && isTimeView(viewForReduce)) {
          return acc + 1;
        }
        return acc;
      }, 0), [viewRenderers, views]);
      const currentViewMode = viewModeLookup[view];
      const shouldRestoreFocus = useEventCallback(() => currentViewMode === "UI");
      const [popperView, setPopperView] = reactExports.useState(currentViewMode === "UI" ? view : null);
      if (popperView !== view && viewModeLookup[view] === "UI") {
        setPopperView(view);
      }
      useEnhancedEffect$1(() => {
        if (currentViewMode === "field" && open2) {
          onClose();
          setTimeout(() => {
            inputRef == null ? void 0 : inputRef.current.focus();
            onSelectedSectionsChange(view);
          });
        }
      }, [view]);
      useEnhancedEffect$1(() => {
        if (!open2) {
          return;
        }
        let newView = view;
        if (currentViewMode === "field" && popperView != null) {
          newView = popperView;
        }
        if (newView !== defaultView && viewModeLookup[newView] === "UI" && viewModeLookup[defaultView] === "UI") {
          newView = defaultView;
        }
        if (newView !== view) {
          setView(newView);
        }
        setFocusedView(newView, true);
      }, [open2]);
      const layoutProps = {
        views,
        view: popperView,
        onViewChange: setView
      };
      return {
        hasUIView,
        shouldRestoreFocus,
        layoutProps,
        renderCurrentView: () => {
          if (popperView == null) {
            return null;
          }
          const renderer = viewRenderers[popperView];
          if (renderer == null) {
            return null;
          }
          return renderer(_extends$1({}, propsToForwardToView, additionalViewProps, propsFromPickerValue, {
            views,
            timezone,
            onChange: setValueAndGoToNextView,
            view: popperView,
            onViewChange: setView,
            focusedView,
            onFocusedViewChange: setFocusedView,
            showViewSwitcher: timeViewsCount > 1,
            timeViewsCount
          }));
        }
      };
    };
    function getOrientation() {
      if (typeof window === "undefined") {
        return "portrait";
      }
      if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
        return Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait";
      }
      if (window.orientation) {
        return Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
      }
      return "portrait";
    }
    const useIsLandscape = (views, customOrientation) => {
      const [orientation, setOrientation] = reactExports.useState(getOrientation);
      useEnhancedEffect$1(() => {
        const eventHandler = () => {
          setOrientation(getOrientation());
        };
        window.addEventListener("orientationchange", eventHandler);
        return () => {
          window.removeEventListener("orientationchange", eventHandler);
        };
      }, []);
      if (arrayIncludes$1(views, ["hours", "minutes", "seconds"])) {
        return false;
      }
      const orientationToUse = customOrientation || orientation;
      return orientationToUse === "landscape";
    };
    const usePickerLayoutProps = ({
      props,
      propsFromPickerValue,
      propsFromPickerViews,
      wrapperVariant
    }) => {
      const {
        orientation
      } = props;
      const isLandscape = useIsLandscape(propsFromPickerViews.views, orientation);
      const layoutProps = _extends$1({}, propsFromPickerViews, propsFromPickerValue, {
        isLandscape,
        wrapperVariant,
        disabled: props.disabled,
        readOnly: props.readOnly
      });
      return {
        layoutProps
      };
    };
    buildWarning(["The `renderInput` prop has been removed in version 6.0 of the Date and Time Pickers.", "You can replace it with the `textField` component slot in most cases.", "For more information, please have a look at the migration guide (https://mui.com/x/migration/migration-pickers-v5/#input-renderer-required-in-v5)."]);
    const usePicker = ({
      props,
      valueManager,
      valueType,
      wrapperVariant,
      inputRef,
      additionalViewProps,
      validator,
      autoFocusView
    }) => {
      const pickerValueResponse = usePickerValue({
        props,
        valueManager,
        valueType,
        wrapperVariant,
        validator
      });
      const pickerViewsResponse = usePickerViews({
        props,
        inputRef,
        additionalViewProps,
        autoFocusView,
        propsFromPickerValue: pickerValueResponse.viewProps
      });
      const pickerLayoutResponse = usePickerLayoutProps({
        props,
        wrapperVariant,
        propsFromPickerValue: pickerValueResponse.layoutProps,
        propsFromPickerViews: pickerViewsResponse.layoutProps
      });
      return {
        // Picker value
        open: pickerValueResponse.open,
        actions: pickerValueResponse.actions,
        fieldProps: pickerValueResponse.fieldProps,
        // Picker views
        renderCurrentView: pickerViewsResponse.renderCurrentView,
        hasUIView: pickerViewsResponse.hasUIView,
        shouldRestoreFocus: pickerViewsResponse.shouldRestoreFocus,
        // Picker layout
        layoutProps: pickerLayoutResponse.layoutProps
      };
    };
    function getPickersLayoutUtilityClass(slot) {
      return generateUtilityClass("MuiPickersLayout", slot);
    }
    const pickersLayoutClasses = generateUtilityClasses("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "shortcuts"]);
    const _excluded$3 = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
    function PickersActionBar(props) {
      const {
        onAccept,
        onClear,
        onCancel,
        onSetToday,
        actions
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$3);
      const localeText = useLocaleText();
      if (actions == null || actions.length === 0) {
        return null;
      }
      const buttons = actions == null ? void 0 : actions.map((actionType) => {
        switch (actionType) {
          case "clear":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onClear,
              children: localeText.clearButtonLabel
            }, actionType);
          case "cancel":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onCancel,
              children: localeText.cancelButtonLabel
            }, actionType);
          case "accept":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onAccept,
              children: localeText.okButtonLabel
            }, actionType);
          case "today":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onSetToday,
              children: localeText.todayButtonLabel
            }, actionType);
          default:
            return null;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions$1, _extends$1({}, other, {
        children: buttons
      }));
    }
    const _excluded$2 = ["items", "changeImportance", "isLandscape", "onChange", "isValid"];
    function PickersShortcuts(props) {
      const {
        items,
        changeImportance,
        onChange,
        isValid
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2);
      if (items == null || items.length === 0) {
        return null;
      }
      const resolvedItems = items.map((item) => {
        const newValue = item.getValue({
          isValid
        });
        return {
          label: item.label,
          onClick: () => {
            onChange(newValue, changeImportance);
          },
          disabled: !isValid(newValue)
        };
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$1({
        dense: true,
        sx: [{
          maxHeight: VIEW_HEIGHT,
          maxWidth: 200,
          overflow: "auto"
        }, ...Array.isArray(other.sx) ? other.sx : [other.sx]]
      }, other, {
        children: resolvedItems.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem$1, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, _extends$1({}, item))
          }, item.label);
        })
      }));
    }
    function toolbarHasView(toolbarProps) {
      return toolbarProps.view !== null;
    }
    const useUtilityClasses$1 = (ownerState) => {
      const {
        classes,
        isLandscape
      } = ownerState;
      const slots = {
        root: ["root", isLandscape && "landscape"],
        contentWrapper: ["contentWrapper"],
        toolbar: ["toolbar"],
        actionBar: ["actionBar"],
        tabs: ["tabs"],
        landscape: ["landscape"],
        shortcuts: ["shortcuts"]
      };
      return composeClasses(slots, getPickersLayoutUtilityClass, classes);
    };
    const usePickerLayout = (props) => {
      var _slots$actionBar, _slots$shortcuts;
      const {
        wrapperVariant,
        onAccept,
        onClear,
        onCancel,
        onSetToday,
        view,
        views,
        onViewChange,
        value,
        onChange,
        onSelectShortcut,
        isValid,
        isLandscape,
        disabled,
        readOnly,
        children,
        components,
        componentsProps,
        slots: innerSlots,
        slotProps: innerSlotProps
        // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
        // The true type should be
        // - For pickers value: TDate | null
        // - For range pickers value: [TDate | null, TDate | null]
      } = props;
      const slots = innerSlots != null ? innerSlots : uncapitalizeObjectKeys(components);
      const slotProps = innerSlotProps != null ? innerSlotProps : componentsProps;
      const classes = useUtilityClasses$1(props);
      const ActionBar = (_slots$actionBar = slots == null ? void 0 : slots.actionBar) != null ? _slots$actionBar : PickersActionBar;
      const actionBarProps = useSlotProps({
        elementType: ActionBar,
        externalSlotProps: slotProps == null ? void 0 : slotProps.actionBar,
        additionalProps: {
          onAccept,
          onClear,
          onCancel,
          onSetToday,
          actions: wrapperVariant === "desktop" ? [] : ["cancel", "accept"],
          className: classes.actionBar
        },
        ownerState: _extends$1({}, props, {
          wrapperVariant
        })
      });
      const actionBar = /* @__PURE__ */ jsxRuntimeExports.jsx(ActionBar, _extends$1({}, actionBarProps));
      const Toolbar2 = slots == null ? void 0 : slots.toolbar;
      const toolbarProps = useSlotProps({
        elementType: Toolbar2,
        externalSlotProps: slotProps == null ? void 0 : slotProps.toolbar,
        additionalProps: {
          isLandscape,
          onChange,
          value,
          view,
          onViewChange,
          views,
          disabled,
          readOnly,
          className: classes.toolbar
        },
        ownerState: _extends$1({}, props, {
          wrapperVariant
        })
      });
      const toolbar = toolbarHasView(toolbarProps) && !!Toolbar2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar2, _extends$1({}, toolbarProps)) : null;
      const content = children;
      const Tabs = slots == null ? void 0 : slots.tabs;
      const tabs = view && Tabs ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, _extends$1({
        view,
        onViewChange
      }, slotProps == null ? void 0 : slotProps.tabs)) : null;
      const Shortcuts = (_slots$shortcuts = slots == null ? void 0 : slots.shortcuts) != null ? _slots$shortcuts : PickersShortcuts;
      const shortcutsProps = useSlotProps({
        elementType: Shortcuts,
        externalSlotProps: slotProps == null ? void 0 : slotProps.shortcuts,
        additionalProps: {
          isValid,
          isLandscape,
          onChange: onSelectShortcut,
          className: classes.shortcuts
        },
        ownerState: {
          isValid,
          isLandscape,
          onChange: onSelectShortcut,
          className: classes.shortcuts,
          wrapperVariant
        }
      });
      const shortcuts = view && !!Shortcuts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Shortcuts, _extends$1({}, shortcutsProps)) : null;
      return {
        toolbar,
        content,
        tabs,
        actionBar,
        shortcuts
      };
    };
    const usePickerLayout$1 = usePickerLayout;
    const useUtilityClasses = (ownerState) => {
      const {
        isLandscape,
        classes
      } = ownerState;
      const slots = {
        root: ["root", isLandscape && "landscape"],
        contentWrapper: ["contentWrapper"]
      };
      return composeClasses(slots, getPickersLayoutUtilityClass, classes);
    };
    const PickersLayoutRoot = styled$1("div", {
      name: "MuiPickersLayout",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => ({
      display: "grid",
      gridAutoColumns: "max-content auto max-content",
      gridAutoRows: "max-content auto max-content",
      [`& .${pickersLayoutClasses.toolbar}`]: ownerState.isLandscape ? {
        gridColumn: theme.direction === "rtl" ? 3 : 1,
        gridRow: "2 / 3"
      } : {
        gridColumn: "2 / 4",
        gridRow: 1
      },
      [`.${pickersLayoutClasses.shortcuts}`]: ownerState.isLandscape ? {
        gridColumn: "2 / 4",
        gridRow: 1
      } : {
        gridColumn: theme.direction === "rtl" ? 3 : 1,
        gridRow: "2 / 3"
      },
      [`& .${pickersLayoutClasses.actionBar}`]: {
        gridColumn: "1 / 4",
        gridRow: 3
      }
    }));
    PickersLayoutRoot.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      as: PropTypes.elementType,
      ownerState: PropTypes.shape({
        isLandscape: PropTypes.bool.isRequired
      }).isRequired,
      sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
    };
    const PickersLayoutContentWrapper = styled$1("div", {
      name: "MuiPickersLayout",
      slot: "ContentWrapper",
      overridesResolver: (props, styles2) => styles2.contentWrapper
    })({
      gridColumn: 2,
      gridRow: 2,
      display: "flex",
      flexDirection: "column"
    });
    const PickersLayout = function PickersLayout2(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersLayout"
      });
      const {
        toolbar,
        content,
        tabs,
        actionBar,
        shortcuts
      } = usePickerLayout$1(props);
      const {
        sx,
        className,
        isLandscape,
        ref,
        wrapperVariant
      } = props;
      const ownerState = props;
      const classes = useUtilityClasses(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
        ref,
        sx,
        className: clsx(className, classes.root),
        ownerState,
        children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersLayoutContentWrapper, {
          className: classes.contentWrapper,
          children: wrapperVariant === "desktop" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [content, tabs]
          }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [tabs, content]
          })
        }), actionBar]
      });
    };
    const _excluded$1 = ["props", "ref"];
    const PickerStaticLayout = styled$1(PickersLayout)(({
      theme
    }) => ({
      overflow: "hidden",
      minWidth: DIALOG_WIDTH,
      backgroundColor: (theme.vars || theme).palette.background.paper
    }));
    const useStaticPicker = (_ref) => {
      var _slots$layout;
      let {
        props,
        ref
      } = _ref, pickerParams = _objectWithoutPropertiesLoose$1(_ref, _excluded$1);
      const {
        localeText,
        slots,
        slotProps,
        className,
        sx,
        displayStaticWrapperAs,
        autoFocus
      } = props;
      const {
        layoutProps,
        renderCurrentView
      } = usePicker(_extends$1({}, pickerParams, {
        props,
        autoFocusView: autoFocus != null ? autoFocus : false,
        additionalViewProps: {},
        wrapperVariant: displayStaticWrapperAs
      }));
      const Layout = (_slots$layout = slots == null ? void 0 : slots.layout) != null ? _slots$layout : PickerStaticLayout;
      const renderPicker = () => {
        var _slotProps$layout, _slotProps$layout2, _slotProps$layout3;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(LocalizationProvider, {
          localeText,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$1({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
            slots,
            slotProps,
            sx: [...Array.isArray(sx) ? sx : [sx], ...Array.isArray(slotProps == null || (_slotProps$layout = slotProps.layout) == null ? void 0 : _slotProps$layout.sx) ? slotProps.layout.sx : [slotProps == null || (_slotProps$layout2 = slotProps.layout) == null ? void 0 : _slotProps$layout2.sx]],
            className: clsx(className, slotProps == null || (_slotProps$layout3 = slotProps.layout) == null ? void 0 : _slotProps$layout3.className),
            ref,
            children: renderCurrentView()
          }))
        });
      };
      return {
        renderPicker
      };
    };
    const renderDateViewCalendar = ({
      view,
      onViewChange,
      views,
      focusedView,
      onFocusedViewChange,
      value,
      defaultValue,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minDate,
      maxDate,
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      reduceAnimations,
      onMonthChange,
      monthsPerRow,
      onYearChange,
      yearsPerRow,
      defaultCalendarMonth,
      components,
      componentsProps,
      slots,
      slotProps,
      loading,
      renderLoading,
      disableHighlightToday,
      readOnly,
      disabled,
      showDaysOutsideCurrentMonth,
      dayOfWeekFormatter,
      sx,
      autoFocus,
      fixedWeekNumber,
      displayWeekNumber,
      timezone
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendar, {
      view,
      onViewChange,
      views: views.filter(isDatePickerView),
      focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
      onFocusedViewChange,
      value,
      defaultValue,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minDate,
      maxDate,
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      reduceAnimations,
      onMonthChange,
      monthsPerRow,
      onYearChange,
      yearsPerRow,
      defaultCalendarMonth,
      components,
      componentsProps,
      slots,
      slotProps,
      loading,
      renderLoading,
      disableHighlightToday,
      readOnly,
      disabled,
      showDaysOutsideCurrentMonth,
      dayOfWeekFormatter,
      sx,
      autoFocus,
      fixedWeekNumber,
      displayWeekNumber,
      timezone
    });
    const StaticDatePicker = /* @__PURE__ */ reactExports.forwardRef(function StaticDatePicker2(inProps, ref) {
      var _defaultizedProps$dis, _defaultizedProps$yea, _defaultizedProps$slo;
      const defaultizedProps = useDatePickerDefaultizedProps(inProps, "MuiStaticDatePicker");
      const displayStaticWrapperAs = (_defaultizedProps$dis = defaultizedProps.displayStaticWrapperAs) != null ? _defaultizedProps$dis : "mobile";
      const viewRenderers = _extends$1({
        day: renderDateViewCalendar,
        month: renderDateViewCalendar,
        year: renderDateViewCalendar
      }, defaultizedProps.viewRenderers);
      const props = _extends$1({}, defaultizedProps, {
        viewRenderers,
        displayStaticWrapperAs,
        yearsPerRow: (_defaultizedProps$yea = defaultizedProps.yearsPerRow) != null ? _defaultizedProps$yea : displayStaticWrapperAs === "mobile" ? 3 : 4,
        slotProps: _extends$1({}, defaultizedProps.slotProps, {
          toolbar: _extends$1({
            hidden: displayStaticWrapperAs === "desktop"
          }, (_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.toolbar)
        })
      });
      const {
        renderPicker
      } = useStaticPicker({
        props,
        valueManager: singleItemValueManager,
        valueType: "date",
        validator: validateDate,
        ref
      });
      return renderPicker();
    });
    StaticDatePicker.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * If `true`, the main element is focused during the first mount.
       * This main element is:
       * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
       * - the `input` element if there is a field rendered.
       */
      autoFocus: PropTypes.bool,
      /**
       * Class name applied to the root element.
       */
      className: PropTypes.string,
      /**
       * Overridable components.
       * @default {}
       * @deprecated Please use `slots`.
       */
      components: PropTypes.object,
      /**
       * The props used for each component slot.
       * @default {}
       * @deprecated Please use `slotProps`.
       */
      componentsProps: PropTypes.object,
      /**
       * Formats the day of week displayed in the calendar header.
       * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
       * @returns {string} The name to display.
       * @default (day) => day.charAt(0).toUpperCase()
       */
      dayOfWeekFormatter: PropTypes.func,
      /**
       * Default calendar month displayed when `value` and `defaultValue` are empty.
       */
      defaultCalendarMonth: PropTypes.any,
      /**
       * The default value.
       * Used when the component is not controlled.
       */
      defaultValue: PropTypes.any,
      /**
       * If `true`, the picker and text field are disabled.
       * @default false
       */
      disabled: PropTypes.bool,
      /**
       * If `true`, disable values after the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disableFuture: PropTypes.bool,
      /**
       * If `true`, today's date is rendering without highlighting with circle.
       * @default false
       */
      disableHighlightToday: PropTypes.bool,
      /**
       * If `true`, disable values before the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disablePast: PropTypes.bool,
      /**
       * Force static wrapper inner components to be rendered in mobile or desktop mode.
       * @default "mobile"
       */
      displayStaticWrapperAs: PropTypes.oneOf(["desktop", "mobile"]),
      /**
       * If `true`, the week number will be display in the calendar.
       */
      displayWeekNumber: PropTypes.bool,
      /**
       * Calendar will show more weeks in order to match this value.
       * Put it to 6 for having fix number of week in Gregorian calendars
       * @default undefined
       */
      fixedWeekNumber: PropTypes.number,
      /**
       * If `true`, calls `renderLoading` instead of rendering the day calendar.
       * Can be used to preload information and show it in calendar.
       * @default false
       */
      loading: PropTypes.bool,
      /**
       * Locale for components texts.
       * Allows overriding texts coming from `LocalizationProvider` and `theme`.
       */
      localeText: PropTypes.object,
      /**
       * Maximal selectable date.
       */
      maxDate: PropTypes.any,
      /**
       * Minimal selectable date.
       */
      minDate: PropTypes.any,
      /**
       * Months rendered per row.
       * @default 3
       */
      monthsPerRow: PropTypes.oneOf([3, 4]),
      /**
       * Callback fired when the value is accepted.
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @param {TValue} value The value that was just accepted.
       */
      onAccept: PropTypes.func,
      /**
       * Callback fired when the value changes.
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
       * @param {TValue} value The new value.
       * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
       */
      onChange: PropTypes.func,
      /**
       * Callback fired when component requests to be closed.
       * Can be fired when selecting (by default on `desktop` mode) or clearing a value.
       * @deprecated Please avoid using as it will be removed in next major version.
       */
      onClose: PropTypes.func,
      /**
       * Callback fired when the error associated to the current value changes.
       * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
       *
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
       * @param {TError} error The new error describing why the current value is not valid.
       * @param {TValue} value The value associated to the error.
       */
      onError: PropTypes.func,
      /**
       * Callback fired on month change.
       * @template TDate
       * @param {TDate} month The new month.
       */
      onMonthChange: PropTypes.func,
      /**
       * Callback fired on view change.
       * @template TView
       * @param {TView} view The new view.
       */
      onViewChange: PropTypes.func,
      /**
       * Callback fired on year change.
       * @template TDate
       * @param {TDate} year The new year.
       */
      onYearChange: PropTypes.func,
      /**
       * The default visible view.
       * Used when the component view is not controlled.
       * Must be a valid option from `views` list.
       */
      openTo: PropTypes.oneOf(["day", "month", "year"]),
      /**
       * Force rendering in particular orientation.
       */
      orientation: PropTypes.oneOf(["landscape", "portrait"]),
      readOnly: PropTypes.bool,
      /**
       * Disable heavy animations.
       * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
       */
      reduceAnimations: PropTypes.bool,
      /**
       * Component displaying when passed `loading` true.
       * @returns {React.ReactNode} The node to render when loading.
       * @default () => <span data-mui-test="loading-progress">...</span>
       */
      renderLoading: PropTypes.func,
      /**
       * Disable specific date.
       * @template TDate
       * @param {TDate} day The date to test.
       * @returns {boolean} If `true` the date will be disabled.
       */
      shouldDisableDate: PropTypes.func,
      /**
       * Disable specific month.
       * @template TDate
       * @param {TDate} month The month to test.
       * @returns {boolean} If `true`, the month will be disabled.
       */
      shouldDisableMonth: PropTypes.func,
      /**
       * Disable specific year.
       * @template TDate
       * @param {TDate} year The year to test.
       * @returns {boolean} If `true`, the year will be disabled.
       */
      shouldDisableYear: PropTypes.func,
      /**
       * If `true`, days outside the current month are rendered:
       *
       * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
       *
       * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
       *
       * - ignored if `calendars` equals more than `1` on range pickers.
       * @default false
       */
      showDaysOutsideCurrentMonth: PropTypes.bool,
      /**
       * The props used for each component slot.
       * @default {}
       */
      slotProps: PropTypes.object,
      /**
       * Overridable component slots.
       * @default {}
       */
      slots: PropTypes.object,
      /**
       * The system prop that allows defining system overrides as well as additional CSS styles.
       */
      sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
      /**
       * Choose which timezone to use for the value.
       * Example: "default", "system", "UTC", "America/New_York".
       * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
       * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
       * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
       */
      timezone: PropTypes.string,
      /**
       * The selected value.
       * Used when the component is controlled.
       */
      value: PropTypes.any,
      /**
       * The visible view.
       * Used when the component view is controlled.
       * Must be a valid option from `views` list.
       */
      view: PropTypes.oneOf(["day", "month", "year"]),
      /**
       * Define custom view renderers for each section.
       * If `null`, the section will only have field editing.
       * If `undefined`, internally defined view will be the used.
       */
      viewRenderers: PropTypes.shape({
        day: PropTypes.func,
        month: PropTypes.func,
        year: PropTypes.func
      }),
      /**
       * Available views.
       */
      views: PropTypes.arrayOf(PropTypes.oneOf(["day", "month", "year"]).isRequired),
      /**
       * Years rendered per row.
       * @default 3
       */
      yearsPerRow: PropTypes.oneOf([3, 4])
    };
    const useModalWindow = () => {
      const [open2, setOpen] = reactExports.useState(false);
      const handleOpen = () => setOpen(true);
      return {
        open: open2,
        setOpen,
        handleOpen
      };
    };
    var base64$3 = {};
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    base64$3.encode = function(input) {
      var output = "";
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
        output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
      }
      return output;
    };
    base64$3.decode = function(input) {
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      while (i2 < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i2++));
        enc2 = _keyStr.indexOf(input.charAt(i2++));
        enc3 = _keyStr.indexOf(input.charAt(i2++));
        enc4 = _keyStr.indexOf(input.charAt(i2++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
          output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
          output += String.fromCharCode(chr3);
        }
      }
      return output;
    };
    var support$4 = {};
    var blob;
    support$4.base64 = true;
    support$4.array = true;
    support$4.string = true;
    support$4.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    support$4.nodebuffer = typeof Buffer !== "undefined";
    support$4.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      blob = support$4.blob = false;
    } else {
      var buffer = new ArrayBuffer(0);
      try {
        blob = support$4.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e2) {
        try {
          var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
          var builder = new Builder();
          builder.append(buffer);
          blob = support$4.blob = builder.getBlob("application/zip").size === 0;
        } catch (e3) {
          blob = support$4.blob = false;
        }
      }
    }
    var utils$d = {};
    var compressions$1 = {};
    var flate = {};
    var pako_es5 = { exports: {} };
    (function(module2, exports2) {
      /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
      (function(global2, factory) {
        factory(exports2);
      })(commonjsGlobal, function(exports3) {
        var Z_FIXED$1 = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN$1 = 2;
        function zero$1(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH$1 = 3;
        var MAX_MATCH$1 = 258;
        var LENGTH_CODES$1 = 29;
        var LITERALS$1 = 256;
        var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
        var D_CODES$1 = 30;
        var BL_CODES$1 = 19;
        var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
        var MAX_BITS$1 = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = (
          /* extra bits for each length code */
          new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
        );
        var extra_dbits = (
          /* extra bits for each distance code */
          new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
        );
        var extra_blbits = (
          /* extra bits for each bit length code */
          new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
        );
        var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES$1 + 2) * 2);
        zero$1(static_ltree);
        var static_dtree = new Array(D_CODES$1 * 2);
        zero$1(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero$1(_dist_code);
        var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
        zero$1(_length_code);
        var base_length = new Array(LENGTH_CODES$1);
        zero$1(base_length);
        var base_dist = new Array(D_CODES$1);
        zero$1(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        }
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        }
        var d_code = function d_code2(dist) {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        };
        var put_short = function put_short2(s2, w2) {
          s2.pending_buf[s2.pending++] = w2 & 255;
          s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
        };
        var send_bits = function send_bits2(s2, value, length2) {
          if (s2.bi_valid > Buf_size - length2) {
            s2.bi_buf |= value << s2.bi_valid & 65535;
            put_short(s2, s2.bi_buf);
            s2.bi_buf = value >> Buf_size - s2.bi_valid;
            s2.bi_valid += length2 - Buf_size;
          } else {
            s2.bi_buf |= value << s2.bi_valid & 65535;
            s2.bi_valid += length2;
          }
        };
        var send_code = function send_code2(s2, c2, tree) {
          send_bits(
            s2,
            tree[c2 * 2],
            tree[c2 * 2 + 1]
            /*.Len*/
          );
        };
        var bi_reverse = function bi_reverse2(code, len) {
          var res = 0;
          do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        };
        var bi_flush = function bi_flush2(s2) {
          if (s2.bi_valid === 16) {
            put_short(s2, s2.bi_buf);
            s2.bi_buf = 0;
            s2.bi_valid = 0;
          } else if (s2.bi_valid >= 8) {
            s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
            s2.bi_buf >>= 8;
            s2.bi_valid -= 8;
          }
        };
        var gen_bitlen = function gen_bitlen2(s2, desc) {
          var tree = desc.dyn_tree;
          var max_code = desc.max_code;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var extra = desc.stat_desc.extra_bits;
          var base = desc.stat_desc.extra_base;
          var max_length = desc.stat_desc.max_length;
          var h2;
          var n2, m2;
          var bits;
          var xbits;
          var f2;
          var overflow = 0;
          for (bits = 0; bits <= MAX_BITS$1; bits++) {
            s2.bl_count[bits] = 0;
          }
          tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
          for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
            n2 = s2.heap[h2];
            bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n2 * 2 + 1] = bits;
            if (n2 > max_code) {
              continue;
            }
            s2.bl_count[bits]++;
            xbits = 0;
            if (n2 >= base) {
              xbits = extra[n2 - base];
            }
            f2 = tree[n2 * 2];
            s2.opt_len += f2 * (bits + xbits);
            if (has_stree) {
              s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s2.bl_count[bits] === 0) {
              bits--;
            }
            s2.bl_count[bits]--;
            s2.bl_count[bits + 1] += 2;
            s2.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n2 = s2.bl_count[bits];
            while (n2 !== 0) {
              m2 = s2.heap[--h2];
              if (m2 > max_code) {
                continue;
              }
              if (tree[m2 * 2 + 1] !== bits) {
                s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
                tree[m2 * 2 + 1] = bits;
              }
              n2--;
            }
          }
        };
        var gen_codes = function gen_codes2(tree, max_code, bl_count) {
          var next_code = new Array(MAX_BITS$1 + 1);
          var code = 0;
          var bits;
          var n2;
          for (bits = 1; bits <= MAX_BITS$1; bits++) {
            code = code + bl_count[bits - 1] << 1;
            next_code[bits] = code;
          }
          for (n2 = 0; n2 <= max_code; n2++) {
            var len = tree[n2 * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n2 * 2] = bi_reverse(next_code[len]++, len);
          }
        };
        var tr_static_init = function tr_static_init2() {
          var n2;
          var bits;
          var length2;
          var code;
          var dist;
          var bl_count = new Array(MAX_BITS$1 + 1);
          length2 = 0;
          for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
            base_length[code] = length2;
            for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
              _length_code[length2++] = code;
            }
          }
          _length_code[length2 - 1] = code;
          dist = 0;
          for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
              _dist_code[dist++] = code;
            }
          }
          dist >>= 7;
          for (; code < D_CODES$1; code++) {
            base_dist[code] = dist << 7;
            for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
              _dist_code[256 + dist++] = code;
            }
          }
          for (bits = 0; bits <= MAX_BITS$1; bits++) {
            bl_count[bits] = 0;
          }
          n2 = 0;
          while (n2 <= 143) {
            static_ltree[n2 * 2 + 1] = 8;
            n2++;
            bl_count[8]++;
          }
          while (n2 <= 255) {
            static_ltree[n2 * 2 + 1] = 9;
            n2++;
            bl_count[9]++;
          }
          while (n2 <= 279) {
            static_ltree[n2 * 2 + 1] = 7;
            n2++;
            bl_count[7]++;
          }
          while (n2 <= 287) {
            static_ltree[n2 * 2 + 1] = 8;
            n2++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
          for (n2 = 0; n2 < D_CODES$1; n2++) {
            static_dtree[n2 * 2 + 1] = 5;
            static_dtree[n2 * 2] = bi_reverse(n2, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
        };
        var init_block = function init_block2(s2) {
          var n2;
          for (n2 = 0; n2 < L_CODES$1; n2++) {
            s2.dyn_ltree[n2 * 2] = 0;
          }
          for (n2 = 0; n2 < D_CODES$1; n2++) {
            s2.dyn_dtree[n2 * 2] = 0;
          }
          for (n2 = 0; n2 < BL_CODES$1; n2++) {
            s2.bl_tree[n2 * 2] = 0;
          }
          s2.dyn_ltree[END_BLOCK * 2] = 1;
          s2.opt_len = s2.static_len = 0;
          s2.sym_next = s2.matches = 0;
        };
        var bi_windup = function bi_windup2(s2) {
          if (s2.bi_valid > 8) {
            put_short(s2, s2.bi_buf);
          } else if (s2.bi_valid > 0) {
            s2.pending_buf[s2.pending++] = s2.bi_buf;
          }
          s2.bi_buf = 0;
          s2.bi_valid = 0;
        };
        var smaller = function smaller2(tree, n2, m2, depth) {
          var _n2 = n2 * 2;
          var _m2 = m2 * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
        };
        var pqdownheap = function pqdownheap2(s2, tree, k2) {
          var v2 = s2.heap[k2];
          var j2 = k2 << 1;
          while (j2 <= s2.heap_len) {
            if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
              j2++;
            }
            if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
              break;
            }
            s2.heap[k2] = s2.heap[j2];
            k2 = j2;
            j2 <<= 1;
          }
          s2.heap[k2] = v2;
        };
        var compress_block = function compress_block2(s2, ltree, dtree) {
          var dist;
          var lc2;
          var sx = 0;
          var code;
          var extra;
          if (s2.sym_next !== 0) {
            do {
              dist = s2.pending_buf[s2.sym_buf + sx++] & 255;
              dist += (s2.pending_buf[s2.sym_buf + sx++] & 255) << 8;
              lc2 = s2.pending_buf[s2.sym_buf + sx++];
              if (dist === 0) {
                send_code(s2, lc2, ltree);
              } else {
                code = _length_code[lc2];
                send_code(s2, code + LITERALS$1 + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                  lc2 -= base_length[code];
                  send_bits(s2, lc2, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s2, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                  dist -= base_dist[code];
                  send_bits(s2, dist, extra);
                }
              }
            } while (sx < s2.sym_next);
          }
          send_code(s2, END_BLOCK, ltree);
        };
        var build_tree = function build_tree2(s2, desc) {
          var tree = desc.dyn_tree;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var elems = desc.stat_desc.elems;
          var n2, m2;
          var max_code = -1;
          var node2;
          s2.heap_len = 0;
          s2.heap_max = HEAP_SIZE$1;
          for (n2 = 0; n2 < elems; n2++) {
            if (tree[n2 * 2] !== 0) {
              s2.heap[++s2.heap_len] = max_code = n2;
              s2.depth[n2] = 0;
            } else {
              tree[n2 * 2 + 1] = 0;
            }
          }
          while (s2.heap_len < 2) {
            node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node2 * 2] = 1;
            s2.depth[node2] = 0;
            s2.opt_len--;
            if (has_stree) {
              s2.static_len -= stree[node2 * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
            pqdownheap(s2, tree, n2);
          }
          node2 = elems;
          do {
            n2 = s2.heap[
              1
              /*SMALLEST*/
            ];
            s2.heap[
              1
              /*SMALLEST*/
            ] = s2.heap[s2.heap_len--];
            pqdownheap(
              s2,
              tree,
              1
              /*SMALLEST*/
            );
            m2 = s2.heap[
              1
              /*SMALLEST*/
            ];
            s2.heap[--s2.heap_max] = n2;
            s2.heap[--s2.heap_max] = m2;
            tree[node2 * 2] = tree[n2 * 2] + tree[m2 * 2];
            s2.depth[node2] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
            tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node2;
            s2.heap[
              1
              /*SMALLEST*/
            ] = node2++;
            pqdownheap(
              s2,
              tree,
              1
              /*SMALLEST*/
            );
          } while (s2.heap_len >= 2);
          s2.heap[--s2.heap_max] = s2.heap[
            1
            /*SMALLEST*/
          ];
          gen_bitlen(s2, desc);
          gen_codes(tree, max_code, s2.bl_count);
        };
        var scan_tree = function scan_tree2(s2, tree, max_code) {
          var n2;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n2 = 0; n2 <= max_code; n2++) {
            curlen = nextlen;
            nextlen = tree[(n2 + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s2.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s2.bl_tree[curlen * 2]++;
              }
              s2.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s2.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s2.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        };
        var send_tree = function send_tree2(s2, tree, max_code) {
          var n2;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n2 = 0; n2 <= max_code; n2++) {
            curlen = nextlen;
            nextlen = tree[(n2 + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s2, curlen, s2.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s2, curlen, s2.bl_tree);
                count--;
              }
              send_code(s2, REP_3_6, s2.bl_tree);
              send_bits(s2, count - 3, 2);
            } else if (count <= 10) {
              send_code(s2, REPZ_3_10, s2.bl_tree);
              send_bits(s2, count - 3, 3);
            } else {
              send_code(s2, REPZ_11_138, s2.bl_tree);
              send_bits(s2, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        };
        var build_bl_tree = function build_bl_tree2(s2) {
          var max_blindex;
          scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
          scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
          build_tree(s2, s2.bl_desc);
          for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
            if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        };
        var send_all_trees = function send_all_trees2(s2, lcodes, dcodes, blcodes) {
          var rank2;
          send_bits(s2, lcodes - 257, 5);
          send_bits(s2, dcodes - 1, 5);
          send_bits(s2, blcodes - 4, 4);
          for (rank2 = 0; rank2 < blcodes; rank2++) {
            send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
          }
          send_tree(s2, s2.dyn_ltree, lcodes - 1);
          send_tree(s2, s2.dyn_dtree, dcodes - 1);
        };
        var detect_data_type = function detect_data_type2(s2) {
          var block_mask = 4093624447;
          var n2;
          for (n2 = 0; n2 <= 31; n2++, block_mask >>>= 1) {
            if (block_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n2 = 32; n2 < LITERALS$1; n2++) {
            if (s2.dyn_ltree[n2 * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        };
        var static_init_done = false;
        var _tr_init$1 = function _tr_init2(s2) {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
          s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
          s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
          s2.bi_buf = 0;
          s2.bi_valid = 0;
          init_block(s2);
        };
        var _tr_stored_block$1 = function _tr_stored_block2(s2, buf, stored_len, last2) {
          send_bits(s2, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
          bi_windup(s2);
          put_short(s2, stored_len);
          put_short(s2, ~stored_len);
          if (stored_len) {
            s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
          }
          s2.pending += stored_len;
        };
        var _tr_align$1 = function _tr_align2(s2) {
          send_bits(s2, STATIC_TREES << 1, 3);
          send_code(s2, END_BLOCK, static_ltree);
          bi_flush(s2);
        };
        var _tr_flush_block$1 = function _tr_flush_block2(s2, buf, stored_len, last2) {
          var opt_lenb, static_lenb;
          var max_blindex = 0;
          if (s2.level > 0) {
            if (s2.strm.data_type === Z_UNKNOWN$1) {
              s2.strm.data_type = detect_data_type(s2);
            }
            build_tree(s2, s2.l_desc);
            build_tree(s2, s2.d_desc);
            max_blindex = build_bl_tree(s2);
            opt_lenb = s2.opt_len + 3 + 7 >>> 3;
            static_lenb = s2.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block$1(s2, buf, stored_len, last2);
          } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
            send_bits(s2, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
            compress_block(s2, static_ltree, static_dtree);
          } else {
            send_bits(s2, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
            send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
          }
          init_block(s2);
          if (last2) {
            bi_windup(s2);
          }
        };
        var _tr_tally$1 = function _tr_tally2(s2, dist, lc2) {
          s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
          s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
          s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc2;
          if (dist === 0) {
            s2.dyn_ltree[lc2 * 2]++;
          } else {
            s2.matches++;
            dist--;
            s2.dyn_ltree[(_length_code[lc2] + LITERALS$1 + 1) * 2]++;
            s2.dyn_dtree[d_code(dist) * 2]++;
          }
          return s2.sym_next === s2.sym_end;
        };
        var _tr_init_1 = _tr_init$1;
        var _tr_stored_block_1 = _tr_stored_block$1;
        var _tr_flush_block_1 = _tr_flush_block$1;
        var _tr_tally_1 = _tr_tally$1;
        var _tr_align_1 = _tr_align$1;
        var trees = {
          _tr_init: _tr_init_1,
          _tr_stored_block: _tr_stored_block_1,
          _tr_flush_block: _tr_flush_block_1,
          _tr_tally: _tr_tally_1,
          _tr_align: _tr_align_1
        };
        var adler32 = function adler322(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
          while (len !== 0) {
            n2 = len > 2e3 ? 2e3 : len;
            len -= n2;
            do {
              s1 = s1 + buf[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n2);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        };
        var adler32_1 = adler32;
        var makeTable = function makeTable2() {
          var c2, table2 = [];
          for (var n2 = 0; n2 < 256; n2++) {
            c2 = n2;
            for (var k2 = 0; k2 < 8; k2++) {
              c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
            }
            table2[n2] = c2;
          }
          return table2;
        };
        var crcTable = new Uint32Array(makeTable());
        var crc322 = function crc323(crc, buf, len, pos) {
          var t2 = crcTable;
          var end = pos + len;
          crc ^= -1;
          for (var i2 = pos; i2 < end; i2++) {
            crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
          }
          return crc ^ -1;
        };
        var crc32_1 = crc322;
        var messages = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
        var constants$2 = {
          /* Allowed flush values; see deflate() and inflate() below for details */
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          /* Return codes for the compression/decompression functions. Negative values
          * are errors, positive values are used for special but normal events.
          */
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_MEM_ERROR: -4,
          Z_BUF_ERROR: -5,
          //Z_VERSION_ERROR: -6,
          /* compression levels */
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          /* Possible values of the data_type field (though see inflate()) */
          Z_BINARY: 0,
          Z_TEXT: 1,
          //Z_ASCII:                1, // = Z_TEXT (deprecated)
          Z_UNKNOWN: 2,
          /* The deflate compression method */
          Z_DEFLATED: 8
          //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };
        var _tr_init = trees._tr_init, _tr_stored_block = trees._tr_stored_block, _tr_flush_block = trees._tr_flush_block, _tr_tally = trees._tr_tally, _tr_align = trees._tr_align;
        var Z_NO_FLUSH$2 = constants$2.Z_NO_FLUSH, Z_PARTIAL_FLUSH = constants$2.Z_PARTIAL_FLUSH, Z_FULL_FLUSH$1 = constants$2.Z_FULL_FLUSH, Z_FINISH$3 = constants$2.Z_FINISH, Z_BLOCK$1 = constants$2.Z_BLOCK, Z_OK$3 = constants$2.Z_OK, Z_STREAM_END$3 = constants$2.Z_STREAM_END, Z_STREAM_ERROR$2 = constants$2.Z_STREAM_ERROR, Z_DATA_ERROR$2 = constants$2.Z_DATA_ERROR, Z_BUF_ERROR$1 = constants$2.Z_BUF_ERROR, Z_DEFAULT_COMPRESSION$1 = constants$2.Z_DEFAULT_COMPRESSION, Z_FILTERED = constants$2.Z_FILTERED, Z_HUFFMAN_ONLY = constants$2.Z_HUFFMAN_ONLY, Z_RLE = constants$2.Z_RLE, Z_FIXED = constants$2.Z_FIXED, Z_DEFAULT_STRATEGY$1 = constants$2.Z_DEFAULT_STRATEGY, Z_UNKNOWN = constants$2.Z_UNKNOWN, Z_DEFLATED$2 = constants$2.Z_DEFLATED;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS$1 = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var GZIP_STATE = 57;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        var err = function err2(strm, errorCode) {
          strm.msg = messages[errorCode];
          return errorCode;
        };
        var rank = function rank2(f2) {
          return f2 * 2 - (f2 > 4 ? 9 : 0);
        };
        var zero = function zero2(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        };
        var slide_hash = function slide_hash2(s2) {
          var n2, m2;
          var p2;
          var wsize = s2.w_size;
          n2 = s2.hash_size;
          p2 = n2;
          do {
            m2 = s2.head[--p2];
            s2.head[p2] = m2 >= wsize ? m2 - wsize : 0;
          } while (--n2);
          n2 = wsize;
          p2 = n2;
          do {
            m2 = s2.prev[--p2];
            s2.prev[p2] = m2 >= wsize ? m2 - wsize : 0;
          } while (--n2);
        };
        var HASH_ZLIB = function HASH_ZLIB2(s2, prev2, data) {
          return (prev2 << s2.hash_shift ^ data) & s2.hash_mask;
        };
        var HASH = HASH_ZLIB;
        var flush_pending = function flush_pending2(strm) {
          var s2 = strm.state;
          var len = s2.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
          strm.next_out += len;
          s2.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s2.pending -= len;
          if (s2.pending === 0) {
            s2.pending_out = 0;
          }
        };
        var flush_block_only = function flush_block_only2(s2, last2) {
          _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
          s2.block_start = s2.strstart;
          flush_pending(s2.strm);
        };
        var put_byte = function put_byte2(s2, b2) {
          s2.pending_buf[s2.pending++] = b2;
        };
        var putShortMSB = function putShortMSB2(s2, b2) {
          s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
          s2.pending_buf[s2.pending++] = b2 & 255;
        };
        var read_buf = function read_buf2(strm, buf, start, size) {
          var len = strm.avail_in;
          if (len > size) {
            len = size;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32_1(strm.adler, buf, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32_1(strm.adler, buf, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        };
        var longest_match = function longest_match2(s2, cur_match) {
          var chain_length = s2.max_chain_length;
          var scan = s2.strstart;
          var match2;
          var len;
          var best_len = s2.prev_length;
          var nice_match = s2.nice_match;
          var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
          var _win = s2.window;
          var wmask = s2.w_mask;
          var prev2 = s2.prev;
          var strend = s2.strstart + MAX_MATCH;
          var scan_end1 = _win[scan + best_len - 1];
          var scan_end = _win[scan + best_len];
          if (s2.prev_length >= s2.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s2.lookahead) {
            nice_match = s2.lookahead;
          }
          do {
            match2 = cur_match;
            if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match2++;
            do {
            } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s2.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s2.lookahead) {
            return best_len;
          }
          return s2.lookahead;
        };
        var fill_window = function fill_window2(s2) {
          var _w_size = s2.w_size;
          var n2, more, str;
          do {
            more = s2.window_size - s2.lookahead - s2.strstart;
            if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
              s2.match_start -= _w_size;
              s2.strstart -= _w_size;
              s2.block_start -= _w_size;
              if (s2.insert > s2.strstart) {
                s2.insert = s2.strstart;
              }
              slide_hash(s2);
              more += _w_size;
            }
            if (s2.strm.avail_in === 0) {
              break;
            }
            n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
            s2.lookahead += n2;
            if (s2.lookahead + s2.insert >= MIN_MATCH) {
              str = s2.strstart - s2.insert;
              s2.ins_h = s2.window[str];
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
              while (s2.insert) {
                s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
                s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
                s2.head[s2.ins_h] = str;
                str++;
                s2.insert--;
                if (s2.lookahead + s2.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
        };
        var deflate_stored = function deflate_stored2(s2, flush) {
          var min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
          var len, left, have, last2 = 0;
          var used = s2.strm.avail_in;
          do {
            len = 65535;
            have = s2.bi_valid + 42 >> 3;
            if (s2.strm.avail_out < have) {
              break;
            }
            have = s2.strm.avail_out - have;
            left = s2.strstart - s2.block_start;
            if (len > left + s2.strm.avail_in) {
              len = left + s2.strm.avail_in;
            }
            if (len > have) {
              len = have;
            }
            if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s2.strm.avail_in)) {
              break;
            }
            last2 = flush === Z_FINISH$3 && len === left + s2.strm.avail_in ? 1 : 0;
            _tr_stored_block(s2, 0, 0, last2);
            s2.pending_buf[s2.pending - 4] = len;
            s2.pending_buf[s2.pending - 3] = len >> 8;
            s2.pending_buf[s2.pending - 2] = ~len;
            s2.pending_buf[s2.pending - 1] = ~len >> 8;
            flush_pending(s2.strm);
            if (left) {
              if (left > len) {
                left = len;
              }
              s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
              s2.strm.next_out += left;
              s2.strm.avail_out -= left;
              s2.strm.total_out += left;
              s2.block_start += left;
              len -= left;
            }
            if (len) {
              read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len);
              s2.strm.next_out += len;
              s2.strm.avail_out -= len;
              s2.strm.total_out += len;
            }
          } while (last2 === 0);
          used -= s2.strm.avail_in;
          if (used) {
            if (used >= s2.w_size) {
              s2.matches = 2;
              s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
              s2.strstart = s2.w_size;
              s2.insert = s2.strstart;
            } else {
              if (s2.window_size - s2.strstart <= used) {
                s2.strstart -= s2.w_size;
                s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
                if (s2.matches < 2) {
                  s2.matches++;
                }
                if (s2.insert > s2.strstart) {
                  s2.insert = s2.strstart;
                }
              }
              s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
              s2.strstart += used;
              s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
            }
            s2.block_start = s2.strstart;
          }
          if (s2.high_water < s2.strstart) {
            s2.high_water = s2.strstart;
          }
          if (last2) {
            return BS_FINISH_DONE;
          }
          if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
            return BS_BLOCK_DONE;
          }
          have = s2.window_size - s2.strstart;
          if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
            s2.block_start -= s2.w_size;
            s2.strstart -= s2.w_size;
            s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
            if (s2.matches < 2) {
              s2.matches++;
            }
            have += s2.w_size;
            if (s2.insert > s2.strstart) {
              s2.insert = s2.strstart;
            }
          }
          if (have > s2.strm.avail_in) {
            have = s2.strm.avail_in;
          }
          if (have) {
            read_buf(s2.strm, s2.window, s2.strstart, have);
            s2.strstart += have;
            s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
          }
          if (s2.high_water < s2.strstart) {
            s2.high_water = s2.strstart;
          }
          have = s2.bi_valid + 42 >> 3;
          have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
          min_block = have > s2.w_size ? s2.w_size : have;
          left = s2.strstart - s2.block_start;
          if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s2.strm.avail_in === 0 && left <= have) {
            len = left > have ? have : left;
            last2 = flush === Z_FINISH$3 && s2.strm.avail_in === 0 && len === left ? 1 : 0;
            _tr_stored_block(s2, s2.block_start, len, last2);
            s2.block_start += len;
            flush_pending(s2.strm);
          }
          return last2 ? BS_FINISH_STARTED : BS_NEED_MORE;
        };
        var deflate_fast = function deflate_fast2(s2, flush) {
          var hash_head;
          var bflush;
          for (; ; ) {
            if (s2.lookahead < MIN_LOOKAHEAD) {
              fill_window(s2);
              if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              if (s2.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s2.lookahead >= MIN_MATCH) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
            if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
              s2.match_length = longest_match(s2, hash_head);
            }
            if (s2.match_length >= MIN_MATCH) {
              bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
              s2.lookahead -= s2.match_length;
              if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
                s2.match_length--;
                do {
                  s2.strstart++;
                  s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
                  hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                  s2.head[s2.ins_h] = s2.strstart;
                } while (--s2.match_length !== 0);
                s2.strstart++;
              } else {
                s2.strstart += s2.match_length;
                s2.match_length = 0;
                s2.ins_h = s2.window[s2.strstart];
                s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
              }
            } else {
              bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
              s2.lookahead--;
              s2.strstart++;
            }
            if (bflush) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.sym_next) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        var deflate_slow = function deflate_slow2(s2, flush) {
          var hash_head;
          var bflush;
          var max_insert;
          for (; ; ) {
            if (s2.lookahead < MIN_LOOKAHEAD) {
              fill_window(s2);
              if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              if (s2.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s2.lookahead >= MIN_MATCH) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
            s2.prev_length = s2.match_length;
            s2.prev_match = s2.match_start;
            s2.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
              s2.match_length = longest_match(s2, hash_head);
              if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
                s2.match_length = MIN_MATCH - 1;
              }
            }
            if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
              max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
              bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
              s2.lookahead -= s2.prev_length - 1;
              s2.prev_length -= 2;
              do {
                if (++s2.strstart <= max_insert) {
                  s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
                  hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                  s2.head[s2.ins_h] = s2.strstart;
                }
              } while (--s2.prev_length !== 0);
              s2.match_available = 0;
              s2.match_length = MIN_MATCH - 1;
              s2.strstart++;
              if (bflush) {
                flush_block_only(s2, false);
                if (s2.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s2.match_available) {
              bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
              if (bflush) {
                flush_block_only(s2, false);
              }
              s2.strstart++;
              s2.lookahead--;
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s2.match_available = 1;
              s2.strstart++;
              s2.lookahead--;
            }
          }
          if (s2.match_available) {
            bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
            s2.match_available = 0;
          }
          s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.sym_next) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        var deflate_rle = function deflate_rle2(s2, flush) {
          var bflush;
          var prev2;
          var scan, strend;
          var _win = s2.window;
          for (; ; ) {
            if (s2.lookahead <= MAX_MATCH) {
              fill_window(s2);
              if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              if (s2.lookahead === 0) {
                break;
              }
            }
            s2.match_length = 0;
            if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
              scan = s2.strstart - 1;
              prev2 = _win[scan];
              if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
                strend = s2.strstart + MAX_MATCH;
                do {
                } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
                s2.match_length = MAX_MATCH - (strend - scan);
                if (s2.match_length > s2.lookahead) {
                  s2.match_length = s2.lookahead;
                }
              }
            }
            if (s2.match_length >= MIN_MATCH) {
              bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
              s2.lookahead -= s2.match_length;
              s2.strstart += s2.match_length;
              s2.match_length = 0;
            } else {
              bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
              s2.lookahead--;
              s2.strstart++;
            }
            if (bflush) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s2.insert = 0;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.sym_next) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        var deflate_huff = function deflate_huff2(s2, flush) {
          var bflush;
          for (; ; ) {
            if (s2.lookahead === 0) {
              fill_window(s2);
              if (s2.lookahead === 0) {
                if (flush === Z_NO_FLUSH$2) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s2.match_length = 0;
            bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
            s2.lookahead--;
            s2.strstart++;
            if (bflush) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s2.insert = 0;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.sym_next) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        }
        var configuration_table = [
          /*      good lazy nice chain */
          new Config(0, 0, 0, 0, deflate_stored),
          /* 0 store only */
          new Config(4, 4, 8, 4, deflate_fast),
          /* 1 max speed, no lazy matches */
          new Config(4, 5, 16, 8, deflate_fast),
          /* 2 */
          new Config(4, 6, 32, 32, deflate_fast),
          /* 3 */
          new Config(4, 4, 16, 16, deflate_slow),
          /* 4 lazy matches */
          new Config(8, 16, 32, 32, deflate_slow),
          /* 5 */
          new Config(8, 16, 128, 128, deflate_slow),
          /* 6 */
          new Config(8, 32, 128, 256, deflate_slow),
          /* 7 */
          new Config(32, 128, 258, 1024, deflate_slow),
          /* 8 */
          new Config(32, 258, 258, 4096, deflate_slow)
          /* 9 max compression */
        ];
        var lm_init = function lm_init2(s2) {
          s2.window_size = 2 * s2.w_size;
          zero(s2.head);
          s2.max_lazy_match = configuration_table[s2.level].max_lazy;
          s2.good_match = configuration_table[s2.level].good_length;
          s2.nice_match = configuration_table[s2.level].nice_length;
          s2.max_chain_length = configuration_table[s2.level].max_chain;
          s2.strstart = 0;
          s2.block_start = 0;
          s2.lookahead = 0;
          s2.insert = 0;
          s2.match_length = s2.prev_length = MIN_MATCH - 1;
          s2.match_available = 0;
          s2.ins_h = 0;
        };
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED$2;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
          this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
          this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new Uint16Array(MAX_BITS + 1);
          this.heap = new Uint16Array(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new Uint16Array(2 * L_CODES + 1);
          zero(this.depth);
          this.sym_buf = 0;
          this.lit_bufsize = 0;
          this.sym_next = 0;
          this.sym_end = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        var deflateStateCheck = function deflateStateCheck2(strm) {
          if (!strm) {
            return 1;
          }
          var s2 = strm.state;
          if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && //#ifdef GZIP
          s2.status !== GZIP_STATE && //#endif
          s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
            return 1;
          }
          return 0;
        };
        var deflateResetKeep = function deflateResetKeep2(strm) {
          if (deflateStateCheck(strm)) {
            return err(strm, Z_STREAM_ERROR$2);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          var s2 = strm.state;
          s2.pending = 0;
          s2.pending_out = 0;
          if (s2.wrap < 0) {
            s2.wrap = -s2.wrap;
          }
          s2.status = //#ifdef GZIP
          s2.wrap === 2 ? GZIP_STATE : (
            //#endif
            s2.wrap ? INIT_STATE : BUSY_STATE
          );
          strm.adler = s2.wrap === 2 ? 0 : 1;
          s2.last_flush = -2;
          _tr_init(s2);
          return Z_OK$3;
        };
        var deflateReset = function deflateReset2(strm) {
          var ret = deflateResetKeep(strm);
          if (ret === Z_OK$3) {
            lm_init(strm.state);
          }
          return ret;
        };
        var deflateSetHeader = function deflateSetHeader2(strm, head) {
          if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
            return Z_STREAM_ERROR$2;
          }
          strm.state.gzhead = head;
          return Z_OK$3;
        };
        var deflateInit2 = function deflateInit22(strm, level, method, windowBits, memLevel, strategy) {
          if (!strm) {
            return Z_STREAM_ERROR$2;
          }
          var wrap = 1;
          if (level === Z_DEFAULT_COMPRESSION$1) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
            return err(strm, Z_STREAM_ERROR$2);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          var s2 = new DeflateState();
          strm.state = s2;
          s2.strm = strm;
          s2.status = INIT_STATE;
          s2.wrap = wrap;
          s2.gzhead = null;
          s2.w_bits = windowBits;
          s2.w_size = 1 << s2.w_bits;
          s2.w_mask = s2.w_size - 1;
          s2.hash_bits = memLevel + 7;
          s2.hash_size = 1 << s2.hash_bits;
          s2.hash_mask = s2.hash_size - 1;
          s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s2.window = new Uint8Array(s2.w_size * 2);
          s2.head = new Uint16Array(s2.hash_size);
          s2.prev = new Uint16Array(s2.w_size);
          s2.lit_bufsize = 1 << memLevel + 6;
          s2.pending_buf_size = s2.lit_bufsize * 4;
          s2.pending_buf = new Uint8Array(s2.pending_buf_size);
          s2.sym_buf = s2.lit_bufsize;
          s2.sym_end = (s2.lit_bufsize - 1) * 3;
          s2.level = level;
          s2.strategy = strategy;
          s2.method = method;
          return deflateReset(strm);
        };
        var deflateInit = function deflateInit3(strm, level) {
          return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
        };
        var deflate$2 = function deflate2(strm, flush) {
          if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
          }
          var s2 = strm.state;
          if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
          }
          var old_flush = s2.last_flush;
          s2.last_flush = flush;
          if (s2.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
            return err(strm, Z_BUF_ERROR$1);
          }
          if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR$1);
          }
          if (s2.status === INIT_STATE && s2.wrap === 0) {
            s2.status = BUSY_STATE;
          }
          if (s2.status === INIT_STATE) {
            var header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
              level_flags = 0;
            } else if (s2.level < 6) {
              level_flags = 1;
            } else if (s2.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s2.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            putShortMSB(s2, header);
            if (s2.strstart !== 0) {
              putShortMSB(s2, strm.adler >>> 16);
              putShortMSB(s2, strm.adler & 65535);
            }
            strm.adler = 1;
            s2.status = BUSY_STATE;
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
          }
          if (s2.status === GZIP_STATE) {
            strm.adler = 0;
            put_byte(s2, 31);
            put_byte(s2, 139);
            put_byte(s2, 8);
            if (!s2.gzhead) {
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
              put_byte(s2, OS_CODE);
              s2.status = BUSY_STATE;
              flush_pending(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK$3;
              }
            } else {
              put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
              put_byte(s2, s2.gzhead.time & 255);
              put_byte(s2, s2.gzhead.time >> 8 & 255);
              put_byte(s2, s2.gzhead.time >> 16 & 255);
              put_byte(s2, s2.gzhead.time >> 24 & 255);
              put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
              put_byte(s2, s2.gzhead.os & 255);
              if (s2.gzhead.extra && s2.gzhead.extra.length) {
                put_byte(s2, s2.gzhead.extra.length & 255);
                put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
              }
              if (s2.gzhead.hcrc) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
              }
              s2.gzindex = 0;
              s2.status = EXTRA_STATE;
            }
          }
          if (s2.status === EXTRA_STATE) {
            if (s2.gzhead.extra) {
              var beg = s2.pending;
              var left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
              while (s2.pending + left > s2.pending_buf_size) {
                var copy2 = s2.pending_buf_size - s2.pending;
                s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy2), s2.pending);
                s2.pending = s2.pending_buf_size;
                if (s2.gzhead.hcrc && s2.pending > beg) {
                  strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                }
                s2.gzindex += copy2;
                flush_pending(strm);
                if (s2.pending !== 0) {
                  s2.last_flush = -1;
                  return Z_OK$3;
                }
                beg = 0;
                left -= copy2;
              }
              var gzhead_extra = new Uint8Array(s2.gzhead.extra);
              s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
              s2.pending += left;
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              s2.gzindex = 0;
            }
            s2.status = NAME_STATE;
          }
          if (s2.status === NAME_STATE) {
            if (s2.gzhead.name) {
              var _beg = s2.pending;
              var val;
              do {
                if (s2.pending === s2.pending_buf_size) {
                  if (s2.gzhead.hcrc && s2.pending > _beg) {
                    strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - _beg, _beg);
                  }
                  flush_pending(strm);
                  if (s2.pending !== 0) {
                    s2.last_flush = -1;
                    return Z_OK$3;
                  }
                  _beg = 0;
                }
                if (s2.gzindex < s2.gzhead.name.length) {
                  val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s2, val);
              } while (val !== 0);
              if (s2.gzhead.hcrc && s2.pending > _beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - _beg, _beg);
              }
              s2.gzindex = 0;
            }
            s2.status = COMMENT_STATE;
          }
          if (s2.status === COMMENT_STATE) {
            if (s2.gzhead.comment) {
              var _beg2 = s2.pending;
              var _val;
              do {
                if (s2.pending === s2.pending_buf_size) {
                  if (s2.gzhead.hcrc && s2.pending > _beg2) {
                    strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - _beg2, _beg2);
                  }
                  flush_pending(strm);
                  if (s2.pending !== 0) {
                    s2.last_flush = -1;
                    return Z_OK$3;
                  }
                  _beg2 = 0;
                }
                if (s2.gzindex < s2.gzhead.comment.length) {
                  _val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
                } else {
                  _val = 0;
                }
                put_byte(s2, _val);
              } while (_val !== 0);
              if (s2.gzhead.hcrc && s2.pending > _beg2) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - _beg2, _beg2);
              }
            }
            s2.status = HCRC_STATE;
          }
          if (s2.status === HCRC_STATE) {
            if (s2.gzhead.hcrc) {
              if (s2.pending + 2 > s2.pending_buf_size) {
                flush_pending(strm);
                if (s2.pending !== 0) {
                  s2.last_flush = -1;
                  return Z_OK$3;
                }
              }
              put_byte(s2, strm.adler & 255);
              put_byte(s2, strm.adler >> 8 & 255);
              strm.adler = 0;
            }
            s2.status = BUSY_STATE;
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
          }
          if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
            var bstate = s2.level === 0 ? deflate_stored(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s2.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s2.last_flush = -1;
              }
              return Z_OK$3;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                _tr_align(s2);
              } else if (flush !== Z_BLOCK$1) {
                _tr_stored_block(s2, 0, 0, false);
                if (flush === Z_FULL_FLUSH$1) {
                  zero(s2.head);
                  if (s2.lookahead === 0) {
                    s2.strstart = 0;
                    s2.block_start = 0;
                    s2.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s2.last_flush = -1;
                return Z_OK$3;
              }
            }
          }
          if (flush !== Z_FINISH$3) {
            return Z_OK$3;
          }
          if (s2.wrap <= 0) {
            return Z_STREAM_END$3;
          }
          if (s2.wrap === 2) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            put_byte(s2, strm.adler >> 16 & 255);
            put_byte(s2, strm.adler >> 24 & 255);
            put_byte(s2, strm.total_in & 255);
            put_byte(s2, strm.total_in >> 8 & 255);
            put_byte(s2, strm.total_in >> 16 & 255);
            put_byte(s2, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s2.wrap > 0) {
            s2.wrap = -s2.wrap;
          }
          return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
        };
        var deflateEnd = function deflateEnd2(strm) {
          if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
          }
          var status = strm.state.status;
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
        };
        var deflateSetDictionary = function deflateSetDictionary2(strm, dictionary) {
          var dictLength = dictionary.length;
          if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
          }
          var s2 = strm.state;
          var wrap = s2.wrap;
          if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
            return Z_STREAM_ERROR$2;
          }
          if (wrap === 1) {
            strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
          }
          s2.wrap = 0;
          if (dictLength >= s2.w_size) {
            if (wrap === 0) {
              zero(s2.head);
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
            var tmpDict = new Uint8Array(s2.w_size);
            tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
            dictionary = tmpDict;
            dictLength = s2.w_size;
          }
          var avail = strm.avail_in;
          var next2 = strm.next_in;
          var input = strm.input;
          strm.avail_in = dictLength;
          strm.next_in = 0;
          strm.input = dictionary;
          fill_window(s2);
          while (s2.lookahead >= MIN_MATCH) {
            var str = s2.strstart;
            var n2 = s2.lookahead - (MIN_MATCH - 1);
            do {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
              s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = str;
              str++;
            } while (--n2);
            s2.strstart = str;
            s2.lookahead = MIN_MATCH - 1;
            fill_window(s2);
          }
          s2.strstart += s2.lookahead;
          s2.block_start = s2.strstart;
          s2.insert = s2.lookahead;
          s2.lookahead = 0;
          s2.match_length = s2.prev_length = MIN_MATCH - 1;
          s2.match_available = 0;
          strm.next_in = next2;
          strm.input = input;
          strm.avail_in = avail;
          s2.wrap = wrap;
          return Z_OK$3;
        };
        var deflateInit_1 = deflateInit;
        var deflateInit2_1 = deflateInit2;
        var deflateReset_1 = deflateReset;
        var deflateResetKeep_1 = deflateResetKeep;
        var deflateSetHeader_1 = deflateSetHeader;
        var deflate_2$1 = deflate$2;
        var deflateEnd_1 = deflateEnd;
        var deflateSetDictionary_1 = deflateSetDictionary;
        var deflateInfo = "pako deflate (from Nodeca project)";
        var deflate_1$2 = {
          deflateInit: deflateInit_1,
          deflateInit2: deflateInit2_1,
          deflateReset: deflateReset_1,
          deflateResetKeep: deflateResetKeep_1,
          deflateSetHeader: deflateSetHeader_1,
          deflate: deflate_2$1,
          deflateEnd: deflateEnd_1,
          deflateSetDictionary: deflateSetDictionary_1,
          deflateInfo
        };
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, _typeof2(obj);
        }
        var _has = function _has2(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        };
        var assign2 = function assign3(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (_typeof2(source) !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p2 in source) {
              if (_has(source, p2)) {
                obj[p2] = source[p2];
              }
            }
          }
          return obj;
        };
        var flattenChunks = function flattenChunks2(chunks) {
          var len = 0;
          for (var i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
            len += chunks[i2].length;
          }
          var result = new Uint8Array(len);
          for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {
            var chunk = chunks[_i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        };
        var common2 = {
          assign: assign2,
          flattenChunks
        };
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len2 = new Uint8Array(256);
        for (var q2 = 0; q2 < 256; q2++) {
          _utf8len2[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
        }
        _utf8len2[254] = _utf8len2[254] = 1;
        var string2buf2 = function string2buf3(str) {
          if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
            return new TextEncoder().encode(str);
          }
          var buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c2 = str.charCodeAt(m_pos);
            if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
          }
          buf = new Uint8Array(buf_len);
          for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
            c2 = str.charCodeAt(m_pos);
            if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            if (c2 < 128) {
              buf[i2++] = c2;
            } else if (c2 < 2048) {
              buf[i2++] = 192 | c2 >>> 6;
              buf[i2++] = 128 | c2 & 63;
            } else if (c2 < 65536) {
              buf[i2++] = 224 | c2 >>> 12;
              buf[i2++] = 128 | c2 >>> 6 & 63;
              buf[i2++] = 128 | c2 & 63;
            } else {
              buf[i2++] = 240 | c2 >>> 18;
              buf[i2++] = 128 | c2 >>> 12 & 63;
              buf[i2++] = 128 | c2 >>> 6 & 63;
              buf[i2++] = 128 | c2 & 63;
            }
          }
          return buf;
        };
        var buf2binstring = function buf2binstring2(buf, len) {
          if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK) {
              return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
            }
          }
          var result = "";
          for (var i2 = 0; i2 < len; i2++) {
            result += String.fromCharCode(buf[i2]);
          }
          return result;
        };
        var buf2string2 = function buf2string3(buf, max) {
          var len = max || buf.length;
          if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
            return new TextDecoder().decode(buf.subarray(0, max));
          }
          var i2, out2;
          var utf16buf = new Array(len * 2);
          for (out2 = 0, i2 = 0; i2 < len; ) {
            var c2 = buf[i2++];
            if (c2 < 128) {
              utf16buf[out2++] = c2;
              continue;
            }
            var c_len = _utf8len2[c2];
            if (c_len > 4) {
              utf16buf[out2++] = 65533;
              i2 += c_len - 1;
              continue;
            }
            c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i2 < len) {
              c2 = c2 << 6 | buf[i2++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out2++] = 65533;
              continue;
            }
            if (c2 < 65536) {
              utf16buf[out2++] = c2;
            } else {
              c2 -= 65536;
              utf16buf[out2++] = 55296 | c2 >> 10 & 1023;
              utf16buf[out2++] = 56320 | c2 & 1023;
            }
          }
          return buf2binstring(utf16buf, out2);
        };
        var utf8border2 = function utf8border3(buf, max) {
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          var pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len2[buf[pos]] > max ? pos : max;
        };
        var strings = {
          string2buf: string2buf2,
          buf2string: buf2string2,
          utf8border: utf8border2
        };
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        var zstream = ZStream;
        var toString$1 = Object.prototype.toString;
        var Z_NO_FLUSH$1 = constants$2.Z_NO_FLUSH, Z_SYNC_FLUSH = constants$2.Z_SYNC_FLUSH, Z_FULL_FLUSH = constants$2.Z_FULL_FLUSH, Z_FINISH$2 = constants$2.Z_FINISH, Z_OK$2 = constants$2.Z_OK, Z_STREAM_END$2 = constants$2.Z_STREAM_END, Z_DEFAULT_COMPRESSION = constants$2.Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY = constants$2.Z_DEFAULT_STRATEGY, Z_DEFLATED$1 = constants$2.Z_DEFLATED;
        function Deflate$1(options) {
          this.options = common2.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream();
          this.strm.avail_out = 0;
          var status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
          if (status !== Z_OK$2) {
            throw new Error(messages[status]);
          }
          if (opt.header) {
            deflate_1$2.deflateSetHeader(this.strm, opt.header);
          }
          if (opt.dictionary) {
            var dict;
            if (typeof opt.dictionary === "string") {
              dict = strings.string2buf(opt.dictionary);
            } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(opt.dictionary);
            } else {
              dict = opt.dictionary;
            }
            status = deflate_1$2.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK$2) {
              throw new Error(messages[status]);
            }
            this._dict_set = true;
          }
        }
        Deflate$1.prototype.push = function(data, flush_mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _flush_mode;
          if (this.ended) {
            return false;
          }
          if (flush_mode === ~~flush_mode)
            _flush_mode = flush_mode;
          else
            _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
          if (typeof data === "string") {
            strm.input = strings.string2buf(data);
          } else if (toString$1.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          for (; ; ) {
            if (strm.avail_out === 0) {
              strm.output = new Uint8Array(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
              this.onData(strm.output.subarray(0, strm.next_out));
              strm.avail_out = 0;
              continue;
            }
            status = deflate_1$2.deflate(strm, _flush_mode);
            if (status === Z_STREAM_END$2) {
              if (strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
              }
              status = deflate_1$2.deflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === Z_OK$2;
            }
            if (strm.avail_out === 0) {
              this.onData(strm.output);
              continue;
            }
            if (_flush_mode > 0 && strm.next_out > 0) {
              this.onData(strm.output.subarray(0, strm.next_out));
              strm.avail_out = 0;
              continue;
            }
            if (strm.avail_in === 0)
              break;
          }
          return true;
        };
        Deflate$1.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Deflate$1.prototype.onEnd = function(status) {
          if (status === Z_OK$2) {
            this.result = common2.flattenChunks(this.chunks);
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function deflate$1(input, options) {
          var deflator = new Deflate$1(options);
          deflator.push(input, true);
          if (deflator.err) {
            throw deflator.msg || messages[deflator.err];
          }
          return deflator.result;
        }
        function deflateRaw$1(input, options) {
          options = options || {};
          options.raw = true;
          return deflate$1(input, options);
        }
        function gzip$1(input, options) {
          options = options || {};
          options.gzip = true;
          return deflate$1(input, options);
        }
        var Deflate_1$1 = Deflate$1;
        var deflate_2 = deflate$1;
        var deflateRaw_1$1 = deflateRaw$1;
        var gzip_1$1 = gzip$1;
        var constants$1 = constants$2;
        var deflate_1$1 = {
          Deflate: Deflate_1$1,
          deflate: deflate_2,
          deflateRaw: deflateRaw_1$1,
          gzip: gzip_1$1,
          constants: constants$1
        };
        var BAD$1 = 16209;
        var TYPE$1 = 16191;
        var inffast = function inflate_fast(strm, start) {
          var _in;
          var last2;
          var _out;
          var beg;
          var end;
          var dmax;
          var wsize;
          var whave;
          var wnext;
          var s_window;
          var hold;
          var bits;
          var lcode;
          var dcode;
          var lmask;
          var dmask;
          var here;
          var op;
          var len;
          var dist;
          var from2;
          var from_source;
          var input, output;
          var state = strm.state;
          _in = strm.next_in;
          input = strm.input;
          last2 = _in + (strm.avail_in - 5);
          _out = strm.next_out;
          output = strm.output;
          beg = _out - (start - strm.avail_out);
          end = _out + (strm.avail_out - 257);
          dmax = state.dmax;
          wsize = state.wsize;
          whave = state.whave;
          wnext = state.wnext;
          s_window = state.window;
          hold = state.hold;
          bits = state.bits;
          lcode = state.lencode;
          dcode = state.distcode;
          lmask = (1 << state.lenbits) - 1;
          dmask = (1 << state.distbits) - 1;
          top:
            do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op === 0) {
                    output[_out++] = here & 65535;
                  } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      len += hold & (1 << op) - 1;
                      hold >>>= op;
                      bits -= op;
                    }
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                          dist = here & 65535;
                          op &= 15;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                          }
                          dist += hold & (1 << op) - 1;
                          if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$1;
                            break top;
                          }
                          hold >>>= op;
                          bits -= op;
                          op = _out - beg;
                          if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD$1;
                                break top;
                              }
                            }
                            from2 = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                              from2 += wsize - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from2++];
                                } while (--op);
                                from2 = _out - dist;
                                from_source = output;
                              }
                            } else if (wnext < op) {
                              from2 += wsize + wnext - op;
                              op -= wnext;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from2++];
                                } while (--op);
                                from2 = 0;
                                if (wnext < len) {
                                  op = wnext;
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from2++];
                                  } while (--op);
                                  from2 = _out - dist;
                                  from_source = output;
                                }
                              }
                            } else {
                              from2 += wnext - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from2++];
                                } while (--op);
                                from2 = _out - dist;
                                from_source = output;
                              }
                            }
                            while (len > 2) {
                              output[_out++] = from_source[from2++];
                              output[_out++] = from_source[from2++];
                              output[_out++] = from_source[from2++];
                              len -= 3;
                            }
                            if (len) {
                              output[_out++] = from_source[from2++];
                              if (len > 1) {
                                output[_out++] = from_source[from2++];
                              }
                            }
                          } else {
                            from2 = _out - dist;
                            do {
                              output[_out++] = output[from2++];
                              output[_out++] = output[from2++];
                              output[_out++] = output[from2++];
                              len -= 3;
                            } while (len > 2);
                            if (len) {
                              output[_out++] = output[from2++];
                              if (len > 1) {
                                output[_out++] = output[from2++];
                              }
                            }
                          }
                        } else if ((op & 64) === 0) {
                          here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dodist;
                        } else {
                          strm.msg = "invalid distance code";
                          state.mode = BAD$1;
                          break top;
                        }
                        break;
                      }
                  } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                  } else if (op & 32) {
                    state.mode = TYPE$1;
                    break top;
                  } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD$1;
                    break top;
                  }
                  break;
                }
            } while (_in < last2 && _out < end);
          len = bits >> 3;
          _in -= len;
          bits -= len << 3;
          hold &= (1 << bits) - 1;
          strm.next_in = _in;
          strm.next_out = _out;
          strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
          strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
          state.hold = hold;
          state.bits = bits;
          return;
        };
        var MAXBITS = 15;
        var ENOUGH_LENS$1 = 852;
        var ENOUGH_DISTS$1 = 592;
        var CODES$1 = 0;
        var LENS$1 = 1;
        var DISTS$1 = 2;
        var lbase = new Uint16Array([
          /* Length codes 257..285 base */
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ]);
        var lext = new Uint8Array([
          /* Length codes 257..285 extra */
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ]);
        var dbase = new Uint16Array([
          /* Distance codes 0..29 base */
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ]);
        var dext = new Uint8Array([
          /* Distance codes 0..29 extra */
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ]);
        var inflate_table = function inflate_table2(type, lens, lens_index, codes, table2, table_index, work, opts) {
          var bits = opts.bits;
          var len = 0;
          var sym = 0;
          var min = 0, max = 0;
          var root = 0;
          var curr = 0;
          var drop = 0;
          var left = 0;
          var used = 0;
          var huff = 0;
          var incr;
          var fill;
          var low;
          var mask;
          var next2;
          var base = null;
          var match2;
          var count = new Uint16Array(MAXBITS + 1);
          var offs = new Uint16Array(MAXBITS + 1);
          var extra = null;
          var here_bits, here_op, here_val;
          for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
          }
          for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
          }
          root = bits;
          for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
              break;
            }
          }
          if (root > max) {
            root = max;
          }
          if (max === 0) {
            table2[table_index++] = 1 << 24 | 64 << 16 | 0;
            table2[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
          }
          for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
              break;
            }
          }
          if (root < min) {
            root = min;
          }
          left = 1;
          for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
              return -1;
            }
          }
          if (left > 0 && (type === CODES$1 || max !== 1)) {
            return -1;
          }
          offs[1] = 0;
          for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
          }
          for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
              work[offs[lens[lens_index + sym]]++] = sym;
            }
          }
          if (type === CODES$1) {
            base = extra = work;
            match2 = 20;
          } else if (type === LENS$1) {
            base = lbase;
            extra = lext;
            match2 = 257;
          } else {
            base = dbase;
            extra = dext;
            match2 = 0;
          }
          huff = 0;
          sym = 0;
          len = min;
          next2 = table_index;
          curr = root;
          drop = 0;
          low = -1;
          used = 1 << root;
          mask = used - 1;
          if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
          }
          for (; ; ) {
            here_bits = len - drop;
            if (work[sym] + 1 < match2) {
              here_op = 0;
              here_val = work[sym];
            } else if (work[sym] >= match2) {
              here_op = extra[work[sym] - match2];
              here_val = base[work[sym] - match2];
            } else {
              here_op = 32 + 64;
              here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
              fill -= incr;
              table2[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
              incr >>= 1;
            }
            if (incr !== 0) {
              huff &= incr - 1;
              huff += incr;
            } else {
              huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
              if (len === max) {
                break;
              }
              len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
              if (drop === 0) {
                drop = root;
              }
              next2 += min;
              curr = len - drop;
              left = 1 << curr;
              while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) {
                  break;
                }
                curr++;
                left <<= 1;
              }
              used += 1 << curr;
              if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
                return 1;
              }
              low = huff & mask;
              table2[low] = root << 24 | curr << 16 | next2 - table_index | 0;
            }
          }
          if (huff !== 0) {
            table2[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
          }
          opts.bits = root;
          return 0;
        };
        var inftrees = inflate_table;
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var Z_FINISH$1 = constants$2.Z_FINISH, Z_BLOCK = constants$2.Z_BLOCK, Z_TREES = constants$2.Z_TREES, Z_OK$1 = constants$2.Z_OK, Z_STREAM_END$1 = constants$2.Z_STREAM_END, Z_NEED_DICT$1 = constants$2.Z_NEED_DICT, Z_STREAM_ERROR$1 = constants$2.Z_STREAM_ERROR, Z_DATA_ERROR$1 = constants$2.Z_DATA_ERROR, Z_MEM_ERROR$1 = constants$2.Z_MEM_ERROR, Z_BUF_ERROR = constants$2.Z_BUF_ERROR, Z_DEFLATED = constants$2.Z_DEFLATED;
        var HEAD = 16180;
        var FLAGS = 16181;
        var TIME = 16182;
        var OS = 16183;
        var EXLEN = 16184;
        var EXTRA = 16185;
        var NAME = 16186;
        var COMMENT2 = 16187;
        var HCRC = 16188;
        var DICTID = 16189;
        var DICT = 16190;
        var TYPE = 16191;
        var TYPEDO = 16192;
        var STORED = 16193;
        var COPY_ = 16194;
        var COPY = 16195;
        var TABLE = 16196;
        var LENLENS = 16197;
        var CODELENS = 16198;
        var LEN_ = 16199;
        var LEN = 16200;
        var LENEXT = 16201;
        var DIST = 16202;
        var DISTEXT = 16203;
        var MATCH = 16204;
        var LIT = 16205;
        var CHECK = 16206;
        var LENGTH = 16207;
        var DONE = 16208;
        var BAD = 16209;
        var MEM = 16210;
        var SYNC = 16211;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var MAX_WBITS = 15;
        var DEF_WBITS = MAX_WBITS;
        var zswap32 = function zswap322(q3) {
          return (q3 >>> 24 & 255) + (q3 >>> 8 & 65280) + ((q3 & 65280) << 8) + ((q3 & 255) << 24);
        };
        function InflateState() {
          this.strm = null;
          this.mode = 0;
          this.last = false;
          this.wrap = 0;
          this.havedict = false;
          this.flags = 0;
          this.dmax = 0;
          this.check = 0;
          this.total = 0;
          this.head = null;
          this.wbits = 0;
          this.wsize = 0;
          this.whave = 0;
          this.wnext = 0;
          this.window = null;
          this.hold = 0;
          this.bits = 0;
          this.length = 0;
          this.offset = 0;
          this.extra = 0;
          this.lencode = null;
          this.distcode = null;
          this.lenbits = 0;
          this.distbits = 0;
          this.ncode = 0;
          this.nlen = 0;
          this.ndist = 0;
          this.have = 0;
          this.next = null;
          this.lens = new Uint16Array(320);
          this.work = new Uint16Array(288);
          this.lendyn = null;
          this.distdyn = null;
          this.sane = 0;
          this.back = 0;
          this.was = 0;
        }
        var inflateStateCheck = function inflateStateCheck2(strm) {
          if (!strm) {
            return 1;
          }
          var state = strm.state;
          if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
            return 1;
          }
          return 0;
        };
        var inflateResetKeep = function inflateResetKeep2(strm) {
          if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
          }
          var state = strm.state;
          strm.total_in = strm.total_out = state.total = 0;
          strm.msg = "";
          if (state.wrap) {
            strm.adler = state.wrap & 1;
          }
          state.mode = HEAD;
          state.last = 0;
          state.havedict = 0;
          state.flags = -1;
          state.dmax = 32768;
          state.head = null;
          state.hold = 0;
          state.bits = 0;
          state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
          state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
          state.sane = 1;
          state.back = -1;
          return Z_OK$1;
        };
        var inflateReset = function inflateReset3(strm) {
          if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
          }
          var state = strm.state;
          state.wsize = 0;
          state.whave = 0;
          state.wnext = 0;
          return inflateResetKeep(strm);
        };
        var inflateReset2 = function inflateReset22(strm, windowBits) {
          var wrap;
          if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
          }
          var state = strm.state;
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else {
            wrap = (windowBits >> 4) + 5;
            if (windowBits < 48) {
              windowBits &= 15;
            }
          }
          if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR$1;
          }
          if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
          }
          state.wrap = wrap;
          state.wbits = windowBits;
          return inflateReset(strm);
        };
        var inflateInit2 = function inflateInit22(strm, windowBits) {
          if (!strm) {
            return Z_STREAM_ERROR$1;
          }
          var state = new InflateState();
          strm.state = state;
          state.strm = strm;
          state.window = null;
          state.mode = HEAD;
          var ret = inflateReset2(strm, windowBits);
          if (ret !== Z_OK$1) {
            strm.state = null;
          }
          return ret;
        };
        var inflateInit = function inflateInit3(strm) {
          return inflateInit2(strm, DEF_WBITS);
        };
        var virgin = true;
        var lenfix, distfix;
        var fixedtables = function fixedtables2(state) {
          if (virgin) {
            lenfix = new Int32Array(512);
            distfix = new Int32Array(32);
            var sym = 0;
            while (sym < 144) {
              state.lens[sym++] = 8;
            }
            while (sym < 256) {
              state.lens[sym++] = 9;
            }
            while (sym < 280) {
              state.lens[sym++] = 7;
            }
            while (sym < 288) {
              state.lens[sym++] = 8;
            }
            inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
              bits: 9
            });
            sym = 0;
            while (sym < 32) {
              state.lens[sym++] = 5;
            }
            inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
              bits: 5
            });
            virgin = false;
          }
          state.lencode = lenfix;
          state.lenbits = 9;
          state.distcode = distfix;
          state.distbits = 5;
        };
        var updatewindow = function updatewindow2(strm, src, end, copy2) {
          var dist;
          var state = strm.state;
          if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new Uint8Array(state.wsize);
          }
          if (copy2 >= state.wsize) {
            state.window.set(src.subarray(end - state.wsize, end), 0);
            state.wnext = 0;
            state.whave = state.wsize;
          } else {
            dist = state.wsize - state.wnext;
            if (dist > copy2) {
              dist = copy2;
            }
            state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
            copy2 -= dist;
            if (copy2) {
              state.window.set(src.subarray(end - copy2, end), 0);
              state.wnext = copy2;
              state.whave = state.wsize;
            } else {
              state.wnext += dist;
              if (state.wnext === state.wsize) {
                state.wnext = 0;
              }
              if (state.whave < state.wsize) {
                state.whave += dist;
              }
            }
          }
          return 0;
        };
        var inflate$2 = function inflate2(strm, flush) {
          var state;
          var input, output;
          var next2;
          var put;
          var have, left;
          var hold;
          var bits;
          var _in, _out;
          var copy2;
          var from2;
          var from_source;
          var here = 0;
          var here_bits, here_op, here_val;
          var last_bits, last_op, last_val;
          var len;
          var ret;
          var hbuf = new Uint8Array(4);
          var opts;
          var n2;
          var order = (
            /* permutation of code lengths */
            new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          );
          if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR$1;
          }
          state = strm.state;
          if (state.mode === TYPE) {
            state.mode = TYPEDO;
          }
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next2 = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          _in = have;
          _out = left;
          ret = Z_OK$1;
          inf_leave:
            for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    if (state.wbits === 0) {
                      state.wbits = 15;
                    }
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || /* check if zlib header allowed */
                  (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  }
                  if (len > 15 || len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << state.wbits;
                  state.flags = 0;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32_1(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32_1(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy2 = state.length;
                    if (copy2 > have) {
                      copy2 = have;
                    }
                    if (copy2) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Uint8Array(state.head.extra_len);
                        }
                        state.head.extra.set(
                          input.subarray(
                            next2,
                            // extra field is limited to 65536 bytes
                            // - no need for additional size check
                            next2 + copy2
                          ),
                          /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                          len
                        );
                      }
                      if (state.flags & 512 && state.wrap & 4) {
                        state.check = crc32_1(state.check, input, copy2, next2);
                      }
                      have -= copy2;
                      next2 += copy2;
                      state.length -= copy2;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy2 = 0;
                    do {
                      len = input[next2 + copy2++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy2 < have);
                    if (state.flags & 512 && state.wrap & 4) {
                      state.check = crc32_1(state.check, input, copy2, next2);
                    }
                    have -= copy2;
                    next2 += copy2;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT2;
                case COMMENT2:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy2 = 0;
                    do {
                      len = input[next2 + copy2++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy2 < have);
                    if (state.flags & 512 && state.wrap & 4) {
                      state.check = crc32_1(state.check, input, copy2, next2);
                    }
                    have -= copy2;
                    next2 += copy2;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = zswap32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next2;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT$1;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy2 = state.length;
                  if (copy2) {
                    if (copy2 > have) {
                      copy2 = have;
                    }
                    if (copy2 > left) {
                      copy2 = left;
                    }
                    if (copy2 === 0) {
                      break inf_leave;
                    }
                    output.set(input.subarray(next2, next2 + copy2), put);
                    have -= copy2;
                    next2 += copy2;
                    left -= copy2;
                    put += copy2;
                    state.length -= copy2;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = {
                    bits: state.lenbits
                  };
                  ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n2 = here_bits + 2;
                        while (bits < n2) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next2++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy2 = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n2 = here_bits + 3;
                        while (bits < n2) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next2++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy2 = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n2 = here_bits + 7;
                        while (bits < n2) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next2++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy2 = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy2 > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy2--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = {
                    bits: state.lenbits
                  };
                  ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = {
                    bits: state.distbits
                  };
                  ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next2;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inffast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next2 = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n2 = state.extra;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n2 = state.extra;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy2 = _out - left;
                  if (state.offset > copy2) {
                    copy2 = state.offset - copy2;
                    if (copy2 > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy2 > state.wnext) {
                      copy2 -= state.wnext;
                      from2 = state.wsize - copy2;
                    } else {
                      from2 = state.wnext - copy2;
                    }
                    if (copy2 > state.length) {
                      copy2 = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output;
                    from2 = put - state.offset;
                    copy2 = state.length;
                  }
                  if (copy2 > left) {
                    copy2 = left;
                  }
                  left -= copy2;
                  state.length -= copy2;
                  do {
                    output[put++] = from_source[from2++];
                  } while (--copy2);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next2++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (state.wrap & 4 && _out) {
                      strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                      state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END$1;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR$1;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR$1;
                case SYNC:
                default:
                  return Z_STREAM_ERROR$1;
              }
            }
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next2;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
              ;
          }
          _in -= strm.avail_in;
          _out -= strm.avail_out;
          strm.total_in += _in;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap & 4 && _out) {
            strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
            state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
          }
          strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
          if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
            ret = Z_BUF_ERROR;
          }
          return ret;
        };
        var inflateEnd = function inflateEnd2(strm) {
          if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
          }
          var state = strm.state;
          if (state.window) {
            state.window = null;
          }
          strm.state = null;
          return Z_OK$1;
        };
        var inflateGetHeader = function inflateGetHeader2(strm, head) {
          if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
          }
          var state = strm.state;
          if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR$1;
          }
          state.head = head;
          head.done = false;
          return Z_OK$1;
        };
        var inflateSetDictionary = function inflateSetDictionary2(strm, dictionary) {
          var dictLength = dictionary.length;
          var state;
          var dictid;
          var ret;
          if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
          }
          state = strm.state;
          if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR$1;
          }
          if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32_1(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
              return Z_DATA_ERROR$1;
            }
          }
          ret = updatewindow(strm, dictionary, dictLength, dictLength);
          if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR$1;
          }
          state.havedict = 1;
          return Z_OK$1;
        };
        var inflateReset_1 = inflateReset;
        var inflateReset2_1 = inflateReset2;
        var inflateResetKeep_1 = inflateResetKeep;
        var inflateInit_1 = inflateInit;
        var inflateInit2_1 = inflateInit2;
        var inflate_2$1 = inflate$2;
        var inflateEnd_1 = inflateEnd;
        var inflateGetHeader_1 = inflateGetHeader;
        var inflateSetDictionary_1 = inflateSetDictionary;
        var inflateInfo = "pako inflate (from Nodeca project)";
        var inflate_1$2 = {
          inflateReset: inflateReset_1,
          inflateReset2: inflateReset2_1,
          inflateResetKeep: inflateResetKeep_1,
          inflateInit: inflateInit_1,
          inflateInit2: inflateInit2_1,
          inflate: inflate_2$1,
          inflateEnd: inflateEnd_1,
          inflateGetHeader: inflateGetHeader_1,
          inflateSetDictionary: inflateSetDictionary_1,
          inflateInfo
        };
        function GZheader() {
          this.text = 0;
          this.time = 0;
          this.xflags = 0;
          this.os = 0;
          this.extra = null;
          this.extra_len = 0;
          this.name = "";
          this.comment = "";
          this.hcrc = 0;
          this.done = false;
        }
        var gzheader = GZheader;
        var toString = Object.prototype.toString;
        var Z_NO_FLUSH = constants$2.Z_NO_FLUSH, Z_FINISH = constants$2.Z_FINISH, Z_OK = constants$2.Z_OK, Z_STREAM_END = constants$2.Z_STREAM_END, Z_NEED_DICT = constants$2.Z_NEED_DICT, Z_STREAM_ERROR = constants$2.Z_STREAM_ERROR, Z_DATA_ERROR = constants$2.Z_DATA_ERROR, Z_MEM_ERROR = constants$2.Z_MEM_ERROR;
        function Inflate$1(options) {
          this.options = common2.assign({
            chunkSize: 1024 * 64,
            windowBits: 15,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream();
          this.strm.avail_out = 0;
          var status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
          if (status !== Z_OK) {
            throw new Error(messages[status]);
          }
          this.header = new gzheader();
          inflate_1$2.inflateGetHeader(this.strm, this.header);
          if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
              opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
              opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
              status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
              if (status !== Z_OK) {
                throw new Error(messages[status]);
              }
            }
          }
        }
        Inflate$1.prototype.push = function(data, flush_mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var dictionary = this.options.dictionary;
          var status, _flush_mode, last_avail_out;
          if (this.ended)
            return false;
          if (flush_mode === ~~flush_mode)
            _flush_mode = flush_mode;
          else
            _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
          if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          for (; ; ) {
            if (strm.avail_out === 0) {
              strm.output = new Uint8Array(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = inflate_1$2.inflate(strm, _flush_mode);
            if (status === Z_NEED_DICT && dictionary) {
              status = inflate_1$2.inflateSetDictionary(strm, dictionary);
              if (status === Z_OK) {
                status = inflate_1$2.inflate(strm, _flush_mode);
              } else if (status === Z_DATA_ERROR) {
                status = Z_NEED_DICT;
              }
            }
            while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
              inflate_1$2.inflateReset(strm);
              status = inflate_1$2.inflate(strm, _flush_mode);
            }
            switch (status) {
              case Z_STREAM_ERROR:
              case Z_DATA_ERROR:
              case Z_NEED_DICT:
              case Z_MEM_ERROR:
                this.onEnd(status);
                this.ended = true;
                return false;
            }
            last_avail_out = strm.avail_out;
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === Z_STREAM_END) {
                if (this.options.to === "string") {
                  var next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                  var tail = strm.next_out - next_out_utf8;
                  var utf8str = strings.buf2string(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail)
                    strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                  this.onData(utf8str);
                } else {
                  this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                }
              }
            }
            if (status === Z_OK && last_avail_out === 0)
              continue;
            if (status === Z_STREAM_END) {
              status = inflate_1$2.inflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return true;
            }
            if (strm.avail_in === 0)
              break;
          }
          return true;
        };
        Inflate$1.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Inflate$1.prototype.onEnd = function(status) {
          if (status === Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = common2.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function inflate$1(input, options) {
          var inflator = new Inflate$1(options);
          inflator.push(input);
          if (inflator.err)
            throw inflator.msg || messages[inflator.err];
          return inflator.result;
        }
        function inflateRaw$1(input, options) {
          options = options || {};
          options.raw = true;
          return inflate$1(input, options);
        }
        var Inflate_1$1 = Inflate$1;
        var inflate_2 = inflate$1;
        var inflateRaw_1$1 = inflateRaw$1;
        var ungzip$1 = inflate$1;
        var constants = constants$2;
        var inflate_1$1 = {
          Inflate: Inflate_1$1,
          inflate: inflate_2,
          inflateRaw: inflateRaw_1$1,
          ungzip: ungzip$1,
          constants
        };
        var Deflate = deflate_1$1.Deflate, deflate = deflate_1$1.deflate, deflateRaw = deflate_1$1.deflateRaw, gzip = deflate_1$1.gzip;
        var Inflate = inflate_1$1.Inflate, inflate = inflate_1$1.inflate, inflateRaw = inflate_1$1.inflateRaw, ungzip = inflate_1$1.ungzip;
        var Deflate_1 = Deflate;
        var deflate_1 = deflate;
        var deflateRaw_1 = deflateRaw;
        var gzip_1 = gzip;
        var Inflate_1 = Inflate;
        var inflate_1 = inflate;
        var inflateRaw_1 = inflateRaw;
        var ungzip_1 = ungzip;
        var constants_1 = constants$2;
        var pako2 = {
          Deflate: Deflate_1,
          deflate: deflate_1,
          deflateRaw: deflateRaw_1,
          gzip: gzip_1,
          Inflate: Inflate_1,
          inflate: inflate_1,
          inflateRaw: inflateRaw_1,
          ungzip: ungzip_1,
          constants: constants_1
        };
        exports3.Deflate = Deflate_1;
        exports3.Inflate = Inflate_1;
        exports3.constants = constants_1;
        exports3["default"] = pako2;
        exports3.deflate = deflate_1;
        exports3.deflateRaw = deflateRaw_1;
        exports3.gzip = gzip_1;
        exports3.inflate = inflate_1;
        exports3.inflateRaw = inflateRaw_1;
        exports3.ungzip = ungzip_1;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    })(pako_es5, pako_es5.exports);
    var pako_es5Exports = pako_es5.exports;
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = pako_es5Exports;
    flate.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
    flate.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
    flate.magic = "\b\0";
    flate.compress = function(input, compressionOptions) {
      return pako.deflateRaw(input, {
        level: compressionOptions.level || -1
        // default compression
      });
    };
    flate.uncompress = function(input) {
      return pako.inflateRaw(input);
    };
    compressions$1.STORE = {
      magic: "\0\0",
      compress: function compress(content) {
        return content;
      },
      uncompress: function uncompress(content) {
        return content;
      },
      compressInputType: null,
      uncompressInputType: null
    };
    compressions$1.DEFLATE = flate;
    var nodeBuffer$2 = { exports: {} };
    nodeBuffer$2.exports = function(data, encoding) {
      if (typeof data === "number") {
        return Buffer.alloc(data);
      }
      return Buffer.from(data, encoding);
    };
    nodeBuffer$2.exports.test = function(b2) {
      return Buffer.isBuffer(b2);
    };
    var nodeBufferExports = nodeBuffer$2.exports;
    (function(exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      var support2 = support$4;
      var compressions2 = compressions$1;
      var nodeBuffer2 = nodeBufferExports;
      exports2.string2binary = function(str) {
        var result = "";
        for (var i2 = 0; i2 < str.length; i2++) {
          result += String.fromCharCode(str.charCodeAt(i2) & 255);
        }
        return result;
      };
      exports2.arrayBuffer2Blob = function(buffer2, mimeType) {
        exports2.checkSupport("blob");
        mimeType = mimeType || "application/zip";
        try {
          return new Blob([buffer2], {
            type: mimeType
          });
        } catch (e2) {
          try {
            var Builder2 = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder2 = new Builder2();
            builder2.append(buffer2);
            return builder2.getBlob(mimeType);
          } catch (e3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      function identity2(input) {
        return input;
      }
      function stringToArrayLike(str, array) {
        for (var i2 = 0; i2 < str.length; ++i2) {
          array[i2] = str.charCodeAt(i2) & 255;
        }
        return array;
      }
      function arrayLikeToString(array) {
        var chunk = 65536;
        var result = [], len = array.length, type = exports2.getTypeOf(array);
        var k2 = 0, canUseApply = true;
        try {
          switch (type) {
            case "uint8array":
              String.fromCharCode.apply(null, new Uint8Array(0));
              break;
            case "nodebuffer":
              String.fromCharCode.apply(null, nodeBuffer2(0));
              break;
          }
        } catch (e2) {
          canUseApply = false;
        }
        if (!canUseApply) {
          var resultStr = "";
          for (var i2 = 0; i2 < array.length; i2++) {
            resultStr += String.fromCharCode(array[i2]);
          }
          return resultStr;
        }
        while (k2 < len && chunk > 1) {
          try {
            if (type === "array" || type === "nodebuffer") {
              result.push(String.fromCharCode.apply(null, array.slice(k2, Math.min(k2 + chunk, len))));
            } else {
              result.push(String.fromCharCode.apply(null, array.subarray(k2, Math.min(k2 + chunk, len))));
            }
            k2 += chunk;
          } catch (e2) {
            chunk = Math.floor(chunk / 2);
          }
        }
        return result.join("");
      }
      exports2.applyFromCharCode = arrayLikeToString;
      function arrayLikeToArrayLike(arrayFrom, arrayTo) {
        for (var i2 = 0; i2 < arrayFrom.length; i2++) {
          arrayTo[i2] = arrayFrom[i2];
        }
        return arrayTo;
      }
      var transform = {};
      transform.string = {
        string: identity2,
        array: function array(input) {
          return stringToArrayLike(input, new Array(input.length));
        },
        arraybuffer: function arraybuffer(input) {
          return transform.string.uint8array(input).buffer;
        },
        uint8array: function uint8array(input) {
          return stringToArrayLike(input, new Uint8Array(input.length));
        },
        nodebuffer: function nodebuffer(input) {
          return stringToArrayLike(input, nodeBuffer2(input.length));
        }
      };
      transform.array = {
        string: arrayLikeToString,
        array: identity2,
        arraybuffer: function arraybuffer(input) {
          return new Uint8Array(input).buffer;
        },
        uint8array: function uint8array(input) {
          return new Uint8Array(input);
        },
        nodebuffer: function nodebuffer(input) {
          return nodeBuffer2(input);
        }
      };
      transform.arraybuffer = {
        string: function string(input) {
          return arrayLikeToString(new Uint8Array(input));
        },
        array: function array(input) {
          return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
        },
        arraybuffer: identity2,
        uint8array: function uint8array(input) {
          return new Uint8Array(input);
        },
        nodebuffer: function nodebuffer(input) {
          return nodeBuffer2(new Uint8Array(input));
        }
      };
      transform.uint8array = {
        string: arrayLikeToString,
        array: function array(input) {
          return arrayLikeToArrayLike(input, new Array(input.length));
        },
        arraybuffer: function arraybuffer(input) {
          return input.buffer;
        },
        uint8array: identity2,
        nodebuffer: function nodebuffer(input) {
          return nodeBuffer2(input);
        }
      };
      transform.nodebuffer = {
        string: arrayLikeToString,
        array: function array(input) {
          return arrayLikeToArrayLike(input, new Array(input.length));
        },
        arraybuffer: function arraybuffer(input) {
          return transform.nodebuffer.uint8array(input).buffer;
        },
        uint8array: function uint8array(input) {
          return arrayLikeToArrayLike(input, new Uint8Array(input.length));
        },
        nodebuffer: identity2
      };
      exports2.transformTo = function(outputType, input) {
        if (!input) {
          input = "";
        }
        if (!outputType) {
          return input;
        }
        exports2.checkSupport(outputType);
        var inputType = exports2.getTypeOf(input);
        var result = transform[inputType][outputType](input);
        return result;
      };
      exports2.getTypeOf = function(input) {
        if (input == null) {
          return;
        }
        if (typeof input === "string") {
          return "string";
        }
        if (Object.prototype.toString.call(input) === "[object Array]") {
          return "array";
        }
        if (support2.nodebuffer && nodeBuffer2.test(input)) {
          return "nodebuffer";
        }
        if (support2.uint8array && input instanceof Uint8Array) {
          return "uint8array";
        }
        if (support2.arraybuffer && input instanceof ArrayBuffer) {
          return "arraybuffer";
        }
        if (input instanceof Promise) {
          throw new Error("Cannot read data from a promise, you probably are running new PizZip(data) with a promise");
        }
        if (_typeof2(input) === "object" && typeof input.file === "function") {
          throw new Error("Cannot read data from a pizzip instance, you probably are running new PizZip(zip) with a zipinstance");
        }
        if (input instanceof Date) {
          throw new Error("Cannot read data from a Date, you probably are running new PizZip(data) with a date");
        }
        if (_typeof2(input) === "object" && input.crc32 == null) {
          throw new Error("Unsupported data given to new PizZip(data) (object given)");
        }
      };
      exports2.checkSupport = function(type) {
        var supported = support2[type.toLowerCase()];
        if (!supported) {
          throw new Error(type + " is not supported by this browser");
        }
      };
      exports2.MAX_VALUE_16BITS = 65535;
      exports2.MAX_VALUE_32BITS = -1;
      exports2.pretty = function(str) {
        var res = "", code, i2;
        for (i2 = 0; i2 < (str || "").length; i2++) {
          code = str.charCodeAt(i2);
          res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
        }
        return res;
      };
      exports2.findCompression = function(compressionMethod) {
        for (var method in compressions2) {
          if (!compressions2.hasOwnProperty(method)) {
            continue;
          }
          if (compressions2[method].magic === compressionMethod) {
            return compressions2[method];
          }
        }
        return null;
      };
      exports2.isRegExp = function(object2) {
        return Object.prototype.toString.call(object2) === "[object RegExp]";
      };
      exports2.extend = function() {
        var result = {};
        var i2, attr;
        for (i2 = 0; i2 < arguments.length; i2++) {
          for (attr in arguments[i2]) {
            if (arguments[i2].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
              result[attr] = arguments[i2][attr];
            }
          }
        }
        return result;
      };
    })(utils$d);
    var utils$c = utils$d;
    var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    var crc32 = function crc322(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils$c.getTypeOf(input) !== "string";
      if (typeof crc == "undefined") {
        crc = 0;
      }
      var x2 = 0;
      var y2 = 0;
      var b2 = 0;
      crc ^= -1;
      for (var i2 = 0, iTop = input.length; i2 < iTop; i2++) {
        b2 = isArray ? input[i2] : input.charCodeAt(i2);
        y2 = (crc ^ b2) & 255;
        x2 = table[y2];
        crc = crc >>> 8 ^ x2;
      }
      return crc ^ -1;
    };
    var signature$1 = {};
    signature$1.LOCAL_FILE_HEADER = "PK";
    signature$1.CENTRAL_FILE_HEADER = "PK";
    signature$1.CENTRAL_DIRECTORY_END = "PK";
    signature$1.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    signature$1.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    signature$1.DATA_DESCRIPTOR = "PK\x07\b";
    var defaults$3 = {};
    defaults$3.base64 = false;
    defaults$3.binary = false;
    defaults$3.dir = false;
    defaults$3.createFolders = false;
    defaults$3.date = null;
    defaults$3.compression = null;
    defaults$3.compressionOptions = null;
    defaults$3.comment = null;
    defaults$3.unixPermissions = null;
    defaults$3.dosPermissions = null;
    function CompressedObject$2() {
      this.compressedSize = 0;
      this.uncompressedSize = 0;
      this.crc32 = 0;
      this.compressionMethod = null;
      this.compressedContent = null;
    }
    CompressedObject$2.prototype = {
      /**
       * Return the decompressed content in an unspecified format.
       * The format will depend on the decompressor.
       * @return {Object} the decompressed content.
       */
      getContent: function getContent() {
        return null;
      },
      /**
       * Return the compressed content in an unspecified format.
       * The format will depend on the compressed conten source.
       * @return {Object} the compressed content.
       */
      getCompressedContent: function getCompressedContent() {
        return null;
      }
    };
    var compressedObject = CompressedObject$2;
    var utf8$2 = {};
    var utils$b = utils$d;
    var support$3 = support$4;
    var nodeBuffer$1 = nodeBufferExports;
    var _utf8len = new Array(256);
    for (var i$1 = 0; i$1 < 256; i$1++) {
      _utf8len[i$1] = i$1 >= 252 ? 6 : i$1 >= 248 ? 5 : i$1 >= 240 ? 4 : i$1 >= 224 ? 3 : i$1 >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    function string2buf(str) {
      var buf, c2, c22, mPos, i2, bufLen = 0;
      var strLen = str.length;
      for (mPos = 0; mPos < strLen; mPos++) {
        c2 = str.charCodeAt(mPos);
        if ((c2 & 64512) === 55296 && mPos + 1 < strLen) {
          c22 = str.charCodeAt(mPos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            mPos++;
          }
        }
        bufLen += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      if (support$3.uint8array) {
        buf = new Uint8Array(bufLen);
      } else {
        buf = new Array(bufLen);
      }
      for (i2 = 0, mPos = 0; i2 < bufLen; mPos++) {
        c2 = str.charCodeAt(mPos);
        if ((c2 & 64512) === 55296 && mPos + 1 < strLen) {
          c22 = str.charCodeAt(mPos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            mPos++;
          }
        }
        if (c2 < 128) {
          buf[i2++] = c2;
        } else if (c2 < 2048) {
          buf[i2++] = 192 | c2 >>> 6;
          buf[i2++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i2++] = 224 | c2 >>> 12;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        } else {
          buf[i2++] = 240 | c2 >>> 18;
          buf[i2++] = 128 | c2 >>> 12 & 63;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        }
      }
      return buf;
    }
    function utf8border(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    }
    function buf2string(buf) {
      var i2, out2, c2, cLen;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out2 = 0, i2 = 0; i2 < len; ) {
        c2 = buf[i2++];
        if (c2 < 128) {
          utf16buf[out2++] = c2;
          continue;
        }
        cLen = _utf8len[c2];
        if (cLen > 4) {
          utf16buf[out2++] = 65533;
          i2 += cLen - 1;
          continue;
        }
        c2 &= cLen === 2 ? 31 : cLen === 3 ? 15 : 7;
        while (cLen > 1 && i2 < len) {
          c2 = c2 << 6 | buf[i2++] & 63;
          cLen--;
        }
        if (cLen > 1) {
          utf16buf[out2++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out2++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out2++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out2++] = 56320 | c2 & 1023;
        }
      }
      if (utf16buf.length !== out2) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out2);
        } else {
          utf16buf.length = out2;
        }
      }
      return utils$b.applyFromCharCode(utf16buf);
    }
    utf8$2.utf8encode = function utf8encode(str) {
      if (support$3.nodebuffer) {
        return nodeBuffer$1(str, "utf-8");
      }
      return string2buf(str);
    };
    utf8$2.utf8decode = function utf8decode(buf) {
      if (support$3.nodebuffer) {
        return utils$b.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils$b.transformTo(support$3.uint8array ? "uint8array" : "array", buf);
      var result = [], len = buf.length, chunk = 65536;
      var k2 = 0;
      while (k2 < len) {
        var nextBoundary = utf8border(buf, Math.min(k2 + chunk, len));
        if (support$3.uint8array) {
          result.push(buf2string(buf.subarray(k2, nextBoundary)));
        } else {
          result.push(buf2string(buf.slice(k2, nextBoundary)));
        }
        k2 = nextBoundary;
      }
      return result.join("");
    };
    var utils$a = utils$d;
    function StringWriter$1() {
      this.data = [];
    }
    StringWriter$1.prototype = {
      /**
       * Append any content to the current string.
       * @param {Object} input the content to add.
       */
      append: function append2(input) {
        input = utils$a.transformTo("string", input);
        this.data.push(input);
      },
      /**
       * Finalize the construction an return the result.
       * @return {string} the generated string.
       */
      finalize: function finalize() {
        return this.data.join("");
      }
    };
    var stringWriter = StringWriter$1;
    var utils$9 = utils$d;
    function Uint8ArrayWriter$1(length2) {
      this.data = new Uint8Array(length2);
      this.index = 0;
    }
    Uint8ArrayWriter$1.prototype = {
      /**
       * Append any content to the current array.
       * @param {Object} input the content to add.
       */
      append: function append2(input) {
        if (input.length !== 0) {
          input = utils$9.transformTo("uint8array", input);
          this.data.set(input, this.index);
          this.index += input.length;
        }
      },
      /**
       * Finalize the construction an return the result.
       * @return {Uint8Array} the generated array.
       */
      finalize: function finalize() {
        return this.data;
      }
    };
    var uint8ArrayWriter = Uint8ArrayWriter$1;
    var support$2 = support$4;
    var utils$8 = utils$d;
    var _crc = crc32;
    var signature = signature$1;
    var defaults$2 = defaults$3;
    var base64$2 = base64$3;
    var compressions = compressions$1;
    var CompressedObject$1 = compressedObject;
    var nodeBuffer = nodeBufferExports;
    var utf8$1 = utf8$2;
    var StringWriter = stringWriter;
    var Uint8ArrayWriter = uint8ArrayWriter;
    function getRawData(file2) {
      if (file2._data instanceof CompressedObject$1) {
        file2._data = file2._data.getContent();
        file2.options.binary = true;
        file2.options.base64 = false;
        if (utils$8.getTypeOf(file2._data) === "uint8array") {
          var copy2 = file2._data;
          file2._data = new Uint8Array(copy2.length);
          if (copy2.length !== 0) {
            file2._data.set(copy2, 0);
          }
        }
      }
      return file2._data;
    }
    function getBinaryData(file2) {
      var result = getRawData(file2), type = utils$8.getTypeOf(result);
      if (type === "string") {
        if (!file2.options.binary) {
          if (support$2.nodebuffer) {
            return nodeBuffer(result, "utf-8");
          }
        }
        return file2.asBinary();
      }
      return result;
    }
    var out = {
      /**
       * Read an existing zip and merge the data in the current PizZip object.
       * The implementation is in pizzip-load.js, don't forget to include it.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load
       * @param {Object} options Options for loading the stream.
       *  options.base64 : is the stream in base64 ? default : false
       * @return {PizZip} the current PizZip object
       */
      load: function load2() {
        throw new Error("Load method is not defined. Is the file pizzip-load.js included ?");
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function filter(search) {
        var result = [];
        var filename, relativePath, file2, fileClone;
        for (filename in this.files) {
          if (!this.files.hasOwnProperty(filename)) {
            continue;
          }
          file2 = this.files[filename];
          fileClone = new ZipObject(file2.name, file2._data, utils$8.extend(file2.options));
          relativePath = filename.slice(this.root.length, filename.length);
          if (filename.slice(0, this.root.length) === this.root && // the file is in the current root
          search(relativePath, fileClone)) {
            result.push(fileClone);
          }
        }
        return result;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {PizZip|Object|Array} this PizZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function file2(name, data, o2) {
        if (arguments.length === 1) {
          if (utils$8.isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file3) {
              return !file3.dir && regexp.test(relativePath);
            });
          }
          return this.filter(function(relativePath, file3) {
            return !file3.dir && relativePath === name;
          })[0] || null;
        }
        name = this.root + name;
        fileAdd.call(this, name, data, o2);
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {PizZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function folder(arg) {
        if (!arg) {
          return this;
        }
        if (utils$8.isRegExp(arg)) {
          return this.filter(function(relativePath, file2) {
            return file2.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.shallowClone();
        ret.root = newFolder.name;
        return ret;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {PizZip} this PizZip object
       */
      remove: function remove(name) {
        name = this.root + name;
        var file2 = this.files[name];
        if (!file2) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file2 = this.files[name];
        }
        if (file2 && !file2.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file3) {
            return file3.name.slice(0, name.length) === name;
          });
          for (var i2 = 0; i2 < kids.length; i2++) {
            delete this.files[kids[i2].name];
          }
        }
        return this;
      },
      /**
       * Generate the complete zip file
       * @param {Object} options the options to generate the zip file :
       * - base64, (deprecated, use type instead) true to generate base64.
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
       */
      generate: function generate(options) {
        options = utils$8.extend(options || {}, {
          base64: true,
          compression: "STORE",
          compressionOptions: null,
          type: "base64",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf8$1.utf8encode
        });
        utils$8.checkSupport(options.type);
        if (options.platform === "darwin" || options.platform === "freebsd" || options.platform === "linux" || options.platform === "sunos") {
          options.platform = "UNIX";
        }
        if (options.platform === "win32") {
          options.platform = "DOS";
        }
        var zipData = [], encodedComment = utils$8.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));
        var localDirLength = 0, centralDirLength = 0, writer, i2;
        for (var name in this.files) {
          if (!this.files.hasOwnProperty(name)) {
            continue;
          }
          var file2 = this.files[name];
          var compressionName = file2.options.compression || options.compression.toUpperCase();
          var compression = compressions[compressionName];
          if (!compression) {
            throw new Error(compressionName + " is not a valid compression method !");
          }
          var compressionOptions = file2.options.compressionOptions || options.compressionOptions || {};
          var compressedObject2 = generateCompressedObjectFrom.call(this, file2, compression, compressionOptions);
          var zipPart = generateZipParts.call(this, name, file2, compressedObject2, localDirLength, options.platform, options.encodeFileName);
          localDirLength += zipPart.fileRecord.length + compressedObject2.compressedSize;
          centralDirLength += zipPart.dirRecord.length;
          zipData.push(zipPart);
        }
        var dirEnd = "";
        dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        decToHex(zipData.length, 2) + // total number of entries in the central directory
        decToHex(zipData.length, 2) + // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) + // .ZIP file comment length
        decToHex(encodedComment.length, 2) + // .ZIP file comment
        encodedComment;
        var typeName = options.type.toLowerCase();
        if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
          writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
        } else {
          writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
        }
        for (i2 = 0; i2 < zipData.length; i2++) {
          writer.append(zipData[i2].fileRecord);
          writer.append(zipData[i2].compressedObject.compressedContent);
        }
        for (i2 = 0; i2 < zipData.length; i2++) {
          writer.append(zipData[i2].dirRecord);
        }
        writer.append(dirEnd);
        var zip = writer.finalize();
        switch (options.type.toLowerCase()) {
          case "uint8array":
          case "arraybuffer":
          case "nodebuffer":
            return utils$8.transformTo(options.type.toLowerCase(), zip);
          case "blob":
            return utils$8.arrayBuffer2Blob(utils$8.transformTo("arraybuffer", zip), options.mimeType);
          case "base64":
            return options.base64 ? base64$2.encode(zip) : zip;
          default:
            return zip;
        }
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      crc32: function crc322(input, crc) {
        return _crc(input, crc);
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      utf8encode: function utf8encode(string) {
        return utils$8.transformTo("string", utf8$1.utf8encode(string));
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      utf8decode: function utf8decode(input) {
        return utf8$1.utf8decode(input);
      }
    };
    function dataToString(asUTF8) {
      var result = getRawData(this);
      if (result === null || typeof result === "undefined") {
        return "";
      }
      if (this.options.base64) {
        result = base64$2.decode(result);
      }
      if (asUTF8 && this.options.binary) {
        result = out.utf8decode(result);
      } else {
        result = utils$8.transformTo("string", result);
      }
      if (!asUTF8 && !this.options.binary) {
        result = utils$8.transformTo("string", out.utf8encode(result));
      }
      return result;
    }
    function ZipObject(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this.options = options;
      this._initialMetadata = {
        dir: options.dir,
        date: options.date
      };
    }
    ZipObject.prototype = {
      /**
       * Return the content as UTF8 string.
       * @return {string} the UTF8 string.
       */
      asText: function asText() {
        return dataToString.call(this, true);
      },
      /**
       * Returns the binary content.
       * @return {string} the content as binary.
       */
      asBinary: function asBinary() {
        return dataToString.call(this, false);
      },
      /**
       * Returns the content as a nodejs Buffer.
       * @return {Buffer} the content as a Buffer.
       */
      asNodeBuffer: function asNodeBuffer() {
        var result = getBinaryData(this);
        return utils$8.transformTo("nodebuffer", result);
      },
      /**
       * Returns the content as an Uint8Array.
       * @return {Uint8Array} the content as an Uint8Array.
       */
      asUint8Array: function asUint8Array() {
        var result = getBinaryData(this);
        return utils$8.transformTo("uint8array", result);
      },
      /**
       * Returns the content as an ArrayBuffer.
       * @return {ArrayBuffer} the content as an ArrayBufer.
       */
      asArrayBuffer: function asArrayBuffer() {
        return this.asUint8Array().buffer;
      }
    };
    function decToHex(dec, bytes) {
      var hex = "", i2;
      for (i2 = 0; i2 < bytes; i2++) {
        hex += String.fromCharCode(dec & 255);
        dec >>>= 8;
      }
      return hex;
    }
    function prepareFileAttrs(o2) {
      o2 = o2 || {};
      if (o2.base64 === true && (o2.binary === null || o2.binary === void 0)) {
        o2.binary = true;
      }
      o2 = utils$8.extend(o2, defaults$2);
      o2.date = o2.date || /* @__PURE__ */ new Date();
      if (o2.compression !== null) {
        o2.compression = o2.compression.toUpperCase();
      }
      return o2;
    }
    function fileAdd(name, data, o2) {
      var dataType = utils$8.getTypeOf(data), parent;
      o2 = prepareFileAttrs(o2);
      if (typeof o2.unixPermissions === "string") {
        o2.unixPermissions = parseInt(o2.unixPermissions, 8);
      }
      if (o2.unixPermissions && o2.unixPermissions & 16384) {
        o2.dir = true;
      }
      if (o2.dosPermissions && o2.dosPermissions & 16) {
        o2.dir = true;
      }
      if (o2.dir) {
        name = forceTrailingSlash(name);
      }
      if (o2.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      if (o2.dir || data === null || typeof data === "undefined") {
        o2.base64 = false;
        o2.binary = false;
        data = null;
        dataType = null;
      } else if (dataType === "string") {
        if (o2.binary && !o2.base64) {
          if (o2.optimizedBinaryString !== true) {
            data = utils$8.string2binary(data);
          }
        }
      } else {
        o2.base64 = false;
        o2.binary = true;
        if (!dataType && !(data instanceof CompressedObject$1)) {
          throw new Error("The data of '" + name + "' is in an unsupported format !");
        }
        if (dataType === "arraybuffer") {
          data = utils$8.transformTo("uint8array", data);
        }
      }
      var object2 = new ZipObject(name, data, o2);
      this.files[name] = object2;
      return object2;
    }
    function parentFolder(path) {
      if (path.slice(-1) === "/") {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf("/");
      return lastSlash > 0 ? path.substring(0, lastSlash) : "";
    }
    function forceTrailingSlash(path) {
      if (path.slice(-1) !== "/") {
        path += "/";
      }
      return path;
    }
    function folderAdd(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : false;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    }
    function generateCompressedObjectFrom(file2, compression, compressionOptions) {
      var result = new CompressedObject$1();
      var content;
      if (file2._data instanceof CompressedObject$1) {
        result.uncompressedSize = file2._data.uncompressedSize;
        result.crc32 = file2._data.crc32;
        if (result.uncompressedSize === 0 || file2.dir) {
          compression = compressions.STORE;
          result.compressedContent = "";
          result.crc32 = 0;
        } else if (file2._data.compressionMethod === compression.magic) {
          result.compressedContent = file2._data.getCompressedContent();
        } else {
          content = file2._data.getContent();
          result.compressedContent = compression.compress(utils$8.transformTo(compression.compressInputType, content), compressionOptions);
        }
      } else {
        content = getBinaryData(file2);
        if (!content || content.length === 0 || file2.dir) {
          compression = compressions.STORE;
          content = "";
        }
        result.uncompressedSize = content.length;
        result.crc32 = _crc(content);
        result.compressedContent = compression.compress(utils$8.transformTo(compression.compressInputType, content), compressionOptions);
      }
      result.compressedSize = result.compressedContent.length;
      result.compressionMethod = compression.magic;
      return result;
    }
    function generateUnixExternalFileAttr(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 16893 : 33204;
      }
      return (result & 65535) << 16;
    }
    function generateDosExternalFileAttr(dosPermissions) {
      return (dosPermissions || 0) & 63;
    }
    function generateZipParts(name, file2, compressedObject2, offset, platform, encodeFileName) {
      var useCustomEncoding = encodeFileName !== utf8$1.utf8encode, encodedFileName = utils$8.transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = utils$8.transformTo("string", utf8$1.utf8encode(file2.name)), comment2 = file2.comment || "", encodedComment = utils$8.transformTo("string", encodeFileName(comment2)), utfEncodedComment = utils$8.transformTo("string", utf8$1.utf8encode(comment2)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment2.length, o2 = file2.options;
      var dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir, date;
      if (file2._initialMetadata.dir !== file2.dir) {
        dir = file2.dir;
      } else {
        dir = o2.dir;
      }
      if (file2._initialMetadata.date !== file2.date) {
        date = file2.date;
      } else {
        date = o2.date;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions);
      }
      dosTime = date.getHours();
      dosTime <<= 6;
      dosTime |= date.getMinutes();
      dosTime <<= 5;
      dosTime |= date.getSeconds() / 2;
      dosDate = date.getFullYear() - 1980;
      dosDate <<= 4;
      dosDate |= date.getMonth() + 1;
      dosDate <<= 5;
      dosDate |= date.getDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(_crc(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(this.crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\0\b" : "\0\0";
      header += compressedObject2.compressionMethod;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(compressedObject2.crc32, 4);
      header += decToHex(compressedObject2.compressedSize, 4);
      header += decToHex(compressedObject2.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord,
        compressedObject: compressedObject2
      };
    }
    var object = out;
    var utils$7 = utils$d;
    function DataReader$2() {
      this.data = null;
      this.length = 0;
      this.index = 0;
      this.zero = 0;
    }
    DataReader$2.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function checkOffset(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specifed index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function checkIndex(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function setIndex(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function skip(n2) {
        this.setIndex(this.index + n2);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function byteAt() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function readInt(size) {
        var result = 0, i2;
        this.checkOffset(size);
        for (i2 = this.index + size - 1; i2 >= this.index; i2--) {
          result = (result << 8) + this.byteAt(i2);
        }
        this.index += size;
        return result;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function readString(size) {
        return utils$7.transformTo("string", this.readData(size));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function readData() {
      },
      /**
       * Find the last occurence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurence, -1 if not found.
       */
      lastIndexOfSignature: function lastIndexOfSignature() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function readDate() {
        var dostime = this.readInt(4);
        return new Date(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        );
      }
    };
    var dataReader = DataReader$2;
    var DataReader$1 = dataReader;
    var utils$6 = utils$d;
    function StringReader$2(data, optimizedBinaryString) {
      this.data = data;
      if (!optimizedBinaryString) {
        this.data = utils$6.string2binary(this.data);
      }
      this.length = this.data.length;
      this.index = 0;
      this.zero = 0;
    }
    StringReader$2.prototype = new DataReader$1();
    StringReader$2.prototype.byteAt = function(i2) {
      return this.data.charCodeAt(this.zero + i2);
    };
    StringReader$2.prototype.lastIndexOfSignature = function(sig2) {
      return this.data.lastIndexOf(sig2) - this.zero;
    };
    StringReader$2.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    var stringReader = StringReader$2;
    var DataReader = dataReader;
    function ArrayReader$2(data) {
      if (data) {
        this.data = data;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
        for (var i2 = 0; i2 < this.data.length; i2++) {
          data[i2] &= data[i2];
        }
      }
    }
    ArrayReader$2.prototype = new DataReader();
    ArrayReader$2.prototype.byteAt = function(i2) {
      return this.data[this.zero + i2];
    };
    ArrayReader$2.prototype.lastIndexOfSignature = function(sig2) {
      var sig0 = sig2.charCodeAt(0), sig1 = sig2.charCodeAt(1), sig22 = sig2.charCodeAt(2), sig3 = sig2.charCodeAt(3);
      for (var i2 = this.length - 4; i2 >= 0; --i2) {
        if (this.data[i2] === sig0 && this.data[i2 + 1] === sig1 && this.data[i2 + 2] === sig22 && this.data[i2 + 3] === sig3) {
          return i2 - this.zero;
        }
      }
      return -1;
    };
    ArrayReader$2.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    var arrayReader = ArrayReader$2;
    var ArrayReader$1 = arrayReader;
    function Uint8ArrayReader$2(data) {
      if (data) {
        this.data = data;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
      }
    }
    Uint8ArrayReader$2.prototype = new ArrayReader$1();
    Uint8ArrayReader$2.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    var uint8ArrayReader = Uint8ArrayReader$2;
    var Uint8ArrayReader$1 = uint8ArrayReader;
    function NodeBufferReader$1(data) {
      this.data = data;
      this.length = this.data.length;
      this.index = 0;
      this.zero = 0;
    }
    NodeBufferReader$1.prototype = new Uint8ArrayReader$1();
    NodeBufferReader$1.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    var nodeBufferReader = NodeBufferReader$1;
    var StringReader$1 = stringReader;
    var utils$5 = utils$d;
    var CompressedObject = compressedObject;
    var pizzipProto = object;
    var support$1 = support$4;
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    function ZipEntry$1(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry$1.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function isEncrypted() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function useUTF8() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Prepare the function used to generate the compressed content from this ZipFile.
       * @param {DataReader} reader the reader to use.
       * @param {number} from the offset from where we should read the data.
       * @param {number} length the length of the data to read.
       * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).
       */
      prepareCompressedContent: function prepareCompressedContent(reader, from2, length2) {
        return function() {
          var previousIndex = reader.index;
          reader.setIndex(from2);
          var compressedFileData = reader.readData(length2);
          reader.setIndex(previousIndex);
          return compressedFileData;
        };
      },
      /**
       * Prepare the function used to generate the uncompressed content from this ZipFile.
       * @param {DataReader} reader the reader to use.
       * @param {number} from the offset from where we should read the data.
       * @param {number} length the length of the data to read.
       * @param {PizZip.compression} compression the compression used on this file.
       * @param {number} uncompressedSize the uncompressed size to expect.
       * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).
       */
      prepareContent: function prepareContent(reader, from2, length2, compression, uncompressedSize) {
        return function() {
          var compressedFileData = utils$5.transformTo(compression.uncompressInputType, this.getCompressedContent());
          var uncompressedFileData = compression.uncompress(compressedFileData);
          if (uncompressedFileData.length !== uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
          return uncompressedFileData;
        };
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function readLocalPart(reader) {
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        var localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");
        }
        var compression = utils$5.findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils$5.pretty(this.compressionMethod) + " unknown (inner file : " + utils$5.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject();
        this.decompressed.compressedSize = this.compressedSize;
        this.decompressed.uncompressedSize = this.uncompressedSize;
        this.decompressed.crc32 = this.crc32;
        this.decompressed.compressionMethod = this.compressionMethod;
        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
        if (this.loadOptions.checkCRC32) {
          this.decompressed = utils$5.transformTo("string", this.decompressed.getContent());
          if (pizzipProto.crc32(this.decompressed) !== this.crc32) {
            throw new Error("Corrupted zip : CRC32 mismatch");
          }
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function readCentralPart(reader) {
        this.versionMadeBy = reader.readInt(2);
        this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        this.fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        this.fileName = reader.readData(this.fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function processAttributes() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = !!(this.externalFileAttributes & 16);
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       */
      parseZIP64ExtraField: function parseZIP64ExtraField() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = new StringReader$1(this.extraFields[1].value);
        if (this.uncompressedSize === utils$5.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils$5.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils$5.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils$5.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function readExtraFields(reader) {
        var start = reader.index;
        var extraFieldId, extraFieldLength, extraFieldValue;
        this.extraFields = this.extraFields || {};
        while (reader.index < start + this.extraFieldsLength) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readString(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function handleUTF8() {
        var decodeParamType = support$1.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = pizzipProto.utf8decode(this.fileName);
          this.fileCommentStr = pizzipProto.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils$5.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils$5.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = new StringReader$1(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (pizzipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return pizzipProto.utf8decode(extraReader.readString(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = new StringReader$1(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (pizzipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return pizzipProto.utf8decode(extraReader.readString(ucommentField.length - 5));
        }
        return null;
      }
    };
    var zipEntry = ZipEntry$1;
    var StringReader = stringReader;
    var NodeBufferReader = nodeBufferReader;
    var Uint8ArrayReader = uint8ArrayReader;
    var ArrayReader = arrayReader;
    var utils$4 = utils$d;
    var sig = signature$1;
    var ZipEntry = zipEntry;
    var support = support$4;
    function ZipEntries$1(data, loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
      if (data) {
        this.load(data);
      }
    }
    ZipEntries$1.prototype = {
      /**
       * Check that the reader is on the speficied signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function checkSignature(expectedSignature) {
        var signature2 = this.reader.readString(4);
        if (signature2 !== expectedSignature) {
          throw new Error("Corrupted zip or bug : unexpected signature (" + utils$4.pretty(signature2) + ", expected " + utils$4.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function isSignature(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature2 = this.reader.readString(4);
        var result = signature2 === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function readBlockEndOfCentral() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils$4.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.versionMadeBy = this.reader.readString(2);
        this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44;
        var index2 = 0;
        var extraFieldId, extraFieldLength, extraFieldValue;
        while (index2 < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readString(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function readLocalFiles() {
        var i2, file2;
        for (i2 = 0; i2 < this.files.length; i2++) {
          file2 = this.files[i2];
          this.reader.setIndex(file2.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file2.readLocalPart(this.reader);
          file2.handleUTF8();
          file2.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function readCentralDir() {
        var file2;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
          file2 = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file2.readCentralPart(this.reader);
          this.files.push(file2);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function readEndOfCentral() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ?");
          } else {
            throw new Error("Corrupted zip : can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils$4.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils$4.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils$4.MAX_VALUE_16BITS || this.centralDirRecords === utils$4.MAX_VALUE_16BITS || this.centralDirSize === utils$4.MAX_VALUE_32BITS || this.centralDirOffset === utils$4.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER))
            ;
          else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function prepareReader(data) {
        var type = utils$4.getTypeOf(data);
        utils$4.checkSupport(type);
        if (type === "string" && !support.uint8array) {
          this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);
        } else if (type === "nodebuffer") {
          this.reader = new NodeBufferReader(data);
        } else if (support.uint8array) {
          this.reader = new Uint8ArrayReader(utils$4.transformTo("uint8array", data));
        } else if (support.array) {
          this.reader = new ArrayReader(utils$4.transformTo("array", data));
        } else {
          throw new Error("Unexpected error: unsupported type '" + type + "'");
        }
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function load2(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    var zipEntries = ZipEntries$1;
    var base64$1 = base64$3;
    var utf8 = utf8$2;
    var utils$3 = utils$d;
    var ZipEntries = zipEntries;
    var load = function(data, options) {
      var i2, input;
      options = utils$3.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (options.base64) {
        data = base64$1.decode(data);
      }
      var zipEntries2 = new ZipEntries(data, options);
      var files = zipEntries2.files;
      for (i2 = 0; i2 < files.length; i2++) {
        input = files[i2];
        this.file(input.fileNameStr, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
      }
      if (zipEntries2.zipComment.length) {
        this.comment = zipEntries2.zipComment;
      }
      return this;
    };
    var deprecatedPublicUtils = {};
    var utils$2 = utils$d;
    deprecatedPublicUtils.string2binary = function(str) {
      return utils$2.string2binary(str);
    };
    deprecatedPublicUtils.string2Uint8Array = function(str) {
      return utils$2.transformTo("uint8array", str);
    };
    deprecatedPublicUtils.uint8Array2String = function(array) {
      return utils$2.transformTo("string", array);
    };
    deprecatedPublicUtils.string2Blob = function(str) {
      var buffer2 = utils$2.transformTo("arraybuffer", str);
      return utils$2.arrayBuffer2Blob(buffer2);
    };
    deprecatedPublicUtils.arrayBuffer2Blob = function(buffer2) {
      return utils$2.arrayBuffer2Blob(buffer2);
    };
    deprecatedPublicUtils.transformTo = function(outputType, input) {
      return utils$2.transformTo(outputType, input);
    };
    deprecatedPublicUtils.getTypeOf = function(input) {
      return utils$2.getTypeOf(input);
    };
    deprecatedPublicUtils.checkSupport = function(type) {
      return utils$2.checkSupport(type);
    };
    deprecatedPublicUtils.MAX_VALUE_16BITS = utils$2.MAX_VALUE_16BITS;
    deprecatedPublicUtils.MAX_VALUE_32BITS = utils$2.MAX_VALUE_32BITS;
    deprecatedPublicUtils.pretty = function(str) {
      return utils$2.pretty(str);
    };
    deprecatedPublicUtils.findCompression = function(compressionMethod) {
      return utils$2.findCompression(compressionMethod);
    };
    deprecatedPublicUtils.isRegExp = function(object2) {
      return utils$2.isRegExp(object2);
    };
    var base64 = base64$3;
    function PizZip(data, options) {
      if (!(this instanceof PizZip)) {
        return new PizZip(data, options);
      }
      this.files = {};
      this.comment = null;
      this.root = "";
      if (data) {
        this.load(data, options);
      }
      this.clone = function() {
        var _this = this;
        var newObj = new PizZip();
        Object.keys(this.files).forEach(function(file2) {
          newObj.file(file2, _this.files[file2].asUint8Array());
        });
        return newObj;
      };
      this.shallowClone = function() {
        var newObj = new PizZip();
        for (var i2 in this) {
          if (typeof this[i2] !== "function") {
            newObj[i2] = this[i2];
          }
        }
        return newObj;
      };
    }
    PizZip.prototype = object;
    PizZip.prototype.load = load;
    PizZip.support = support$4;
    PizZip.defaults = defaults$3;
    PizZip.utils = deprecatedPublicUtils;
    PizZip.base64 = {
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      encode: function encode(input) {
        return base64.encode(input);
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      decode: function decode(input) {
        return base64.decode(input);
      }
    };
    PizZip.compressions = compressions$1;
    var js = PizZip;
    const PizZip$1 = /* @__PURE__ */ getDefaultExportFromCjs(js);
    var FileSaver_min = { exports: {} };
    (function(module2, exports2) {
      (function(a2, b2) {
        b2();
      })(commonjsGlobal, function() {
        function b2(a3, b3) {
          return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
        }
        function c2(a3, b3, c3) {
          var d3 = new XMLHttpRequest();
          d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
            g2(d3.response, b3, c3);
          }, d3.onerror = function() {
            console.error("could not download file");
          }, d3.send();
        }
        function d2(a3) {
          var b3 = new XMLHttpRequest();
          b3.open("HEAD", a3, false);
          try {
            b3.send();
          } catch (a4) {
          }
          return 200 <= b3.status && 299 >= b3.status;
        }
        function e2(a3) {
          try {
            a3.dispatchEvent(new MouseEvent("click"));
          } catch (c3) {
            var b3 = document.createEvent("MouseEvents");
            b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
          }
        }
        var f2 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || ("object" != typeof window || window !== f2 ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
          var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
          g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", "string" == typeof b3 ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d2(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
            i2.revokeObjectURL(j2.href);
          }, 4e4), setTimeout(function() {
            e2(j2);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
          if (g3 = g3 || f3.name || "download", "string" != typeof f3)
            navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
          else if (d2(f3))
            c2(f3, g3, h2);
          else {
            var i2 = document.createElement("a");
            i2.href = f3, i2.target = "_blank", setTimeout(function() {
              e2(i2);
            });
          }
        } : function(b3, d3, e3, g3) {
          if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), "string" == typeof b3)
            return c2(b3, d3, e3);
          var h2 = "application/octet-stream" === b3.type, i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j2 || h2 && i2 || a2) && "undefined" != typeof FileReader) {
            var k2 = new FileReader();
            k2.onloadend = function() {
              var a3 = k2.result;
              a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
            }, k2.readAsDataURL(b3);
          } else {
            var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
            g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
              l2.revokeObjectURL(m2);
            }, 4e4);
          }
        });
        f2.saveAs = g2.saveAs = g2, module2.exports = g2;
      });
    })(FileSaver_min);
    var FileSaver_minExports = FileSaver_min.exports;
    var lib = {};
    var dom$2 = {};
    var conventions$2 = {};
    function find$2(list, predicate, ac2) {
      if (ac2 === void 0) {
        ac2 = Array.prototype;
      }
      if (list && typeof ac2.find === "function") {
        return ac2.find.call(list, predicate);
      }
      for (var i2 = 0; i2 < list.length; i2++) {
        if (Object.prototype.hasOwnProperty.call(list, i2)) {
          var item = list[i2];
          if (predicate.call(void 0, item, i2, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object2, oc2) {
      if (oc2 === void 0) {
        oc2 = Object;
      }
      return oc2 && typeof oc2.freeze === "function" ? oc2.freeze(object2) : object2;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE$3 = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE$3.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    conventions$2.assign = assign;
    conventions$2.find = find$2;
    conventions$2.freeze = freeze;
    conventions$2.MIME_TYPE = MIME_TYPE;
    conventions$2.NAMESPACE = NAMESPACE$3;
    var conventions$1 = conventions$2;
    var find$1 = conventions$1.find;
    var NAMESPACE$2 = conventions$1.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input)
        return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p2 in src) {
        if (Object.prototype.hasOwnProperty.call(src, p2)) {
          dest[p2] = src[p2];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t3 = function() {
        };
        var t2 = t3;
        t3.prototype = Super.prototype;
        t3 = new t3();
        copy(pt, t3);
        Class.prototype = pt = t3;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message)
        this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index2) {
        return index2 >= 0 && index2 < this.length ? this[index2] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i2 = 0; i2 < this.length; i2++) {
          serializeToString(this[i2], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node2, refresh) {
      this._node = node2;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i2 = ls.length; i2 in list; i2++) {
            if (Object.prototype.hasOwnProperty.call(list, i2)) {
              delete list[i2];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i2) {
      _updateLiveList(this);
      return this[i2] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node2) {
      var i2 = list.length;
      while (i2--) {
        if (list[i2] === node2) {
          return i2;
        }
      }
    }
    function _addNamedNode(el2, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el2) {
        newAttr.ownerElement = el2;
        var doc = el2.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el2, oldAttr);
          _onAddAttribute(doc, el2, newAttr);
        }
      }
    }
    function _removeNamedNode(el2, list, attr) {
      var i2 = _findNodeIndex(list, attr);
      if (i2 >= 0) {
        var lastIndex = list.length - 1;
        while (i2 < lastIndex) {
          list[i2] = list[++i2];
        }
        list.length = lastIndex;
        if (el2) {
          var doc = el2.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el2, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el2.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i2 = this.length;
        while (i2--) {
          var attr = this[i2];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el2 = attr.ownerElement;
        if (el2 && el2 != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el2 = attr.ownerElement, oldAttr;
        if (el2 && el2 != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i2 = this.length;
        while (i2--) {
          var node2 = this[i2];
          if (node2.localName == localName && node2.namespaceURI == namespaceURI) {
            return node2;
          }
        }
        return null;
      }
    };
    function DOMImplementation$1() {
    }
    DOMImplementation$1.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node2 = new DocumentType();
        node2.name = qualifiedName;
        node2.nodeName = qualifiedName;
        node2.publicId = publicId || "";
        node2.systemId = systemId || "";
        return node2;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next2 = child.nextSibling;
          if (next2 && next2.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next2);
            child.appendData(next2.data);
          } else {
            child.normalize();
            child = next2;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el2 = this;
        while (el2) {
          var map = el2._nsMap;
          if (map) {
            for (var n2 in map) {
              if (Object.prototype.hasOwnProperty.call(map, n2) && map[n2] === namespaceURI) {
                return n2;
              }
            }
          }
          el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix2) {
        var el2 = this;
        while (el2) {
          var map = el2._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix2)) {
              return map[prefix2];
            }
          }
          el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix2 = this.lookupPrefix(namespaceURI);
        return prefix2 == null;
      }
    };
    function _xmlEncoder(c2) {
      return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node2, callback) {
      if (callback(node2)) {
        return true;
      }
      if (node2 = node2.firstChild) {
        do {
          if (_visitNode(node2, callback)) {
            return true;
          }
        } while (node2 = node2.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el2, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE$2.XMLNS) {
        el2._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el2, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE$2.XMLNS) {
        delete el2._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el2, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el2.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el2.firstChild;
          var i2 = 0;
          while (child) {
            cs[i2++] = child;
            child = child.nextSibling;
          }
          cs.length = i2;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next2 = child.nextSibling;
      if (previous) {
        previous.nextSibling = next2;
      } else {
        parentNode.firstChild = next2;
      }
      if (next2) {
        next2.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node2) {
      return node2 && (node2.nodeType === Node.DOCUMENT_NODE || node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node2.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node2) {
      return node2 && (isElementNode(node2) || isTextNode(node2) || isDocTypeNode(node2) || node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node2.nodeType === Node.COMMENT_NODE || node2.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node2) {
      return node2 && node2.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node2) {
      return node2 && node2.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node2) {
      return node2 && node2.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find$1(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find$1(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node2) {
        return isElementNode(node2) && node2 !== child;
      }
      if (find$1(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find$1(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node2, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node2) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node2) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node2.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node2, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node2.childNodes || [];
      if (node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find$1(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node2)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node2)) {
        if (find$1(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find$1(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node2, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node2.childNodes || [];
      if (node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find$1(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node2)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node2)) {
        let hasDoctypeChildThatIsNotChild2 = function(node3) {
          return isDocTypeNode(node3) && node3 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find$1(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find$1(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node2, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node2, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node2, child);
      }
      var cp = node2.parentNode;
      if (cp) {
        cp.removeChild(node2);
      }
      if (node2.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node2.firstChild;
        if (newFirst == null) {
          return node2;
        }
        var newLast = node2.lastChild;
      } else {
        newFirst = newLast = node2;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node2.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node2.firstChild = node2.lastChild = null;
      }
      return node2;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next2 = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next2;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id2) {
        var rtv = null;
        _visitNode(this.documentElement, function(node2) {
          if (node2.nodeType == ELEMENT_NODE) {
            if (node2.getAttribute("id") == id2) {
              rtv = node2;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node2) {
              if (node2 !== base && node2.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node2.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node2);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node2 = new Element();
        node2.ownerDocument = this;
        node2.nodeName = tagName;
        node2.tagName = tagName;
        node2.localName = tagName;
        node2.childNodes = new NodeList();
        var attrs = node2.attributes = new NamedNodeMap();
        attrs._ownerElement = node2;
        return node2;
      },
      createDocumentFragment: function() {
        var node2 = new DocumentFragment$1();
        node2.ownerDocument = this;
        node2.childNodes = new NodeList();
        return node2;
      },
      createTextNode: function(data) {
        var node2 = new Text();
        node2.ownerDocument = this;
        node2.appendData(data);
        return node2;
      },
      createComment: function(data) {
        var node2 = new Comment();
        node2.ownerDocument = this;
        node2.appendData(data);
        return node2;
      },
      createCDATASection: function(data) {
        var node2 = new CDATASection();
        node2.ownerDocument = this;
        node2.appendData(data);
        return node2;
      },
      createProcessingInstruction: function(target, data) {
        var node2 = new ProcessingInstruction();
        node2.ownerDocument = this;
        node2.tagName = node2.nodeName = node2.target = target;
        node2.nodeValue = node2.data = data;
        return node2;
      },
      createAttribute: function(name) {
        var node2 = new Attr();
        node2.ownerDocument = this;
        node2.name = name;
        node2.nodeName = name;
        node2.localName = name;
        node2.specified = true;
        return node2;
      },
      createEntityReference: function(name) {
        var node2 = new EntityReference();
        node2.ownerDocument = this;
        node2.nodeName = name;
        return node2;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node2 = new Element();
        var pl2 = qualifiedName.split(":");
        var attrs = node2.attributes = new NamedNodeMap();
        node2.childNodes = new NodeList();
        node2.ownerDocument = this;
        node2.nodeName = qualifiedName;
        node2.tagName = qualifiedName;
        node2.namespaceURI = namespaceURI;
        if (pl2.length == 2) {
          node2.prefix = pl2[0];
          node2.localName = pl2[1];
        } else {
          node2.localName = qualifiedName;
        }
        attrs._ownerElement = node2;
        return node2;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node2 = new Attr();
        var pl2 = qualifiedName.split(":");
        node2.ownerDocument = this;
        node2.nodeName = qualifiedName;
        node2.name = qualifiedName;
        node2.namespaceURI = namespaceURI;
        node2.specified = true;
        if (pl2.length == 2) {
          node2.prefix = pl2[0];
          node2.localName = pl2[1];
        } else {
          node2.localName = qualifiedName;
        }
        return node2;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node2) {
            if (node2 !== base && node2.nodeType == ELEMENT_NODE && (tagName === "*" || node2.tagName == tagName)) {
              ls.push(node2);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node2) {
            if (node2 !== base && node2.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node2.namespaceURI === namespaceURI) && (localName === "*" || node2.localName == localName)) {
              ls.push(node2);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment$1() {
    }
    DocumentFragment$1.prototype.nodeName = "#document-fragment";
    DocumentFragment$1.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment$1, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer$1() {
    }
    XMLSerializer$1.prototype.serializeToString = function(node2, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node2, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix2 = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix2 == null) {
        var prefix2 = refNode.lookupPrefix(uri);
        if (prefix2 == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node2, isHTML, visibleNamespaces) {
      var prefix2 = node2.prefix || "";
      var uri = node2.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix2 === "xml" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {
        return false;
      }
      var i2 = visibleNamespaces.length;
      while (i2--) {
        var ns = visibleNamespaces[i2];
        if (ns.prefix === prefix2) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node2, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node2 = nodeFilter(node2);
        if (node2) {
          if (typeof node2 == "string") {
            buf.push(node2);
            return;
          }
        } else {
          return;
        }
      }
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node2.attributes;
          var len = attrs.length;
          var child = node2.firstChild;
          var nodeName = node2.tagName;
          isHTML = NAMESPACE$2.isHTML(node2.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node2.prefix && node2.namespaceURI) {
            var defaultNS;
            for (var ai2 = 0; ai2 < attrs.length; ai2++) {
              if (attrs.item(ai2).name === "xmlns") {
                defaultNS = attrs.item(ai2).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node2.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node2.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node2.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i2 = 0; i2 < len; i2++) {
            var attr = attrs.item(i2);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i2 = 0; i2 < len; i2++) {
            var attr = attrs.item(i2);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix2 = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix2 ? "xmlns:" + prefix2 : "xmlns", uri);
              visibleNamespaces.push({ prefix: prefix2, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node2, isHTML, visibleNamespaces)) {
            var prefix2 = node2.prefix || "";
            var uri = node2.namespaceURI;
            addSerializedAttribute(buf, prefix2 ? "xmlns:" + prefix2 : "xmlns", uri);
            visibleNamespaces.push({ prefix: prefix2, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node2.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node2.name, node2.value);
        case TEXT_NODE:
          return buf.push(
            node2.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node2.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node2.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node2.publicId;
          var sysid = node2.systemId;
          buf.push("<!DOCTYPE ", node2.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node2.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node2.target, " ", node2.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node2.nodeName, ";");
        default:
          buf.push("??", node2.nodeName);
      }
    }
    function importNode(doc, node2, deep) {
      var node22;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          node22 = node2.cloneNode(false);
          node22.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node22) {
        node22 = node2.cloneNode(false);
      }
      node22.ownerDocument = doc;
      node22.parentNode = null;
      if (deep) {
        var child = node2.firstChild;
        while (child) {
          node22.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node22;
    }
    function cloneNode(doc, node2, deep) {
      var node22 = new node2.constructor();
      for (var n2 in node2) {
        if (Object.prototype.hasOwnProperty.call(node2, n2)) {
          var v2 = node2[n2];
          if (typeof v2 != "object") {
            if (v2 != node22[n2]) {
              node22[n2] = v2;
            }
          }
        }
      }
      if (node2.childNodes) {
        node22.childNodes = new NodeList();
      }
      node22.ownerDocument = doc;
      switch (node22.nodeType) {
        case ELEMENT_NODE:
          var attrs = node2.attributes;
          var attrs2 = node22.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node22;
          for (var i2 = 0; i2 < len; i2++) {
            node22.setAttributeNode(cloneNode(doc, attrs.item(i2), true));
          }
          break;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node2.firstChild;
        while (child) {
          node22.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node22;
    }
    function __set__(object2, key, value) {
      object2[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node2) {
          switch (node2.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node2 = node2.firstChild;
              while (node2) {
                if (node2.nodeType !== 7 && node2.nodeType !== 8) {
                  buf.push(getTextContent2(node2));
                }
                node2 = node2.nextSibling;
              }
              return buf.join("");
            default:
              return node2.nodeValue;
          }
        };
        var getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object2, key, value) {
          object2["$$" + key] = value;
        };
      }
    } catch (e2) {
    }
    dom$2.DocumentType = DocumentType;
    dom$2.DOMException = DOMException;
    dom$2.DOMImplementation = DOMImplementation$1;
    dom$2.Element = Element;
    dom$2.Node = Node;
    dom$2.NodeList = NodeList;
    dom$2.XMLSerializer = XMLSerializer$1;
    var domParser = {};
    var entities$1 = {};
    (function(exports2) {
      var freeze2 = conventions$2.freeze;
      exports2.XML_ENTITIES = freeze2({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"'
      });
      exports2.HTML_ENTITIES = freeze2({
        Aacute: "Á",
        aacute: "á",
        Abreve: "Ă",
        abreve: "ă",
        ac: "∾",
        acd: "∿",
        acE: "∾̳",
        Acirc: "Â",
        acirc: "â",
        acute: "´",
        Acy: "А",
        acy: "а",
        AElig: "Æ",
        aelig: "æ",
        af: "⁡",
        Afr: "𝔄",
        afr: "𝔞",
        Agrave: "À",
        agrave: "à",
        alefsym: "ℵ",
        aleph: "ℵ",
        Alpha: "Α",
        alpha: "α",
        Amacr: "Ā",
        amacr: "ā",
        amalg: "⨿",
        AMP: "&",
        amp: "&",
        And: "⩓",
        and: "∧",
        andand: "⩕",
        andd: "⩜",
        andslope: "⩘",
        andv: "⩚",
        ang: "∠",
        ange: "⦤",
        angle: "∠",
        angmsd: "∡",
        angmsdaa: "⦨",
        angmsdab: "⦩",
        angmsdac: "⦪",
        angmsdad: "⦫",
        angmsdae: "⦬",
        angmsdaf: "⦭",
        angmsdag: "⦮",
        angmsdah: "⦯",
        angrt: "∟",
        angrtvb: "⊾",
        angrtvbd: "⦝",
        angsph: "∢",
        angst: "Å",
        angzarr: "⍼",
        Aogon: "Ą",
        aogon: "ą",
        Aopf: "𝔸",
        aopf: "𝕒",
        ap: "≈",
        apacir: "⩯",
        apE: "⩰",
        ape: "≊",
        apid: "≋",
        apos: "'",
        ApplyFunction: "⁡",
        approx: "≈",
        approxeq: "≊",
        Aring: "Å",
        aring: "å",
        Ascr: "𝒜",
        ascr: "𝒶",
        Assign: "≔",
        ast: "*",
        asymp: "≈",
        asympeq: "≍",
        Atilde: "Ã",
        atilde: "ã",
        Auml: "Ä",
        auml: "ä",
        awconint: "∳",
        awint: "⨑",
        backcong: "≌",
        backepsilon: "϶",
        backprime: "‵",
        backsim: "∽",
        backsimeq: "⋍",
        Backslash: "∖",
        Barv: "⫧",
        barvee: "⊽",
        Barwed: "⌆",
        barwed: "⌅",
        barwedge: "⌅",
        bbrk: "⎵",
        bbrktbrk: "⎶",
        bcong: "≌",
        Bcy: "Б",
        bcy: "б",
        bdquo: "„",
        becaus: "∵",
        Because: "∵",
        because: "∵",
        bemptyv: "⦰",
        bepsi: "϶",
        bernou: "ℬ",
        Bernoullis: "ℬ",
        Beta: "Β",
        beta: "β",
        beth: "ℶ",
        between: "≬",
        Bfr: "𝔅",
        bfr: "𝔟",
        bigcap: "⋂",
        bigcirc: "◯",
        bigcup: "⋃",
        bigodot: "⨀",
        bigoplus: "⨁",
        bigotimes: "⨂",
        bigsqcup: "⨆",
        bigstar: "★",
        bigtriangledown: "▽",
        bigtriangleup: "△",
        biguplus: "⨄",
        bigvee: "⋁",
        bigwedge: "⋀",
        bkarow: "⤍",
        blacklozenge: "⧫",
        blacksquare: "▪",
        blacktriangle: "▴",
        blacktriangledown: "▾",
        blacktriangleleft: "◂",
        blacktriangleright: "▸",
        blank: "␣",
        blk12: "▒",
        blk14: "░",
        blk34: "▓",
        block: "█",
        bne: "=⃥",
        bnequiv: "≡⃥",
        bNot: "⫭",
        bnot: "⌐",
        Bopf: "𝔹",
        bopf: "𝕓",
        bot: "⊥",
        bottom: "⊥",
        bowtie: "⋈",
        boxbox: "⧉",
        boxDL: "╗",
        boxDl: "╖",
        boxdL: "╕",
        boxdl: "┐",
        boxDR: "╔",
        boxDr: "╓",
        boxdR: "╒",
        boxdr: "┌",
        boxH: "═",
        boxh: "─",
        boxHD: "╦",
        boxHd: "╤",
        boxhD: "╥",
        boxhd: "┬",
        boxHU: "╩",
        boxHu: "╧",
        boxhU: "╨",
        boxhu: "┴",
        boxminus: "⊟",
        boxplus: "⊞",
        boxtimes: "⊠",
        boxUL: "╝",
        boxUl: "╜",
        boxuL: "╛",
        boxul: "┘",
        boxUR: "╚",
        boxUr: "╙",
        boxuR: "╘",
        boxur: "└",
        boxV: "║",
        boxv: "│",
        boxVH: "╬",
        boxVh: "╫",
        boxvH: "╪",
        boxvh: "┼",
        boxVL: "╣",
        boxVl: "╢",
        boxvL: "╡",
        boxvl: "┤",
        boxVR: "╠",
        boxVr: "╟",
        boxvR: "╞",
        boxvr: "├",
        bprime: "‵",
        Breve: "˘",
        breve: "˘",
        brvbar: "¦",
        Bscr: "ℬ",
        bscr: "𝒷",
        bsemi: "⁏",
        bsim: "∽",
        bsime: "⋍",
        bsol: "\\",
        bsolb: "⧅",
        bsolhsub: "⟈",
        bull: "•",
        bullet: "•",
        bump: "≎",
        bumpE: "⪮",
        bumpe: "≏",
        Bumpeq: "≎",
        bumpeq: "≏",
        Cacute: "Ć",
        cacute: "ć",
        Cap: "⋒",
        cap: "∩",
        capand: "⩄",
        capbrcup: "⩉",
        capcap: "⩋",
        capcup: "⩇",
        capdot: "⩀",
        CapitalDifferentialD: "ⅅ",
        caps: "∩︀",
        caret: "⁁",
        caron: "ˇ",
        Cayleys: "ℭ",
        ccaps: "⩍",
        Ccaron: "Č",
        ccaron: "č",
        Ccedil: "Ç",
        ccedil: "ç",
        Ccirc: "Ĉ",
        ccirc: "ĉ",
        Cconint: "∰",
        ccups: "⩌",
        ccupssm: "⩐",
        Cdot: "Ċ",
        cdot: "ċ",
        cedil: "¸",
        Cedilla: "¸",
        cemptyv: "⦲",
        cent: "¢",
        CenterDot: "·",
        centerdot: "·",
        Cfr: "ℭ",
        cfr: "𝔠",
        CHcy: "Ч",
        chcy: "ч",
        check: "✓",
        checkmark: "✓",
        Chi: "Χ",
        chi: "χ",
        cir: "○",
        circ: "ˆ",
        circeq: "≗",
        circlearrowleft: "↺",
        circlearrowright: "↻",
        circledast: "⊛",
        circledcirc: "⊚",
        circleddash: "⊝",
        CircleDot: "⊙",
        circledR: "®",
        circledS: "Ⓢ",
        CircleMinus: "⊖",
        CirclePlus: "⊕",
        CircleTimes: "⊗",
        cirE: "⧃",
        cire: "≗",
        cirfnint: "⨐",
        cirmid: "⫯",
        cirscir: "⧂",
        ClockwiseContourIntegral: "∲",
        CloseCurlyDoubleQuote: "”",
        CloseCurlyQuote: "’",
        clubs: "♣",
        clubsuit: "♣",
        Colon: "∷",
        colon: ":",
        Colone: "⩴",
        colone: "≔",
        coloneq: "≔",
        comma: ",",
        commat: "@",
        comp: "∁",
        compfn: "∘",
        complement: "∁",
        complexes: "ℂ",
        cong: "≅",
        congdot: "⩭",
        Congruent: "≡",
        Conint: "∯",
        conint: "∮",
        ContourIntegral: "∮",
        Copf: "ℂ",
        copf: "𝕔",
        coprod: "∐",
        Coproduct: "∐",
        COPY: "©",
        copy: "©",
        copysr: "℗",
        CounterClockwiseContourIntegral: "∳",
        crarr: "↵",
        Cross: "⨯",
        cross: "✗",
        Cscr: "𝒞",
        cscr: "𝒸",
        csub: "⫏",
        csube: "⫑",
        csup: "⫐",
        csupe: "⫒",
        ctdot: "⋯",
        cudarrl: "⤸",
        cudarrr: "⤵",
        cuepr: "⋞",
        cuesc: "⋟",
        cularr: "↶",
        cularrp: "⤽",
        Cup: "⋓",
        cup: "∪",
        cupbrcap: "⩈",
        CupCap: "≍",
        cupcap: "⩆",
        cupcup: "⩊",
        cupdot: "⊍",
        cupor: "⩅",
        cups: "∪︀",
        curarr: "↷",
        curarrm: "⤼",
        curlyeqprec: "⋞",
        curlyeqsucc: "⋟",
        curlyvee: "⋎",
        curlywedge: "⋏",
        curren: "¤",
        curvearrowleft: "↶",
        curvearrowright: "↷",
        cuvee: "⋎",
        cuwed: "⋏",
        cwconint: "∲",
        cwint: "∱",
        cylcty: "⌭",
        Dagger: "‡",
        dagger: "†",
        daleth: "ℸ",
        Darr: "↡",
        dArr: "⇓",
        darr: "↓",
        dash: "‐",
        Dashv: "⫤",
        dashv: "⊣",
        dbkarow: "⤏",
        dblac: "˝",
        Dcaron: "Ď",
        dcaron: "ď",
        Dcy: "Д",
        dcy: "д",
        DD: "ⅅ",
        dd: "ⅆ",
        ddagger: "‡",
        ddarr: "⇊",
        DDotrahd: "⤑",
        ddotseq: "⩷",
        deg: "°",
        Del: "∇",
        Delta: "Δ",
        delta: "δ",
        demptyv: "⦱",
        dfisht: "⥿",
        Dfr: "𝔇",
        dfr: "𝔡",
        dHar: "⥥",
        dharl: "⇃",
        dharr: "⇂",
        DiacriticalAcute: "´",
        DiacriticalDot: "˙",
        DiacriticalDoubleAcute: "˝",
        DiacriticalGrave: "`",
        DiacriticalTilde: "˜",
        diam: "⋄",
        Diamond: "⋄",
        diamond: "⋄",
        diamondsuit: "♦",
        diams: "♦",
        die: "¨",
        DifferentialD: "ⅆ",
        digamma: "ϝ",
        disin: "⋲",
        div: "÷",
        divide: "÷",
        divideontimes: "⋇",
        divonx: "⋇",
        DJcy: "Ђ",
        djcy: "ђ",
        dlcorn: "⌞",
        dlcrop: "⌍",
        dollar: "$",
        Dopf: "𝔻",
        dopf: "𝕕",
        Dot: "¨",
        dot: "˙",
        DotDot: "⃜",
        doteq: "≐",
        doteqdot: "≑",
        DotEqual: "≐",
        dotminus: "∸",
        dotplus: "∔",
        dotsquare: "⊡",
        doublebarwedge: "⌆",
        DoubleContourIntegral: "∯",
        DoubleDot: "¨",
        DoubleDownArrow: "⇓",
        DoubleLeftArrow: "⇐",
        DoubleLeftRightArrow: "⇔",
        DoubleLeftTee: "⫤",
        DoubleLongLeftArrow: "⟸",
        DoubleLongLeftRightArrow: "⟺",
        DoubleLongRightArrow: "⟹",
        DoubleRightArrow: "⇒",
        DoubleRightTee: "⊨",
        DoubleUpArrow: "⇑",
        DoubleUpDownArrow: "⇕",
        DoubleVerticalBar: "∥",
        DownArrow: "↓",
        Downarrow: "⇓",
        downarrow: "↓",
        DownArrowBar: "⤓",
        DownArrowUpArrow: "⇵",
        DownBreve: "̑",
        downdownarrows: "⇊",
        downharpoonleft: "⇃",
        downharpoonright: "⇂",
        DownLeftRightVector: "⥐",
        DownLeftTeeVector: "⥞",
        DownLeftVector: "↽",
        DownLeftVectorBar: "⥖",
        DownRightTeeVector: "⥟",
        DownRightVector: "⇁",
        DownRightVectorBar: "⥗",
        DownTee: "⊤",
        DownTeeArrow: "↧",
        drbkarow: "⤐",
        drcorn: "⌟",
        drcrop: "⌌",
        Dscr: "𝒟",
        dscr: "𝒹",
        DScy: "Ѕ",
        dscy: "ѕ",
        dsol: "⧶",
        Dstrok: "Đ",
        dstrok: "đ",
        dtdot: "⋱",
        dtri: "▿",
        dtrif: "▾",
        duarr: "⇵",
        duhar: "⥯",
        dwangle: "⦦",
        DZcy: "Џ",
        dzcy: "џ",
        dzigrarr: "⟿",
        Eacute: "É",
        eacute: "é",
        easter: "⩮",
        Ecaron: "Ě",
        ecaron: "ě",
        ecir: "≖",
        Ecirc: "Ê",
        ecirc: "ê",
        ecolon: "≕",
        Ecy: "Э",
        ecy: "э",
        eDDot: "⩷",
        Edot: "Ė",
        eDot: "≑",
        edot: "ė",
        ee: "ⅇ",
        efDot: "≒",
        Efr: "𝔈",
        efr: "𝔢",
        eg: "⪚",
        Egrave: "È",
        egrave: "è",
        egs: "⪖",
        egsdot: "⪘",
        el: "⪙",
        Element: "∈",
        elinters: "⏧",
        ell: "ℓ",
        els: "⪕",
        elsdot: "⪗",
        Emacr: "Ē",
        emacr: "ē",
        empty: "∅",
        emptyset: "∅",
        EmptySmallSquare: "◻",
        emptyv: "∅",
        EmptyVerySmallSquare: "▫",
        emsp: " ",
        emsp13: " ",
        emsp14: " ",
        ENG: "Ŋ",
        eng: "ŋ",
        ensp: " ",
        Eogon: "Ę",
        eogon: "ę",
        Eopf: "𝔼",
        eopf: "𝕖",
        epar: "⋕",
        eparsl: "⧣",
        eplus: "⩱",
        epsi: "ε",
        Epsilon: "Ε",
        epsilon: "ε",
        epsiv: "ϵ",
        eqcirc: "≖",
        eqcolon: "≕",
        eqsim: "≂",
        eqslantgtr: "⪖",
        eqslantless: "⪕",
        Equal: "⩵",
        equals: "=",
        EqualTilde: "≂",
        equest: "≟",
        Equilibrium: "⇌",
        equiv: "≡",
        equivDD: "⩸",
        eqvparsl: "⧥",
        erarr: "⥱",
        erDot: "≓",
        Escr: "ℰ",
        escr: "ℯ",
        esdot: "≐",
        Esim: "⩳",
        esim: "≂",
        Eta: "Η",
        eta: "η",
        ETH: "Ð",
        eth: "ð",
        Euml: "Ë",
        euml: "ë",
        euro: "€",
        excl: "!",
        exist: "∃",
        Exists: "∃",
        expectation: "ℰ",
        ExponentialE: "ⅇ",
        exponentiale: "ⅇ",
        fallingdotseq: "≒",
        Fcy: "Ф",
        fcy: "ф",
        female: "♀",
        ffilig: "ﬃ",
        fflig: "ﬀ",
        ffllig: "ﬄ",
        Ffr: "𝔉",
        ffr: "𝔣",
        filig: "ﬁ",
        FilledSmallSquare: "◼",
        FilledVerySmallSquare: "▪",
        fjlig: "fj",
        flat: "♭",
        fllig: "ﬂ",
        fltns: "▱",
        fnof: "ƒ",
        Fopf: "𝔽",
        fopf: "𝕗",
        ForAll: "∀",
        forall: "∀",
        fork: "⋔",
        forkv: "⫙",
        Fouriertrf: "ℱ",
        fpartint: "⨍",
        frac12: "½",
        frac13: "⅓",
        frac14: "¼",
        frac15: "⅕",
        frac16: "⅙",
        frac18: "⅛",
        frac23: "⅔",
        frac25: "⅖",
        frac34: "¾",
        frac35: "⅗",
        frac38: "⅜",
        frac45: "⅘",
        frac56: "⅚",
        frac58: "⅝",
        frac78: "⅞",
        frasl: "⁄",
        frown: "⌢",
        Fscr: "ℱ",
        fscr: "𝒻",
        gacute: "ǵ",
        Gamma: "Γ",
        gamma: "γ",
        Gammad: "Ϝ",
        gammad: "ϝ",
        gap: "⪆",
        Gbreve: "Ğ",
        gbreve: "ğ",
        Gcedil: "Ģ",
        Gcirc: "Ĝ",
        gcirc: "ĝ",
        Gcy: "Г",
        gcy: "г",
        Gdot: "Ġ",
        gdot: "ġ",
        gE: "≧",
        ge: "≥",
        gEl: "⪌",
        gel: "⋛",
        geq: "≥",
        geqq: "≧",
        geqslant: "⩾",
        ges: "⩾",
        gescc: "⪩",
        gesdot: "⪀",
        gesdoto: "⪂",
        gesdotol: "⪄",
        gesl: "⋛︀",
        gesles: "⪔",
        Gfr: "𝔊",
        gfr: "𝔤",
        Gg: "⋙",
        gg: "≫",
        ggg: "⋙",
        gimel: "ℷ",
        GJcy: "Ѓ",
        gjcy: "ѓ",
        gl: "≷",
        gla: "⪥",
        glE: "⪒",
        glj: "⪤",
        gnap: "⪊",
        gnapprox: "⪊",
        gnE: "≩",
        gne: "⪈",
        gneq: "⪈",
        gneqq: "≩",
        gnsim: "⋧",
        Gopf: "𝔾",
        gopf: "𝕘",
        grave: "`",
        GreaterEqual: "≥",
        GreaterEqualLess: "⋛",
        GreaterFullEqual: "≧",
        GreaterGreater: "⪢",
        GreaterLess: "≷",
        GreaterSlantEqual: "⩾",
        GreaterTilde: "≳",
        Gscr: "𝒢",
        gscr: "ℊ",
        gsim: "≳",
        gsime: "⪎",
        gsiml: "⪐",
        Gt: "≫",
        GT: ">",
        gt: ">",
        gtcc: "⪧",
        gtcir: "⩺",
        gtdot: "⋗",
        gtlPar: "⦕",
        gtquest: "⩼",
        gtrapprox: "⪆",
        gtrarr: "⥸",
        gtrdot: "⋗",
        gtreqless: "⋛",
        gtreqqless: "⪌",
        gtrless: "≷",
        gtrsim: "≳",
        gvertneqq: "≩︀",
        gvnE: "≩︀",
        Hacek: "ˇ",
        hairsp: " ",
        half: "½",
        hamilt: "ℋ",
        HARDcy: "Ъ",
        hardcy: "ъ",
        hArr: "⇔",
        harr: "↔",
        harrcir: "⥈",
        harrw: "↭",
        Hat: "^",
        hbar: "ℏ",
        Hcirc: "Ĥ",
        hcirc: "ĥ",
        hearts: "♥",
        heartsuit: "♥",
        hellip: "…",
        hercon: "⊹",
        Hfr: "ℌ",
        hfr: "𝔥",
        HilbertSpace: "ℋ",
        hksearow: "⤥",
        hkswarow: "⤦",
        hoarr: "⇿",
        homtht: "∻",
        hookleftarrow: "↩",
        hookrightarrow: "↪",
        Hopf: "ℍ",
        hopf: "𝕙",
        horbar: "―",
        HorizontalLine: "─",
        Hscr: "ℋ",
        hscr: "𝒽",
        hslash: "ℏ",
        Hstrok: "Ħ",
        hstrok: "ħ",
        HumpDownHump: "≎",
        HumpEqual: "≏",
        hybull: "⁃",
        hyphen: "‐",
        Iacute: "Í",
        iacute: "í",
        ic: "⁣",
        Icirc: "Î",
        icirc: "î",
        Icy: "И",
        icy: "и",
        Idot: "İ",
        IEcy: "Е",
        iecy: "е",
        iexcl: "¡",
        iff: "⇔",
        Ifr: "ℑ",
        ifr: "𝔦",
        Igrave: "Ì",
        igrave: "ì",
        ii: "ⅈ",
        iiiint: "⨌",
        iiint: "∭",
        iinfin: "⧜",
        iiota: "℩",
        IJlig: "Ĳ",
        ijlig: "ĳ",
        Im: "ℑ",
        Imacr: "Ī",
        imacr: "ī",
        image: "ℑ",
        ImaginaryI: "ⅈ",
        imagline: "ℐ",
        imagpart: "ℑ",
        imath: "ı",
        imof: "⊷",
        imped: "Ƶ",
        Implies: "⇒",
        in: "∈",
        incare: "℅",
        infin: "∞",
        infintie: "⧝",
        inodot: "ı",
        Int: "∬",
        int: "∫",
        intcal: "⊺",
        integers: "ℤ",
        Integral: "∫",
        intercal: "⊺",
        Intersection: "⋂",
        intlarhk: "⨗",
        intprod: "⨼",
        InvisibleComma: "⁣",
        InvisibleTimes: "⁢",
        IOcy: "Ё",
        iocy: "ё",
        Iogon: "Į",
        iogon: "į",
        Iopf: "𝕀",
        iopf: "𝕚",
        Iota: "Ι",
        iota: "ι",
        iprod: "⨼",
        iquest: "¿",
        Iscr: "ℐ",
        iscr: "𝒾",
        isin: "∈",
        isindot: "⋵",
        isinE: "⋹",
        isins: "⋴",
        isinsv: "⋳",
        isinv: "∈",
        it: "⁢",
        Itilde: "Ĩ",
        itilde: "ĩ",
        Iukcy: "І",
        iukcy: "і",
        Iuml: "Ï",
        iuml: "ï",
        Jcirc: "Ĵ",
        jcirc: "ĵ",
        Jcy: "Й",
        jcy: "й",
        Jfr: "𝔍",
        jfr: "𝔧",
        jmath: "ȷ",
        Jopf: "𝕁",
        jopf: "𝕛",
        Jscr: "𝒥",
        jscr: "𝒿",
        Jsercy: "Ј",
        jsercy: "ј",
        Jukcy: "Є",
        jukcy: "є",
        Kappa: "Κ",
        kappa: "κ",
        kappav: "ϰ",
        Kcedil: "Ķ",
        kcedil: "ķ",
        Kcy: "К",
        kcy: "к",
        Kfr: "𝔎",
        kfr: "𝔨",
        kgreen: "ĸ",
        KHcy: "Х",
        khcy: "х",
        KJcy: "Ќ",
        kjcy: "ќ",
        Kopf: "𝕂",
        kopf: "𝕜",
        Kscr: "𝒦",
        kscr: "𝓀",
        lAarr: "⇚",
        Lacute: "Ĺ",
        lacute: "ĺ",
        laemptyv: "⦴",
        lagran: "ℒ",
        Lambda: "Λ",
        lambda: "λ",
        Lang: "⟪",
        lang: "⟨",
        langd: "⦑",
        langle: "⟨",
        lap: "⪅",
        Laplacetrf: "ℒ",
        laquo: "«",
        Larr: "↞",
        lArr: "⇐",
        larr: "←",
        larrb: "⇤",
        larrbfs: "⤟",
        larrfs: "⤝",
        larrhk: "↩",
        larrlp: "↫",
        larrpl: "⤹",
        larrsim: "⥳",
        larrtl: "↢",
        lat: "⪫",
        lAtail: "⤛",
        latail: "⤙",
        late: "⪭",
        lates: "⪭︀",
        lBarr: "⤎",
        lbarr: "⤌",
        lbbrk: "❲",
        lbrace: "{",
        lbrack: "[",
        lbrke: "⦋",
        lbrksld: "⦏",
        lbrkslu: "⦍",
        Lcaron: "Ľ",
        lcaron: "ľ",
        Lcedil: "Ļ",
        lcedil: "ļ",
        lceil: "⌈",
        lcub: "{",
        Lcy: "Л",
        lcy: "л",
        ldca: "⤶",
        ldquo: "“",
        ldquor: "„",
        ldrdhar: "⥧",
        ldrushar: "⥋",
        ldsh: "↲",
        lE: "≦",
        le: "≤",
        LeftAngleBracket: "⟨",
        LeftArrow: "←",
        Leftarrow: "⇐",
        leftarrow: "←",
        LeftArrowBar: "⇤",
        LeftArrowRightArrow: "⇆",
        leftarrowtail: "↢",
        LeftCeiling: "⌈",
        LeftDoubleBracket: "⟦",
        LeftDownTeeVector: "⥡",
        LeftDownVector: "⇃",
        LeftDownVectorBar: "⥙",
        LeftFloor: "⌊",
        leftharpoondown: "↽",
        leftharpoonup: "↼",
        leftleftarrows: "⇇",
        LeftRightArrow: "↔",
        Leftrightarrow: "⇔",
        leftrightarrow: "↔",
        leftrightarrows: "⇆",
        leftrightharpoons: "⇋",
        leftrightsquigarrow: "↭",
        LeftRightVector: "⥎",
        LeftTee: "⊣",
        LeftTeeArrow: "↤",
        LeftTeeVector: "⥚",
        leftthreetimes: "⋋",
        LeftTriangle: "⊲",
        LeftTriangleBar: "⧏",
        LeftTriangleEqual: "⊴",
        LeftUpDownVector: "⥑",
        LeftUpTeeVector: "⥠",
        LeftUpVector: "↿",
        LeftUpVectorBar: "⥘",
        LeftVector: "↼",
        LeftVectorBar: "⥒",
        lEg: "⪋",
        leg: "⋚",
        leq: "≤",
        leqq: "≦",
        leqslant: "⩽",
        les: "⩽",
        lescc: "⪨",
        lesdot: "⩿",
        lesdoto: "⪁",
        lesdotor: "⪃",
        lesg: "⋚︀",
        lesges: "⪓",
        lessapprox: "⪅",
        lessdot: "⋖",
        lesseqgtr: "⋚",
        lesseqqgtr: "⪋",
        LessEqualGreater: "⋚",
        LessFullEqual: "≦",
        LessGreater: "≶",
        lessgtr: "≶",
        LessLess: "⪡",
        lesssim: "≲",
        LessSlantEqual: "⩽",
        LessTilde: "≲",
        lfisht: "⥼",
        lfloor: "⌊",
        Lfr: "𝔏",
        lfr: "𝔩",
        lg: "≶",
        lgE: "⪑",
        lHar: "⥢",
        lhard: "↽",
        lharu: "↼",
        lharul: "⥪",
        lhblk: "▄",
        LJcy: "Љ",
        ljcy: "љ",
        Ll: "⋘",
        ll: "≪",
        llarr: "⇇",
        llcorner: "⌞",
        Lleftarrow: "⇚",
        llhard: "⥫",
        lltri: "◺",
        Lmidot: "Ŀ",
        lmidot: "ŀ",
        lmoust: "⎰",
        lmoustache: "⎰",
        lnap: "⪉",
        lnapprox: "⪉",
        lnE: "≨",
        lne: "⪇",
        lneq: "⪇",
        lneqq: "≨",
        lnsim: "⋦",
        loang: "⟬",
        loarr: "⇽",
        lobrk: "⟦",
        LongLeftArrow: "⟵",
        Longleftarrow: "⟸",
        longleftarrow: "⟵",
        LongLeftRightArrow: "⟷",
        Longleftrightarrow: "⟺",
        longleftrightarrow: "⟷",
        longmapsto: "⟼",
        LongRightArrow: "⟶",
        Longrightarrow: "⟹",
        longrightarrow: "⟶",
        looparrowleft: "↫",
        looparrowright: "↬",
        lopar: "⦅",
        Lopf: "𝕃",
        lopf: "𝕝",
        loplus: "⨭",
        lotimes: "⨴",
        lowast: "∗",
        lowbar: "_",
        LowerLeftArrow: "↙",
        LowerRightArrow: "↘",
        loz: "◊",
        lozenge: "◊",
        lozf: "⧫",
        lpar: "(",
        lparlt: "⦓",
        lrarr: "⇆",
        lrcorner: "⌟",
        lrhar: "⇋",
        lrhard: "⥭",
        lrm: "‎",
        lrtri: "⊿",
        lsaquo: "‹",
        Lscr: "ℒ",
        lscr: "𝓁",
        Lsh: "↰",
        lsh: "↰",
        lsim: "≲",
        lsime: "⪍",
        lsimg: "⪏",
        lsqb: "[",
        lsquo: "‘",
        lsquor: "‚",
        Lstrok: "Ł",
        lstrok: "ł",
        Lt: "≪",
        LT: "<",
        lt: "<",
        ltcc: "⪦",
        ltcir: "⩹",
        ltdot: "⋖",
        lthree: "⋋",
        ltimes: "⋉",
        ltlarr: "⥶",
        ltquest: "⩻",
        ltri: "◃",
        ltrie: "⊴",
        ltrif: "◂",
        ltrPar: "⦖",
        lurdshar: "⥊",
        luruhar: "⥦",
        lvertneqq: "≨︀",
        lvnE: "≨︀",
        macr: "¯",
        male: "♂",
        malt: "✠",
        maltese: "✠",
        Map: "⤅",
        map: "↦",
        mapsto: "↦",
        mapstodown: "↧",
        mapstoleft: "↤",
        mapstoup: "↥",
        marker: "▮",
        mcomma: "⨩",
        Mcy: "М",
        mcy: "м",
        mdash: "—",
        mDDot: "∺",
        measuredangle: "∡",
        MediumSpace: " ",
        Mellintrf: "ℳ",
        Mfr: "𝔐",
        mfr: "𝔪",
        mho: "℧",
        micro: "µ",
        mid: "∣",
        midast: "*",
        midcir: "⫰",
        middot: "·",
        minus: "−",
        minusb: "⊟",
        minusd: "∸",
        minusdu: "⨪",
        MinusPlus: "∓",
        mlcp: "⫛",
        mldr: "…",
        mnplus: "∓",
        models: "⊧",
        Mopf: "𝕄",
        mopf: "𝕞",
        mp: "∓",
        Mscr: "ℳ",
        mscr: "𝓂",
        mstpos: "∾",
        Mu: "Μ",
        mu: "μ",
        multimap: "⊸",
        mumap: "⊸",
        nabla: "∇",
        Nacute: "Ń",
        nacute: "ń",
        nang: "∠⃒",
        nap: "≉",
        napE: "⩰̸",
        napid: "≋̸",
        napos: "ŉ",
        napprox: "≉",
        natur: "♮",
        natural: "♮",
        naturals: "ℕ",
        nbsp: " ",
        nbump: "≎̸",
        nbumpe: "≏̸",
        ncap: "⩃",
        Ncaron: "Ň",
        ncaron: "ň",
        Ncedil: "Ņ",
        ncedil: "ņ",
        ncong: "≇",
        ncongdot: "⩭̸",
        ncup: "⩂",
        Ncy: "Н",
        ncy: "н",
        ndash: "–",
        ne: "≠",
        nearhk: "⤤",
        neArr: "⇗",
        nearr: "↗",
        nearrow: "↗",
        nedot: "≐̸",
        NegativeMediumSpace: "​",
        NegativeThickSpace: "​",
        NegativeThinSpace: "​",
        NegativeVeryThinSpace: "​",
        nequiv: "≢",
        nesear: "⤨",
        nesim: "≂̸",
        NestedGreaterGreater: "≫",
        NestedLessLess: "≪",
        NewLine: "\n",
        nexist: "∄",
        nexists: "∄",
        Nfr: "𝔑",
        nfr: "𝔫",
        ngE: "≧̸",
        nge: "≱",
        ngeq: "≱",
        ngeqq: "≧̸",
        ngeqslant: "⩾̸",
        nges: "⩾̸",
        nGg: "⋙̸",
        ngsim: "≵",
        nGt: "≫⃒",
        ngt: "≯",
        ngtr: "≯",
        nGtv: "≫̸",
        nhArr: "⇎",
        nharr: "↮",
        nhpar: "⫲",
        ni: "∋",
        nis: "⋼",
        nisd: "⋺",
        niv: "∋",
        NJcy: "Њ",
        njcy: "њ",
        nlArr: "⇍",
        nlarr: "↚",
        nldr: "‥",
        nlE: "≦̸",
        nle: "≰",
        nLeftarrow: "⇍",
        nleftarrow: "↚",
        nLeftrightarrow: "⇎",
        nleftrightarrow: "↮",
        nleq: "≰",
        nleqq: "≦̸",
        nleqslant: "⩽̸",
        nles: "⩽̸",
        nless: "≮",
        nLl: "⋘̸",
        nlsim: "≴",
        nLt: "≪⃒",
        nlt: "≮",
        nltri: "⋪",
        nltrie: "⋬",
        nLtv: "≪̸",
        nmid: "∤",
        NoBreak: "⁠",
        NonBreakingSpace: " ",
        Nopf: "ℕ",
        nopf: "𝕟",
        Not: "⫬",
        not: "¬",
        NotCongruent: "≢",
        NotCupCap: "≭",
        NotDoubleVerticalBar: "∦",
        NotElement: "∉",
        NotEqual: "≠",
        NotEqualTilde: "≂̸",
        NotExists: "∄",
        NotGreater: "≯",
        NotGreaterEqual: "≱",
        NotGreaterFullEqual: "≧̸",
        NotGreaterGreater: "≫̸",
        NotGreaterLess: "≹",
        NotGreaterSlantEqual: "⩾̸",
        NotGreaterTilde: "≵",
        NotHumpDownHump: "≎̸",
        NotHumpEqual: "≏̸",
        notin: "∉",
        notindot: "⋵̸",
        notinE: "⋹̸",
        notinva: "∉",
        notinvb: "⋷",
        notinvc: "⋶",
        NotLeftTriangle: "⋪",
        NotLeftTriangleBar: "⧏̸",
        NotLeftTriangleEqual: "⋬",
        NotLess: "≮",
        NotLessEqual: "≰",
        NotLessGreater: "≸",
        NotLessLess: "≪̸",
        NotLessSlantEqual: "⩽̸",
        NotLessTilde: "≴",
        NotNestedGreaterGreater: "⪢̸",
        NotNestedLessLess: "⪡̸",
        notni: "∌",
        notniva: "∌",
        notnivb: "⋾",
        notnivc: "⋽",
        NotPrecedes: "⊀",
        NotPrecedesEqual: "⪯̸",
        NotPrecedesSlantEqual: "⋠",
        NotReverseElement: "∌",
        NotRightTriangle: "⋫",
        NotRightTriangleBar: "⧐̸",
        NotRightTriangleEqual: "⋭",
        NotSquareSubset: "⊏̸",
        NotSquareSubsetEqual: "⋢",
        NotSquareSuperset: "⊐̸",
        NotSquareSupersetEqual: "⋣",
        NotSubset: "⊂⃒",
        NotSubsetEqual: "⊈",
        NotSucceeds: "⊁",
        NotSucceedsEqual: "⪰̸",
        NotSucceedsSlantEqual: "⋡",
        NotSucceedsTilde: "≿̸",
        NotSuperset: "⊃⃒",
        NotSupersetEqual: "⊉",
        NotTilde: "≁",
        NotTildeEqual: "≄",
        NotTildeFullEqual: "≇",
        NotTildeTilde: "≉",
        NotVerticalBar: "∤",
        npar: "∦",
        nparallel: "∦",
        nparsl: "⫽⃥",
        npart: "∂̸",
        npolint: "⨔",
        npr: "⊀",
        nprcue: "⋠",
        npre: "⪯̸",
        nprec: "⊀",
        npreceq: "⪯̸",
        nrArr: "⇏",
        nrarr: "↛",
        nrarrc: "⤳̸",
        nrarrw: "↝̸",
        nRightarrow: "⇏",
        nrightarrow: "↛",
        nrtri: "⋫",
        nrtrie: "⋭",
        nsc: "⊁",
        nsccue: "⋡",
        nsce: "⪰̸",
        Nscr: "𝒩",
        nscr: "𝓃",
        nshortmid: "∤",
        nshortparallel: "∦",
        nsim: "≁",
        nsime: "≄",
        nsimeq: "≄",
        nsmid: "∤",
        nspar: "∦",
        nsqsube: "⋢",
        nsqsupe: "⋣",
        nsub: "⊄",
        nsubE: "⫅̸",
        nsube: "⊈",
        nsubset: "⊂⃒",
        nsubseteq: "⊈",
        nsubseteqq: "⫅̸",
        nsucc: "⊁",
        nsucceq: "⪰̸",
        nsup: "⊅",
        nsupE: "⫆̸",
        nsupe: "⊉",
        nsupset: "⊃⃒",
        nsupseteq: "⊉",
        nsupseteqq: "⫆̸",
        ntgl: "≹",
        Ntilde: "Ñ",
        ntilde: "ñ",
        ntlg: "≸",
        ntriangleleft: "⋪",
        ntrianglelefteq: "⋬",
        ntriangleright: "⋫",
        ntrianglerighteq: "⋭",
        Nu: "Ν",
        nu: "ν",
        num: "#",
        numero: "№",
        numsp: " ",
        nvap: "≍⃒",
        nVDash: "⊯",
        nVdash: "⊮",
        nvDash: "⊭",
        nvdash: "⊬",
        nvge: "≥⃒",
        nvgt: ">⃒",
        nvHarr: "⤄",
        nvinfin: "⧞",
        nvlArr: "⤂",
        nvle: "≤⃒",
        nvlt: "<⃒",
        nvltrie: "⊴⃒",
        nvrArr: "⤃",
        nvrtrie: "⊵⃒",
        nvsim: "∼⃒",
        nwarhk: "⤣",
        nwArr: "⇖",
        nwarr: "↖",
        nwarrow: "↖",
        nwnear: "⤧",
        Oacute: "Ó",
        oacute: "ó",
        oast: "⊛",
        ocir: "⊚",
        Ocirc: "Ô",
        ocirc: "ô",
        Ocy: "О",
        ocy: "о",
        odash: "⊝",
        Odblac: "Ő",
        odblac: "ő",
        odiv: "⨸",
        odot: "⊙",
        odsold: "⦼",
        OElig: "Œ",
        oelig: "œ",
        ofcir: "⦿",
        Ofr: "𝔒",
        ofr: "𝔬",
        ogon: "˛",
        Ograve: "Ò",
        ograve: "ò",
        ogt: "⧁",
        ohbar: "⦵",
        ohm: "Ω",
        oint: "∮",
        olarr: "↺",
        olcir: "⦾",
        olcross: "⦻",
        oline: "‾",
        olt: "⧀",
        Omacr: "Ō",
        omacr: "ō",
        Omega: "Ω",
        omega: "ω",
        Omicron: "Ο",
        omicron: "ο",
        omid: "⦶",
        ominus: "⊖",
        Oopf: "𝕆",
        oopf: "𝕠",
        opar: "⦷",
        OpenCurlyDoubleQuote: "“",
        OpenCurlyQuote: "‘",
        operp: "⦹",
        oplus: "⊕",
        Or: "⩔",
        or: "∨",
        orarr: "↻",
        ord: "⩝",
        order: "ℴ",
        orderof: "ℴ",
        ordf: "ª",
        ordm: "º",
        origof: "⊶",
        oror: "⩖",
        orslope: "⩗",
        orv: "⩛",
        oS: "Ⓢ",
        Oscr: "𝒪",
        oscr: "ℴ",
        Oslash: "Ø",
        oslash: "ø",
        osol: "⊘",
        Otilde: "Õ",
        otilde: "õ",
        Otimes: "⨷",
        otimes: "⊗",
        otimesas: "⨶",
        Ouml: "Ö",
        ouml: "ö",
        ovbar: "⌽",
        OverBar: "‾",
        OverBrace: "⏞",
        OverBracket: "⎴",
        OverParenthesis: "⏜",
        par: "∥",
        para: "¶",
        parallel: "∥",
        parsim: "⫳",
        parsl: "⫽",
        part: "∂",
        PartialD: "∂",
        Pcy: "П",
        pcy: "п",
        percnt: "%",
        period: ".",
        permil: "‰",
        perp: "⊥",
        pertenk: "‱",
        Pfr: "𝔓",
        pfr: "𝔭",
        Phi: "Φ",
        phi: "φ",
        phiv: "ϕ",
        phmmat: "ℳ",
        phone: "☎",
        Pi: "Π",
        pi: "π",
        pitchfork: "⋔",
        piv: "ϖ",
        planck: "ℏ",
        planckh: "ℎ",
        plankv: "ℏ",
        plus: "+",
        plusacir: "⨣",
        plusb: "⊞",
        pluscir: "⨢",
        plusdo: "∔",
        plusdu: "⨥",
        pluse: "⩲",
        PlusMinus: "±",
        plusmn: "±",
        plussim: "⨦",
        plustwo: "⨧",
        pm: "±",
        Poincareplane: "ℌ",
        pointint: "⨕",
        Popf: "ℙ",
        popf: "𝕡",
        pound: "£",
        Pr: "⪻",
        pr: "≺",
        prap: "⪷",
        prcue: "≼",
        prE: "⪳",
        pre: "⪯",
        prec: "≺",
        precapprox: "⪷",
        preccurlyeq: "≼",
        Precedes: "≺",
        PrecedesEqual: "⪯",
        PrecedesSlantEqual: "≼",
        PrecedesTilde: "≾",
        preceq: "⪯",
        precnapprox: "⪹",
        precneqq: "⪵",
        precnsim: "⋨",
        precsim: "≾",
        Prime: "″",
        prime: "′",
        primes: "ℙ",
        prnap: "⪹",
        prnE: "⪵",
        prnsim: "⋨",
        prod: "∏",
        Product: "∏",
        profalar: "⌮",
        profline: "⌒",
        profsurf: "⌓",
        prop: "∝",
        Proportion: "∷",
        Proportional: "∝",
        propto: "∝",
        prsim: "≾",
        prurel: "⊰",
        Pscr: "𝒫",
        pscr: "𝓅",
        Psi: "Ψ",
        psi: "ψ",
        puncsp: " ",
        Qfr: "𝔔",
        qfr: "𝔮",
        qint: "⨌",
        Qopf: "ℚ",
        qopf: "𝕢",
        qprime: "⁗",
        Qscr: "𝒬",
        qscr: "𝓆",
        quaternions: "ℍ",
        quatint: "⨖",
        quest: "?",
        questeq: "≟",
        QUOT: '"',
        quot: '"',
        rAarr: "⇛",
        race: "∽̱",
        Racute: "Ŕ",
        racute: "ŕ",
        radic: "√",
        raemptyv: "⦳",
        Rang: "⟫",
        rang: "⟩",
        rangd: "⦒",
        range: "⦥",
        rangle: "⟩",
        raquo: "»",
        Rarr: "↠",
        rArr: "⇒",
        rarr: "→",
        rarrap: "⥵",
        rarrb: "⇥",
        rarrbfs: "⤠",
        rarrc: "⤳",
        rarrfs: "⤞",
        rarrhk: "↪",
        rarrlp: "↬",
        rarrpl: "⥅",
        rarrsim: "⥴",
        Rarrtl: "⤖",
        rarrtl: "↣",
        rarrw: "↝",
        rAtail: "⤜",
        ratail: "⤚",
        ratio: "∶",
        rationals: "ℚ",
        RBarr: "⤐",
        rBarr: "⤏",
        rbarr: "⤍",
        rbbrk: "❳",
        rbrace: "}",
        rbrack: "]",
        rbrke: "⦌",
        rbrksld: "⦎",
        rbrkslu: "⦐",
        Rcaron: "Ř",
        rcaron: "ř",
        Rcedil: "Ŗ",
        rcedil: "ŗ",
        rceil: "⌉",
        rcub: "}",
        Rcy: "Р",
        rcy: "р",
        rdca: "⤷",
        rdldhar: "⥩",
        rdquo: "”",
        rdquor: "”",
        rdsh: "↳",
        Re: "ℜ",
        real: "ℜ",
        realine: "ℛ",
        realpart: "ℜ",
        reals: "ℝ",
        rect: "▭",
        REG: "®",
        reg: "®",
        ReverseElement: "∋",
        ReverseEquilibrium: "⇋",
        ReverseUpEquilibrium: "⥯",
        rfisht: "⥽",
        rfloor: "⌋",
        Rfr: "ℜ",
        rfr: "𝔯",
        rHar: "⥤",
        rhard: "⇁",
        rharu: "⇀",
        rharul: "⥬",
        Rho: "Ρ",
        rho: "ρ",
        rhov: "ϱ",
        RightAngleBracket: "⟩",
        RightArrow: "→",
        Rightarrow: "⇒",
        rightarrow: "→",
        RightArrowBar: "⇥",
        RightArrowLeftArrow: "⇄",
        rightarrowtail: "↣",
        RightCeiling: "⌉",
        RightDoubleBracket: "⟧",
        RightDownTeeVector: "⥝",
        RightDownVector: "⇂",
        RightDownVectorBar: "⥕",
        RightFloor: "⌋",
        rightharpoondown: "⇁",
        rightharpoonup: "⇀",
        rightleftarrows: "⇄",
        rightleftharpoons: "⇌",
        rightrightarrows: "⇉",
        rightsquigarrow: "↝",
        RightTee: "⊢",
        RightTeeArrow: "↦",
        RightTeeVector: "⥛",
        rightthreetimes: "⋌",
        RightTriangle: "⊳",
        RightTriangleBar: "⧐",
        RightTriangleEqual: "⊵",
        RightUpDownVector: "⥏",
        RightUpTeeVector: "⥜",
        RightUpVector: "↾",
        RightUpVectorBar: "⥔",
        RightVector: "⇀",
        RightVectorBar: "⥓",
        ring: "˚",
        risingdotseq: "≓",
        rlarr: "⇄",
        rlhar: "⇌",
        rlm: "‏",
        rmoust: "⎱",
        rmoustache: "⎱",
        rnmid: "⫮",
        roang: "⟭",
        roarr: "⇾",
        robrk: "⟧",
        ropar: "⦆",
        Ropf: "ℝ",
        ropf: "𝕣",
        roplus: "⨮",
        rotimes: "⨵",
        RoundImplies: "⥰",
        rpar: ")",
        rpargt: "⦔",
        rppolint: "⨒",
        rrarr: "⇉",
        Rrightarrow: "⇛",
        rsaquo: "›",
        Rscr: "ℛ",
        rscr: "𝓇",
        Rsh: "↱",
        rsh: "↱",
        rsqb: "]",
        rsquo: "’",
        rsquor: "’",
        rthree: "⋌",
        rtimes: "⋊",
        rtri: "▹",
        rtrie: "⊵",
        rtrif: "▸",
        rtriltri: "⧎",
        RuleDelayed: "⧴",
        ruluhar: "⥨",
        rx: "℞",
        Sacute: "Ś",
        sacute: "ś",
        sbquo: "‚",
        Sc: "⪼",
        sc: "≻",
        scap: "⪸",
        Scaron: "Š",
        scaron: "š",
        sccue: "≽",
        scE: "⪴",
        sce: "⪰",
        Scedil: "Ş",
        scedil: "ş",
        Scirc: "Ŝ",
        scirc: "ŝ",
        scnap: "⪺",
        scnE: "⪶",
        scnsim: "⋩",
        scpolint: "⨓",
        scsim: "≿",
        Scy: "С",
        scy: "с",
        sdot: "⋅",
        sdotb: "⊡",
        sdote: "⩦",
        searhk: "⤥",
        seArr: "⇘",
        searr: "↘",
        searrow: "↘",
        sect: "§",
        semi: ";",
        seswar: "⤩",
        setminus: "∖",
        setmn: "∖",
        sext: "✶",
        Sfr: "𝔖",
        sfr: "𝔰",
        sfrown: "⌢",
        sharp: "♯",
        SHCHcy: "Щ",
        shchcy: "щ",
        SHcy: "Ш",
        shcy: "ш",
        ShortDownArrow: "↓",
        ShortLeftArrow: "←",
        shortmid: "∣",
        shortparallel: "∥",
        ShortRightArrow: "→",
        ShortUpArrow: "↑",
        shy: "­",
        Sigma: "Σ",
        sigma: "σ",
        sigmaf: "ς",
        sigmav: "ς",
        sim: "∼",
        simdot: "⩪",
        sime: "≃",
        simeq: "≃",
        simg: "⪞",
        simgE: "⪠",
        siml: "⪝",
        simlE: "⪟",
        simne: "≆",
        simplus: "⨤",
        simrarr: "⥲",
        slarr: "←",
        SmallCircle: "∘",
        smallsetminus: "∖",
        smashp: "⨳",
        smeparsl: "⧤",
        smid: "∣",
        smile: "⌣",
        smt: "⪪",
        smte: "⪬",
        smtes: "⪬︀",
        SOFTcy: "Ь",
        softcy: "ь",
        sol: "/",
        solb: "⧄",
        solbar: "⌿",
        Sopf: "𝕊",
        sopf: "𝕤",
        spades: "♠",
        spadesuit: "♠",
        spar: "∥",
        sqcap: "⊓",
        sqcaps: "⊓︀",
        sqcup: "⊔",
        sqcups: "⊔︀",
        Sqrt: "√",
        sqsub: "⊏",
        sqsube: "⊑",
        sqsubset: "⊏",
        sqsubseteq: "⊑",
        sqsup: "⊐",
        sqsupe: "⊒",
        sqsupset: "⊐",
        sqsupseteq: "⊒",
        squ: "□",
        Square: "□",
        square: "□",
        SquareIntersection: "⊓",
        SquareSubset: "⊏",
        SquareSubsetEqual: "⊑",
        SquareSuperset: "⊐",
        SquareSupersetEqual: "⊒",
        SquareUnion: "⊔",
        squarf: "▪",
        squf: "▪",
        srarr: "→",
        Sscr: "𝒮",
        sscr: "𝓈",
        ssetmn: "∖",
        ssmile: "⌣",
        sstarf: "⋆",
        Star: "⋆",
        star: "☆",
        starf: "★",
        straightepsilon: "ϵ",
        straightphi: "ϕ",
        strns: "¯",
        Sub: "⋐",
        sub: "⊂",
        subdot: "⪽",
        subE: "⫅",
        sube: "⊆",
        subedot: "⫃",
        submult: "⫁",
        subnE: "⫋",
        subne: "⊊",
        subplus: "⪿",
        subrarr: "⥹",
        Subset: "⋐",
        subset: "⊂",
        subseteq: "⊆",
        subseteqq: "⫅",
        SubsetEqual: "⊆",
        subsetneq: "⊊",
        subsetneqq: "⫋",
        subsim: "⫇",
        subsub: "⫕",
        subsup: "⫓",
        succ: "≻",
        succapprox: "⪸",
        succcurlyeq: "≽",
        Succeeds: "≻",
        SucceedsEqual: "⪰",
        SucceedsSlantEqual: "≽",
        SucceedsTilde: "≿",
        succeq: "⪰",
        succnapprox: "⪺",
        succneqq: "⪶",
        succnsim: "⋩",
        succsim: "≿",
        SuchThat: "∋",
        Sum: "∑",
        sum: "∑",
        sung: "♪",
        Sup: "⋑",
        sup: "⊃",
        sup1: "¹",
        sup2: "²",
        sup3: "³",
        supdot: "⪾",
        supdsub: "⫘",
        supE: "⫆",
        supe: "⊇",
        supedot: "⫄",
        Superset: "⊃",
        SupersetEqual: "⊇",
        suphsol: "⟉",
        suphsub: "⫗",
        suplarr: "⥻",
        supmult: "⫂",
        supnE: "⫌",
        supne: "⊋",
        supplus: "⫀",
        Supset: "⋑",
        supset: "⊃",
        supseteq: "⊇",
        supseteqq: "⫆",
        supsetneq: "⊋",
        supsetneqq: "⫌",
        supsim: "⫈",
        supsub: "⫔",
        supsup: "⫖",
        swarhk: "⤦",
        swArr: "⇙",
        swarr: "↙",
        swarrow: "↙",
        swnwar: "⤪",
        szlig: "ß",
        Tab: "	",
        target: "⌖",
        Tau: "Τ",
        tau: "τ",
        tbrk: "⎴",
        Tcaron: "Ť",
        tcaron: "ť",
        Tcedil: "Ţ",
        tcedil: "ţ",
        Tcy: "Т",
        tcy: "т",
        tdot: "⃛",
        telrec: "⌕",
        Tfr: "𝔗",
        tfr: "𝔱",
        there4: "∴",
        Therefore: "∴",
        therefore: "∴",
        Theta: "Θ",
        theta: "θ",
        thetasym: "ϑ",
        thetav: "ϑ",
        thickapprox: "≈",
        thicksim: "∼",
        ThickSpace: "  ",
        thinsp: " ",
        ThinSpace: " ",
        thkap: "≈",
        thksim: "∼",
        THORN: "Þ",
        thorn: "þ",
        Tilde: "∼",
        tilde: "˜",
        TildeEqual: "≃",
        TildeFullEqual: "≅",
        TildeTilde: "≈",
        times: "×",
        timesb: "⊠",
        timesbar: "⨱",
        timesd: "⨰",
        tint: "∭",
        toea: "⤨",
        top: "⊤",
        topbot: "⌶",
        topcir: "⫱",
        Topf: "𝕋",
        topf: "𝕥",
        topfork: "⫚",
        tosa: "⤩",
        tprime: "‴",
        TRADE: "™",
        trade: "™",
        triangle: "▵",
        triangledown: "▿",
        triangleleft: "◃",
        trianglelefteq: "⊴",
        triangleq: "≜",
        triangleright: "▹",
        trianglerighteq: "⊵",
        tridot: "◬",
        trie: "≜",
        triminus: "⨺",
        TripleDot: "⃛",
        triplus: "⨹",
        trisb: "⧍",
        tritime: "⨻",
        trpezium: "⏢",
        Tscr: "𝒯",
        tscr: "𝓉",
        TScy: "Ц",
        tscy: "ц",
        TSHcy: "Ћ",
        tshcy: "ћ",
        Tstrok: "Ŧ",
        tstrok: "ŧ",
        twixt: "≬",
        twoheadleftarrow: "↞",
        twoheadrightarrow: "↠",
        Uacute: "Ú",
        uacute: "ú",
        Uarr: "↟",
        uArr: "⇑",
        uarr: "↑",
        Uarrocir: "⥉",
        Ubrcy: "Ў",
        ubrcy: "ў",
        Ubreve: "Ŭ",
        ubreve: "ŭ",
        Ucirc: "Û",
        ucirc: "û",
        Ucy: "У",
        ucy: "у",
        udarr: "⇅",
        Udblac: "Ű",
        udblac: "ű",
        udhar: "⥮",
        ufisht: "⥾",
        Ufr: "𝔘",
        ufr: "𝔲",
        Ugrave: "Ù",
        ugrave: "ù",
        uHar: "⥣",
        uharl: "↿",
        uharr: "↾",
        uhblk: "▀",
        ulcorn: "⌜",
        ulcorner: "⌜",
        ulcrop: "⌏",
        ultri: "◸",
        Umacr: "Ū",
        umacr: "ū",
        uml: "¨",
        UnderBar: "_",
        UnderBrace: "⏟",
        UnderBracket: "⎵",
        UnderParenthesis: "⏝",
        Union: "⋃",
        UnionPlus: "⊎",
        Uogon: "Ų",
        uogon: "ų",
        Uopf: "𝕌",
        uopf: "𝕦",
        UpArrow: "↑",
        Uparrow: "⇑",
        uparrow: "↑",
        UpArrowBar: "⤒",
        UpArrowDownArrow: "⇅",
        UpDownArrow: "↕",
        Updownarrow: "⇕",
        updownarrow: "↕",
        UpEquilibrium: "⥮",
        upharpoonleft: "↿",
        upharpoonright: "↾",
        uplus: "⊎",
        UpperLeftArrow: "↖",
        UpperRightArrow: "↗",
        Upsi: "ϒ",
        upsi: "υ",
        upsih: "ϒ",
        Upsilon: "Υ",
        upsilon: "υ",
        UpTee: "⊥",
        UpTeeArrow: "↥",
        upuparrows: "⇈",
        urcorn: "⌝",
        urcorner: "⌝",
        urcrop: "⌎",
        Uring: "Ů",
        uring: "ů",
        urtri: "◹",
        Uscr: "𝒰",
        uscr: "𝓊",
        utdot: "⋰",
        Utilde: "Ũ",
        utilde: "ũ",
        utri: "▵",
        utrif: "▴",
        uuarr: "⇈",
        Uuml: "Ü",
        uuml: "ü",
        uwangle: "⦧",
        vangrt: "⦜",
        varepsilon: "ϵ",
        varkappa: "ϰ",
        varnothing: "∅",
        varphi: "ϕ",
        varpi: "ϖ",
        varpropto: "∝",
        vArr: "⇕",
        varr: "↕",
        varrho: "ϱ",
        varsigma: "ς",
        varsubsetneq: "⊊︀",
        varsubsetneqq: "⫋︀",
        varsupsetneq: "⊋︀",
        varsupsetneqq: "⫌︀",
        vartheta: "ϑ",
        vartriangleleft: "⊲",
        vartriangleright: "⊳",
        Vbar: "⫫",
        vBar: "⫨",
        vBarv: "⫩",
        Vcy: "В",
        vcy: "в",
        VDash: "⊫",
        Vdash: "⊩",
        vDash: "⊨",
        vdash: "⊢",
        Vdashl: "⫦",
        Vee: "⋁",
        vee: "∨",
        veebar: "⊻",
        veeeq: "≚",
        vellip: "⋮",
        Verbar: "‖",
        verbar: "|",
        Vert: "‖",
        vert: "|",
        VerticalBar: "∣",
        VerticalLine: "|",
        VerticalSeparator: "❘",
        VerticalTilde: "≀",
        VeryThinSpace: " ",
        Vfr: "𝔙",
        vfr: "𝔳",
        vltri: "⊲",
        vnsub: "⊂⃒",
        vnsup: "⊃⃒",
        Vopf: "𝕍",
        vopf: "𝕧",
        vprop: "∝",
        vrtri: "⊳",
        Vscr: "𝒱",
        vscr: "𝓋",
        vsubnE: "⫋︀",
        vsubne: "⊊︀",
        vsupnE: "⫌︀",
        vsupne: "⊋︀",
        Vvdash: "⊪",
        vzigzag: "⦚",
        Wcirc: "Ŵ",
        wcirc: "ŵ",
        wedbar: "⩟",
        Wedge: "⋀",
        wedge: "∧",
        wedgeq: "≙",
        weierp: "℘",
        Wfr: "𝔚",
        wfr: "𝔴",
        Wopf: "𝕎",
        wopf: "𝕨",
        wp: "℘",
        wr: "≀",
        wreath: "≀",
        Wscr: "𝒲",
        wscr: "𝓌",
        xcap: "⋂",
        xcirc: "◯",
        xcup: "⋃",
        xdtri: "▽",
        Xfr: "𝔛",
        xfr: "𝔵",
        xhArr: "⟺",
        xharr: "⟷",
        Xi: "Ξ",
        xi: "ξ",
        xlArr: "⟸",
        xlarr: "⟵",
        xmap: "⟼",
        xnis: "⋻",
        xodot: "⨀",
        Xopf: "𝕏",
        xopf: "𝕩",
        xoplus: "⨁",
        xotime: "⨂",
        xrArr: "⟹",
        xrarr: "⟶",
        Xscr: "𝒳",
        xscr: "𝓍",
        xsqcup: "⨆",
        xuplus: "⨄",
        xutri: "△",
        xvee: "⋁",
        xwedge: "⋀",
        Yacute: "Ý",
        yacute: "ý",
        YAcy: "Я",
        yacy: "я",
        Ycirc: "Ŷ",
        ycirc: "ŷ",
        Ycy: "Ы",
        ycy: "ы",
        yen: "¥",
        Yfr: "𝔜",
        yfr: "𝔶",
        YIcy: "Ї",
        yicy: "ї",
        Yopf: "𝕐",
        yopf: "𝕪",
        Yscr: "𝒴",
        yscr: "𝓎",
        YUcy: "Ю",
        yucy: "ю",
        Yuml: "Ÿ",
        yuml: "ÿ",
        Zacute: "Ź",
        zacute: "ź",
        Zcaron: "Ž",
        zcaron: "ž",
        Zcy: "З",
        zcy: "з",
        Zdot: "Ż",
        zdot: "ż",
        zeetrf: "ℨ",
        ZeroWidthSpace: "​",
        Zeta: "Ζ",
        zeta: "ζ",
        Zfr: "ℨ",
        zfr: "𝔷",
        ZHcy: "Ж",
        zhcy: "ж",
        zigrarr: "⇝",
        Zopf: "ℤ",
        zopf: "𝕫",
        Zscr: "𝒵",
        zscr: "𝓏",
        zwj: "‍",
        zwnj: "‌"
      });
      exports2.entityMap = exports2.HTML_ENTITIES;
    })(entities$1);
    var sax$1 = {};
    var NAMESPACE$1 = conventions$2.NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError$1(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError$1);
    }
    ParseError$1.prototype = new Error();
    ParseError$1.prototype.name = ParseError$1.name;
    function XMLReader$1() {
    }
    XMLReader$1.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a3) {
        var k2 = a3.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k2)) {
          return entityMap[k2];
        } else if (k2.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a3);
          return a3;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position2(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position2(p2, m2) {
        while (p2 >= lineEnd && (m2 = linePattern.exec(source))) {
          lineStart = m2.index;
          lineEnd = lineStart + m2[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p2 - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config2 = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config2.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config2.localNSMap;
              var endMatch = config2.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config2.tagName && config2.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config2.uri, config2.localName, tagName);
                if (localNSMap) {
                  for (var prefix2 in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix2)) {
                      domBuilder.endPrefixMapping(prefix2);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config2.tagName);
                }
              } else {
                parseStack.push(config2);
              }
              end++;
              break;
            case "?":
              locator && position2(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position2(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position2(tagStart);
              var el2 = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el2, currentNSMap, entityReplacer, errorHandler);
              var len = el2.length;
              if (!el2.closed && fixSelfClosed(source, end, el2.tagName, closeMap)) {
                el2.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i2 = 0; i2 < len; i2++) {
                  var a2 = el2[i2];
                  position2(a2.offset);
                  a2.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement$1(el2, domBuilder, currentNSMap)) {
                  parseStack.push(el2);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement$1(el2, domBuilder, currentNSMap)) {
                  parseStack.push(el2);
                }
              }
              if (NAMESPACE$1.isHTML(el2.uri) && !el2.closed) {
                end = parseHtmlSpecialContent(source, end, el2.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e2) {
          if (e2 instanceof ParseError$1) {
            throw e2;
          }
          errorHandler.error("element parse error: " + e2);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f2, t2) {
      t2.lineNumber = f2.lineNumber;
      t2.columnNumber = f2.columnNumber;
      return t2;
    }
    function parseElementStartPart(source, start, el2, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el2.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el2.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p2 = ++start;
      var s2 = S_TAG;
      while (true) {
        var c2 = source.charAt(p2);
        switch (c2) {
          case "=":
            if (s2 === S_ATTR) {
              attrName = source.slice(start, p2);
              s2 = S_EQ;
            } else if (s2 === S_ATTR_SPACE) {
              s2 = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s2 === S_EQ || s2 === S_ATTR) {
              if (s2 === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p2);
              }
              start = p2 + 1;
              p2 = source.indexOf(c2, start);
              if (p2 > 0) {
                value = source.slice(start, p2);
                addAttribute(attrName, value, start - 1);
                s2 = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c2 + "' match");
              }
            } else if (s2 == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p2);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
              start = p2 + 1;
              s2 = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s2) {
              case S_TAG:
                el2.setTagName(source.slice(start, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s2 = S_TAG_CLOSE;
                el2.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el2.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s2 == S_TAG) {
              el2.setTagName(source.slice(start, p2));
            }
            return p2;
          case ">":
            switch (s2) {
              case S_TAG:
                el2.setTagName(source.slice(start, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p2);
                if (value.slice(-1) === "/") {
                  el2.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s2 === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s2 == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p2;
          case "":
            c2 = " ";
          default:
            if (c2 <= " ") {
              switch (s2) {
                case S_TAG:
                  el2.setTagName(source.slice(start, p2));
                  s2 = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p2);
                  s2 = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p2);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s2 = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s2) {
                case S_ATTR_SPACE:
                  el2.tagName;
                  if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p2;
                  s2 = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s2 = S_ATTR;
                  start = p2;
                  break;
                case S_EQ:
                  s2 = S_ATTR_NOQUOT_VALUE;
                  start = p2;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p2++;
      }
    }
    function appendElement$1(el2, domBuilder, currentNSMap) {
      var tagName = el2.tagName;
      var localNSMap = null;
      var i2 = el2.length;
      while (i2--) {
        var a2 = el2[i2];
        var qName = a2.qName;
        var value = a2.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix2 = a2.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix2 === "xmlns" && localName;
        } else {
          localName = qName;
          prefix2 = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a2.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a2.uri = NAMESPACE$1.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i2 = el2.length;
      while (i2--) {
        a2 = el2[i2];
        var prefix2 = a2.prefix;
        if (prefix2) {
          if (prefix2 === "xml") {
            a2.uri = NAMESPACE$1.XML;
          }
          if (prefix2 !== "xmlns") {
            a2.uri = currentNSMap[prefix2 || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix2 = el2.prefix = tagName.slice(0, nsp);
        localName = el2.localName = tagName.slice(nsp + 1);
      } else {
        prefix2 = null;
        localName = el2.localName = tagName;
      }
      var ns = el2.uri = currentNSMap[prefix2 || ""];
      domBuilder.startElement(ns, localName, tagName, el2);
      if (el2.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix2 in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix2)) {
              domBuilder.endPrefixMapping(prefix2);
            }
          }
        }
      } else {
        el2.currentNSMap = currentNSMap;
        el2.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, n2)) {
          target[n2] = source[n2];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next2 = source.charAt(start + 2);
      switch (next2) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match2 = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match2) {
          match2[0].length;
          domBuilder.processingInstruction(match2[1], match2[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i2) {
        return this[i2].localName;
      },
      getLocator: function(i2) {
        return this[i2].locator;
      },
      getQName: function(i2) {
        return this[i2].qName;
      },
      getURI: function(i2) {
        return this[i2].uri;
      },
      getValue: function(i2) {
        return this[i2].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match2;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match2 = reg.exec(source)) {
        buf.push(match2);
        if (match2[1])
          return buf;
      }
    }
    sax$1.XMLReader = XMLReader$1;
    sax$1.ParseError = ParseError$1;
    var conventions = conventions$2;
    var dom$1 = dom$2;
    var entities = entities$1;
    var sax = sax$1;
    var DOMImplementation = dom$1.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser$1(options) {
      this.options = options || { locator: {} };
    }
    DOMParser$1.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn2 = errorImpl[key];
        if (!fn2 && isCallback) {
          fn2 = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn2 && function(msg) {
          fn2("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node2) {
      node2.lineNumber = locator.lineNumber;
      node2.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el2 = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el2);
        this.currentElement = el2;
        this.locator && position(this.locator, el2);
        for (var i2 = 0; i2 < len; i2++) {
          var namespaceURI = attrs.getURI(i2);
          var value = attrs.getValue(i2);
          var qName = attrs.getQName(i2);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i2), attr);
          attr.value = attr.nodeValue = value;
          el2.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix2, uri) {
      },
      endPrefixMapping: function(prefix2) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch2, start, length2) {
      },
      characters: function(chars, start, length2) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length2) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l2) {
      if (l2) {
        return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
      }
    }
    function _toString(chars, start, length2) {
      if (typeof chars == "string") {
        return chars.substr(start, length2);
      } else {
        if (chars.length >= start + length2 || start) {
          return new java.lang.String(chars, start, length2) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node2) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node2);
      } else {
        hander.currentElement.appendChild(node2);
      }
    }
    domParser.__DOMHandler = DOMHandler;
    domParser.normalizeLineEndings = normalizeLineEndings;
    domParser.DOMParser = DOMParser$1;
    var dom = dom$2;
    lib.DOMImplementation = dom.DOMImplementation;
    lib.XMLSerializer = dom.XMLSerializer;
    lib.DOMParser = domParser.DOMParser;
    function last$4(a2) {
      return a2[a2.length - 1];
    }
    function first$3(a2) {
      return a2[0];
    }
    var utils$1 = {
      last: last$4,
      first: first$3
    };
    function _typeof$6(obj) {
      "@babel/helpers - typeof";
      return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$6(obj);
    }
    function ownKeys$3(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
          _defineProperty$3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty$3(obj, key, value) {
      key = _toPropertyKey$6(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey$6(arg) {
      var key = _toPrimitive$6(arg, "string");
      return _typeof$6(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive$6(input, hint) {
      if (_typeof$6(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$6(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require$6 = utils$1, last$3 = _require$6.last, first$2 = _require$6.first;
    function XTError(message) {
      this.name = "GenericError";
      this.message = message;
      this.stack = new Error(message).stack;
    }
    XTError.prototype = Error.prototype;
    function XTTemplateError$2(message) {
      this.name = "TemplateError";
      this.message = message;
      this.stack = new Error(message).stack;
    }
    XTTemplateError$2.prototype = new XTError();
    function XTRenderingError(message) {
      this.name = "RenderingError";
      this.message = message;
      this.stack = new Error(message).stack;
    }
    XTRenderingError.prototype = new XTError();
    function XTScopeParserError(message) {
      this.name = "ScopeParserError";
      this.message = message;
      this.stack = new Error(message).stack;
    }
    XTScopeParserError.prototype = new XTError();
    function XTInternalError$2(message) {
      this.name = "InternalError";
      this.properties = {
        explanation: "InternalError"
      };
      this.message = message;
      this.stack = new Error(message).stack;
    }
    XTInternalError$2.prototype = new XTError();
    function XTAPIVersionError(message) {
      this.name = "APIVersionError";
      this.properties = {
        explanation: "APIVersionError"
      };
      this.message = message;
      this.stack = new Error(message).stack;
    }
    XTAPIVersionError.prototype = new XTError();
    function throwApiVersionError$1(msg, properties2) {
      var err = new XTAPIVersionError(msg);
      err.properties = _objectSpread$2({
        id: "api_version_error"
      }, properties2);
      throw err;
    }
    function throwMultiError$1(errors2) {
      var err = new XTTemplateError$2("Multi error");
      err.properties = {
        errors: errors2,
        id: "multi_error",
        explanation: "The template has multiple errors"
      };
      throw err;
    }
    function getUnopenedTagException$1(options) {
      var err = new XTTemplateError$2("Unopened tag");
      err.properties = {
        xtag: last$3(options.xtag.split(" ")),
        id: "unopened_tag",
        context: options.xtag,
        offset: options.offset,
        lIndex: options.lIndex,
        explanation: 'The tag beginning with "'.concat(options.xtag.substr(0, 10), '" is unopened')
      };
      return err;
    }
    function getDuplicateOpenTagException$1(options) {
      var err = new XTTemplateError$2("Duplicate open tag, expected one open tag");
      err.properties = {
        xtag: first$2(options.xtag.split(" ")),
        id: "duplicate_open_tag",
        context: options.xtag,
        offset: options.offset,
        lIndex: options.lIndex,
        explanation: 'The tag beginning with "'.concat(options.xtag.substr(0, 10), '" has duplicate open tags')
      };
      return err;
    }
    function getDuplicateCloseTagException$1(options) {
      var err = new XTTemplateError$2("Duplicate close tag, expected one close tag");
      err.properties = {
        xtag: first$2(options.xtag.split(" ")),
        id: "duplicate_close_tag",
        context: options.xtag,
        offset: options.offset,
        lIndex: options.lIndex,
        explanation: 'The tag ending with "'.concat(options.xtag.substr(0, 10), '" has duplicate close tags')
      };
      return err;
    }
    function getUnclosedTagException$1(options) {
      var err = new XTTemplateError$2("Unclosed tag");
      err.properties = {
        xtag: first$2(options.xtag.split(" ")).substr(1),
        id: "unclosed_tag",
        context: options.xtag,
        offset: options.offset,
        lIndex: options.lIndex,
        explanation: 'The tag beginning with "'.concat(options.xtag.substr(0, 10), '" is unclosed')
      };
      return err;
    }
    function throwXmlTagNotFound$1(options) {
      var err = new XTTemplateError$2('No tag "'.concat(options.element, '" was found at the ').concat(options.position));
      var part = options.parsed[options.index];
      err.properties = {
        id: "no_xml_tag_found_at_".concat(options.position),
        explanation: 'No tag "'.concat(options.element, '" was found at the ').concat(options.position),
        offset: part.offset,
        part,
        parsed: options.parsed,
        index: options.index,
        element: options.element
      };
      throw err;
    }
    function getCorruptCharactersException(_ref) {
      var tag = _ref.tag, value = _ref.value, offset = _ref.offset;
      var err = new XTRenderingError("There are some XML corrupt characters");
      err.properties = {
        id: "invalid_xml_characters",
        xtag: tag,
        value,
        offset,
        explanation: "There are some corrupt characters for the field ".concat(tag)
      };
      return err;
    }
    function getInvalidRawXMLValueException(_ref2) {
      var tag = _ref2.tag, value = _ref2.value, offset = _ref2.offset;
      var err = new XTRenderingError("Non string values are not allowed for rawXML tags");
      err.properties = {
        id: "invalid_raw_xml_value",
        xtag: tag,
        value,
        offset,
        explanation: "The value of the raw tag : '".concat(tag, "' is not a string")
      };
      return err;
    }
    function throwExpandNotFound$1(options) {
      var _options$part = options.part, value = _options$part.value, offset = _options$part.offset, _options$id = options.id, id2 = _options$id === void 0 ? "raw_tag_outerxml_invalid" : _options$id, _options$message = options.message, message = _options$message === void 0 ? "Raw tag not in paragraph" : _options$message;
      var part = options.part;
      var _options$explanation = options.explanation, explanation = _options$explanation === void 0 ? 'The tag "'.concat(value, '" is not inside a paragraph') : _options$explanation;
      if (typeof explanation === "function") {
        explanation = explanation(part);
      }
      var err = new XTTemplateError$2(message);
      err.properties = {
        id: id2,
        explanation,
        rootError: options.rootError,
        xtag: value,
        offset,
        postparsed: options.postparsed,
        expandTo: options.expandTo,
        index: options.index
      };
      throw err;
    }
    function throwRawTagShouldBeOnlyTextInParagraph(options) {
      var err = new XTTemplateError$2("Raw tag should be the only text in paragraph");
      var tag = options.part.value;
      err.properties = {
        id: "raw_xml_tag_should_be_only_text_in_paragraph",
        explanation: 'The raw tag "'.concat(tag, '" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.'),
        xtag: tag,
        offset: options.part.offset,
        paragraphParts: options.paragraphParts
      };
      throw err;
    }
    function getUnmatchedLoopException(part) {
      var location2 = part.location, offset = part.offset, square = part.square;
      var t2 = location2 === "start" ? "unclosed" : "unopened";
      var T2 = location2 === "start" ? "Unclosed" : "Unopened";
      var err = new XTTemplateError$2("".concat(T2, " loop"));
      var tag = part.value;
      err.properties = {
        id: "".concat(t2, "_loop"),
        explanation: 'The loop with tag "'.concat(tag, '" is ').concat(t2),
        xtag: tag,
        offset
      };
      if (square) {
        err.properties.square = square;
      }
      return err;
    }
    function getUnbalancedLoopException(pair, lastPair) {
      var err = new XTTemplateError$2("Unbalanced loop tag");
      var lastL = lastPair[0].part.value;
      var lastR = lastPair[1].part.value;
      var l2 = pair[0].part.value;
      var r2 = pair[1].part.value;
      err.properties = {
        id: "unbalanced_loop_tags",
        explanation: "Unbalanced loop tags {#".concat(lastL, "}{/").concat(lastR, "}{#").concat(l2, "}{/").concat(r2, "}"),
        offset: [lastPair[0].part.offset, pair[1].part.offset],
        lastPair: {
          left: lastPair[0].part.value,
          right: lastPair[1].part.value
        },
        pair: {
          left: pair[0].part.value,
          right: pair[1].part.value
        }
      };
      return err;
    }
    function getClosingTagNotMatchOpeningTag(_ref3) {
      var tags2 = _ref3.tags;
      var err = new XTTemplateError$2("Closing tag does not match opening tag");
      err.properties = {
        id: "closing_tag_does_not_match_opening_tag",
        explanation: 'The tag "'.concat(tags2[0].value, '" is closed by the tag "').concat(tags2[1].value, '"'),
        openingtag: first$2(tags2).value,
        offset: [first$2(tags2).offset, last$3(tags2).offset],
        closingtag: last$3(tags2).value
      };
      return err;
    }
    function getScopeCompilationError(_ref4) {
      var tag = _ref4.tag, rootError = _ref4.rootError, offset = _ref4.offset;
      var err = new XTScopeParserError("Scope parser compilation failed");
      err.properties = {
        id: "scopeparser_compilation_failed",
        offset,
        xtag: tag,
        explanation: 'The scope parser for the tag "'.concat(tag, '" failed to compile'),
        rootError
      };
      return err;
    }
    function getScopeParserExecutionError$1(_ref5) {
      var tag = _ref5.tag, scope = _ref5.scope, error = _ref5.error, offset = _ref5.offset;
      var err = new XTScopeParserError("Scope parser execution failed");
      err.properties = {
        id: "scopeparser_execution_failed",
        explanation: "The scope parser for the tag ".concat(tag, " failed to execute"),
        scope,
        offset,
        xtag: tag,
        rootError: error
      };
      return err;
    }
    function getLoopPositionProducesInvalidXMLError$1(_ref6) {
      var tag = _ref6.tag, offset = _ref6.offset;
      var err = new XTTemplateError$2('The position of the loop tags "'.concat(tag, '" would produce invalid XML'));
      err.properties = {
        xtag: tag,
        id: "loop_position_invalid",
        explanation: 'The tags "'.concat(tag, '" are misplaced in the document, for example one of them is in a table and the other one outside the table'),
        offset
      };
      return err;
    }
    function throwUnimplementedTagType(part, index2) {
      var errorMsg = 'Unimplemented tag type "'.concat(part.type, '"');
      if (part.module) {
        errorMsg += ' "'.concat(part.module, '"');
      }
      var err = new XTTemplateError$2(errorMsg);
      err.properties = {
        part,
        index: index2,
        id: "unimplemented_tag_type"
      };
      throw err;
    }
    function throwMalformedXml$1() {
      var err = new XTInternalError$2("Malformed xml");
      err.properties = {
        explanation: "The template contains malformed xml",
        id: "malformed_xml"
      };
      throw err;
    }
    function throwResolveBeforeCompile$1() {
      var err = new XTInternalError$2("You must run `.compile()` before running `.resolveData()`");
      err.properties = {
        id: "resolve_before_compile",
        explanation: "You must run `.compile()` before running `.resolveData()`"
      };
      throw err;
    }
    function throwRenderInvalidTemplate$1() {
      var err = new XTInternalError$2("You should not call .render on a document that had compilation errors");
      err.properties = {
        id: "render_on_invalid_template",
        explanation: "You should not call .render on a document that had compilation errors"
      };
      throw err;
    }
    function throwRenderTwice$1() {
      var err = new XTInternalError$2("You should not call .render twice on the same docxtemplater instance");
      err.properties = {
        id: "render_twice",
        explanation: "You should not call .render twice on the same docxtemplater instance"
      };
      throw err;
    }
    function throwFileTypeNotIdentified$1() {
      var err = new XTInternalError$2("The filetype for this file could not be identified, is this file corrupted ?");
      err.properties = {
        id: "filetype_not_identified",
        explanation: "The filetype for this file could not be identified, is this file corrupted ?"
      };
      throw err;
    }
    function throwXmlInvalid$1(content, offset) {
      var err = new XTTemplateError$2("An XML file has invalid xml");
      err.properties = {
        id: "file_has_invalid_xml",
        content,
        offset,
        explanation: "The docx contains invalid XML, it is most likely corrupt"
      };
      throw err;
    }
    function throwFileTypeNotHandled$1(fileType) {
      var err = new XTInternalError$2('The filetype "'.concat(fileType, '" is not handled by docxtemplater'));
      err.properties = {
        id: "filetype_not_handled",
        explanation: 'The file you are trying to generate is of type "'.concat(fileType, '", but only docx and pptx formats are handled'),
        fileType
      };
      throw err;
    }
    var errors = {
      XTError,
      XTTemplateError: XTTemplateError$2,
      XTInternalError: XTInternalError$2,
      XTScopeParserError,
      XTAPIVersionError,
      // Remove this alias in v4
      RenderingError: XTRenderingError,
      XTRenderingError,
      getClosingTagNotMatchOpeningTag,
      getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError$1,
      getScopeCompilationError,
      getScopeParserExecutionError: getScopeParserExecutionError$1,
      getUnclosedTagException: getUnclosedTagException$1,
      getUnopenedTagException: getUnopenedTagException$1,
      getUnmatchedLoopException,
      getDuplicateCloseTagException: getDuplicateCloseTagException$1,
      getDuplicateOpenTagException: getDuplicateOpenTagException$1,
      getCorruptCharactersException,
      getInvalidRawXMLValueException,
      getUnbalancedLoopException,
      throwApiVersionError: throwApiVersionError$1,
      throwFileTypeNotHandled: throwFileTypeNotHandled$1,
      throwFileTypeNotIdentified: throwFileTypeNotIdentified$1,
      throwMalformedXml: throwMalformedXml$1,
      throwMultiError: throwMultiError$1,
      throwExpandNotFound: throwExpandNotFound$1,
      throwRawTagShouldBeOnlyTextInParagraph,
      throwUnimplementedTagType,
      throwXmlTagNotFound: throwXmlTagNotFound$1,
      throwXmlInvalid: throwXmlInvalid$1,
      throwResolveBeforeCompile: throwResolveBeforeCompile$1,
      throwRenderInvalidTemplate: throwRenderInvalidTemplate$1,
      throwRenderTwice: throwRenderTwice$1
    };
    function _typeof$5(obj) {
      "@babel/helpers - typeof";
      return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$5(obj);
    }
    function _slicedToArray$2(arr, i2) {
      return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$2();
    }
    function _nonIterableRest$2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray$2(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray$2(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray$2(o2, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _iterableToArrayLimit$2(arr, i2) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i2) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles$2(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function ownKeys$2(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$1(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
          _defineProperty$2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty$2(obj, key, value) {
      key = _toPropertyKey$5(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey$5(arg) {
      var key = _toPrimitive$5(arg, "string");
      return _typeof$5(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive$5(input, hint) {
      if (_typeof$5(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$5(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require$5 = lib, DOMParser = _require$5.DOMParser, XMLSerializer = _require$5.XMLSerializer;
    var _require2$4 = errors, throwXmlTagNotFound = _require2$4.throwXmlTagNotFound;
    var _require3$1 = utils$1, last$2 = _require3$1.last, first$1 = _require3$1.first;
    function isWhiteSpace(value) {
      return /^[ \n\r\t]+$/.test(value);
    }
    function parser(tag) {
      return {
        get: function get(scope) {
          if (tag === ".") {
            return scope;
          }
          if (scope) {
            return scope[tag];
          }
          return scope;
        }
      };
    }
    var attrToRegex = {};
    function setSingleAttribute(partValue, attr, attrValue) {
      var regex;
      if (attrToRegex[attr]) {
        regex = attrToRegex[attr];
      } else {
        regex = new RegExp("(<.* ".concat(attr, '=")([^"]*)(".*)$'));
        attrToRegex[attr] = regex;
      }
      if (regex.test(partValue)) {
        return partValue.replace(regex, "$1".concat(attrValue, "$3"));
      }
      var end = partValue.lastIndexOf("/>");
      if (end === -1) {
        end = partValue.lastIndexOf(">");
      }
      return partValue.substr(0, end) + " ".concat(attr, '="').concat(attrValue, '"') + partValue.substr(end);
    }
    function getSingleAttribute(value, attributeName) {
      var index2 = value.indexOf(" ".concat(attributeName, '="'));
      if (index2 === -1) {
        return null;
      }
      var startIndex = value.substr(index2).search(/["']/) + index2;
      var endIndex = value.substr(startIndex + 1).search(/["']/) + startIndex;
      return value.substr(startIndex + 1, endIndex - startIndex);
    }
    function endsWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    function startsWith(str, prefix2) {
      return str.substring(0, prefix2.length) === prefix2;
    }
    function uniq$1(arr) {
      var hash2 = {}, result = [];
      for (var i2 = 0, l2 = arr.length; i2 < l2; ++i2) {
        if (!hash2[arr[i2]]) {
          hash2[arr[i2]] = true;
          result.push(arr[i2]);
        }
      }
      return result;
    }
    function chunkBy$1(parsed, f2) {
      return parsed.reduce(function(chunks, p2) {
        var currentChunk = last$2(chunks);
        var res = f2(p2);
        if (res === "start") {
          chunks.push([p2]);
        } else if (res === "end") {
          currentChunk.push(p2);
          chunks.push([]);
        } else {
          currentChunk.push(p2);
        }
        return chunks;
      }, [[]]).filter(function(p2) {
        return p2.length > 0;
      });
    }
    var defaults$1 = {
      errorLogging: "json",
      paragraphLoop: false,
      nullGetter: function nullGetter(part) {
        return part.module ? "" : "undefined";
      },
      xmlFileNames: ["[Content_Types].xml"],
      parser,
      linebreaks: false,
      fileTypeConfig: null,
      delimiters: {
        start: "{",
        end: "}"
      }
    };
    function mergeObjects() {
      var resObj = {};
      var obj;
      for (var i2 = 0; i2 < arguments.length; i2 += 1) {
        obj = arguments[i2];
        resObj = _objectSpread$1(_objectSpread$1({}, resObj), obj);
      }
      return resObj;
    }
    function xml2str$1(xmlNode) {
      var a2 = new XMLSerializer();
      return a2.serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?="" ?/g, "");
    }
    function str2xml$1(str) {
      if (str.charCodeAt(0) === 65279) {
        str = str.substr(1);
      }
      return new DOMParser().parseFromString(str, "text/xml");
    }
    var charMap = [["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&apos;"]];
    var charMapRegexes = charMap.map(function(_ref) {
      var _ref2 = _slicedToArray$2(_ref, 2), endChar = _ref2[0], startChar = _ref2[1];
      return {
        rstart: new RegExp(startChar, "g"),
        rend: new RegExp(endChar, "g"),
        start: startChar,
        end: endChar
      };
    });
    function wordToUtf8$1(string) {
      var r2;
      for (var i2 = charMapRegexes.length - 1; i2 >= 0; i2--) {
        r2 = charMapRegexes[i2];
        string = string.replace(r2.rstart, r2.end);
      }
      return string;
    }
    function utf8ToWord(string) {
      string = string.toString();
      var r2;
      for (var i2 = 0, l2 = charMapRegexes.length; i2 < l2; i2++) {
        r2 = charMapRegexes[i2];
        string = string.replace(r2.rend, r2.start);
      }
      return string;
    }
    function concatArrays$2(arrays) {
      var result = [];
      for (var i2 = 0; i2 < arrays.length; i2++) {
        var array = arrays[i2];
        for (var j2 = 0, len = array.length; j2 < len; j2++) {
          result.push(array[j2]);
        }
      }
      return result;
    }
    var spaceRegexp = new RegExp(String.fromCharCode(160), "g");
    function convertSpaces(s2) {
      return s2.replace(spaceRegexp, " ");
    }
    function pregMatchAll(regex, content) {
      var matchArray = [];
      var match2;
      while ((match2 = regex.exec(content)) != null) {
        matchArray.push({
          array: match2,
          offset: match2.index
        });
      }
      return matchArray;
    }
    function isEnding(value, element) {
      return value === "</" + element + ">";
    }
    function isStarting(value, element) {
      return value.indexOf("<" + element) === 0 && [">", " ", "/"].indexOf(value[element.length + 1]) !== -1;
    }
    function getRight$1(parsed, element, index2) {
      var val = getRightOrNull$1(parsed, element, index2);
      if (val !== null) {
        return val;
      }
      throwXmlTagNotFound({
        position: "right",
        element,
        parsed,
        index: index2
      });
    }
    function getRightOrNull$1(parsed, elements, index2) {
      if (typeof elements === "string") {
        elements = [elements];
      }
      var level = 1;
      for (var i2 = index2, l2 = parsed.length; i2 < l2; i2++) {
        var part = parsed[i2];
        for (var j2 = 0, len = elements.length; j2 < len; j2++) {
          var element = elements[j2];
          if (isEnding(part.value, element)) {
            level--;
          }
          if (isStarting(part.value, element)) {
            level++;
          }
          if (level === 0) {
            return i2;
          }
        }
      }
      return null;
    }
    function getLeft$1(parsed, element, index2) {
      var val = getLeftOrNull$1(parsed, element, index2);
      if (val !== null) {
        return val;
      }
      throwXmlTagNotFound({
        position: "left",
        element,
        parsed,
        index: index2
      });
    }
    function getLeftOrNull$1(parsed, elements, index2) {
      if (typeof elements === "string") {
        elements = [elements];
      }
      var level = 1;
      for (var i2 = index2; i2 >= 0; i2--) {
        var part = parsed[i2];
        for (var j2 = 0, len = elements.length; j2 < len; j2++) {
          var element = elements[j2];
          if (isStarting(part.value, element)) {
            level--;
          }
          if (isEnding(part.value, element)) {
            level++;
          }
          if (level === 0) {
            return i2;
          }
        }
      }
      return null;
    }
    function isTagStart$1(tagType, _ref3) {
      var type = _ref3.type, tag = _ref3.tag, position2 = _ref3.position;
      return type === "tag" && tag === tagType && (position2 === "start" || position2 === "selfclosing");
    }
    function isTagStartStrict(tagType, _ref4) {
      var type = _ref4.type, tag = _ref4.tag, position2 = _ref4.position;
      return type === "tag" && tag === tagType && position2 === "start";
    }
    function isTagEnd$1(tagType, _ref5) {
      var type = _ref5.type, tag = _ref5.tag, position2 = _ref5.position;
      return type === "tag" && tag === tagType && position2 === "end";
    }
    function isParagraphStart(part) {
      return isTagStartStrict("w:p", part) || isTagStartStrict("a:p", part);
    }
    function isParagraphEnd(part) {
      return isTagEnd$1("w:p", part) || isTagEnd$1("a:p", part);
    }
    function isTextStart$1(_ref6) {
      var type = _ref6.type, position2 = _ref6.position, text = _ref6.text;
      return type === "tag" && position2 === "start" && text;
    }
    function isTextEnd$1(_ref7) {
      var type = _ref7.type, position2 = _ref7.position, text = _ref7.text;
      return type === "tag" && position2 === "end" && text;
    }
    function isContent$1(_ref8) {
      var type = _ref8.type, position2 = _ref8.position;
      return type === "placeholder" || type === "content" && position2 === "insidetag";
    }
    function isModule(_ref9, modules) {
      var module2 = _ref9.module, type = _ref9.type;
      if (!(modules instanceof Array)) {
        modules = [modules];
      }
      return type === "placeholder" && modules.indexOf(module2) !== -1;
    }
    var corruptCharacters = /[\x00-\x08\x0B\x0C\x0E-\x1F]/;
    function hasCorruptCharacters(string) {
      return corruptCharacters.test(string);
    }
    function invertMap(map) {
      return Object.keys(map).reduce(function(invertedMap, key) {
        var value = map[key];
        invertedMap[value] = invertedMap[value] || [];
        invertedMap[value].push(key);
        return invertedMap;
      }, {});
    }
    function stableSort$1(arr, compare) {
      return arr.map(function(item, index2) {
        return {
          item,
          index: index2
        };
      }).sort(function(a2, b2) {
        return compare(a2.item, b2.item) || a2.index - b2.index;
      }).map(function(_ref10) {
        var item = _ref10.item;
        return item;
      });
    }
    var docUtils = {
      endsWith,
      startsWith,
      isContent: isContent$1,
      isParagraphStart,
      isParagraphEnd,
      isTagStart: isTagStart$1,
      isTagEnd: isTagEnd$1,
      isTextStart: isTextStart$1,
      isTextEnd: isTextEnd$1,
      isStarting,
      isEnding,
      isModule,
      uniq: uniq$1,
      chunkBy: chunkBy$1,
      last: last$2,
      first: first$1,
      mergeObjects,
      xml2str: xml2str$1,
      str2xml: str2xml$1,
      getRightOrNull: getRightOrNull$1,
      getRight: getRight$1,
      getLeftOrNull: getLeftOrNull$1,
      getLeft: getLeft$1,
      pregMatchAll,
      convertSpaces,
      charMapRegexes,
      hasCorruptCharacters,
      defaults: defaults$1,
      wordToUtf8: wordToUtf8$1,
      utf8ToWord,
      concatArrays: concatArrays$2,
      invertMap,
      charMap,
      getSingleAttribute,
      setSingleAttribute,
      isWhiteSpace,
      stableSort: stableSort$1
    };
    function _typeof$4(obj) {
      "@babel/helpers - typeof";
      return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$4(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray$1(arr);
    }
    function _slicedToArray$1(arr, i2) {
      return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
    }
    function _nonIterableRest$1() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray$1(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray$1(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray$1(o2, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _iterableToArrayLimit$1(arr, i2) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i2) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles$1(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function ownKeys$1(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty$1(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty$1(obj, key, value) {
      key = _toPropertyKey$4(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey$4(arg) {
      var key = _toPrimitive$4(arg, "string");
      return _typeof$4(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive$4(input, hint) {
      if (_typeof$4(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$4(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require$4 = docUtils, getRightOrNull = _require$4.getRightOrNull, getRight = _require$4.getRight, getLeft = _require$4.getLeft, getLeftOrNull = _require$4.getLeftOrNull, chunkBy = _require$4.chunkBy, isTagStart = _require$4.isTagStart, isTagEnd = _require$4.isTagEnd, isContent = _require$4.isContent, last$1 = _require$4.last, first = _require$4.first;
    var _require2$3 = errors, XTTemplateError$1 = _require2$3.XTTemplateError, throwExpandNotFound = _require2$3.throwExpandNotFound, getLoopPositionProducesInvalidXMLError = _require2$3.getLoopPositionProducesInvalidXMLError;
    function lastTagIsOpenTag(tags2, tag) {
      if (tags2.length === 0) {
        return false;
      }
      var innerLastTag = last$1(tags2).substr(1);
      return innerLastTag.indexOf(tag) === 0;
    }
    function getListXmlElements(parts) {
      var result = [];
      for (var i2 = 0; i2 < parts.length; i2++) {
        var _parts$i = parts[i2], position2 = _parts$i.position, value = _parts$i.value, tag = _parts$i.tag;
        if (!tag) {
          continue;
        }
        if (position2 === "end") {
          if (lastTagIsOpenTag(result, tag)) {
            result.pop();
          } else {
            result.push(value);
          }
        } else if (position2 === "start") {
          result.push(value);
        }
      }
      return result;
    }
    function has(name, xmlElements) {
      for (var i2 = 0; i2 < xmlElements.length; i2++) {
        var xmlElement = xmlElements[i2];
        if (xmlElement.indexOf("<".concat(name)) === 0) {
          return true;
        }
      }
      return false;
    }
    function getExpandToDefault(postparsed, pair, expandTags) {
      var parts = postparsed.slice(pair[0].offset, pair[1].offset);
      var xmlElements = getListXmlElements(parts);
      var closingTagCount = xmlElements.filter(function(tag) {
        return tag[1] === "/";
      }).length;
      var startingTagCount = xmlElements.filter(function(tag) {
        return tag[1] !== "/" && tag[tag.length - 2] !== "/";
      }).length;
      if (closingTagCount !== startingTagCount) {
        return {
          error: getLoopPositionProducesInvalidXMLError({
            tag: first(pair).part.value,
            offset: [first(pair).part.offset, last$1(pair).part.offset]
          })
        };
      }
      var _loop = function _loop2() {
        var _expandTags$i = expandTags[i2], contains = _expandTags$i.contains, expand = _expandTags$i.expand, onlyTextInTag = _expandTags$i.onlyTextInTag;
        if (has(contains, xmlElements)) {
          if (onlyTextInTag) {
            var left = getLeftOrNull(postparsed, contains, pair[0].offset);
            var right = getRightOrNull(postparsed, contains, pair[1].offset);
            if (left === null || right === null) {
              return 0;
            }
            var chunks = chunkBy(postparsed.slice(left, right), function(p2) {
              return isTagStart(contains, p2) ? "start" : isTagEnd(contains, p2) ? "end" : null;
            });
            var firstChunk = first(chunks);
            var lastChunk = last$1(chunks);
            var firstContent = firstChunk.filter(isContent);
            var lastContent = lastChunk.filter(isContent);
            if (firstContent.length !== 1 || lastContent.length !== 1) {
              return 0;
            }
          }
          return {
            v: {
              value: expand
            }
          };
        }
      }, _ret;
      for (var i2 = 0, len = expandTags.length; i2 < len; i2++) {
        _ret = _loop();
        if (_ret === 0)
          continue;
        if (_ret)
          return _ret.v;
      }
      return {};
    }
    function getExpandLimit(part, index2, postparsed, options) {
      var expandTo = part.expandTo || options.expandTo;
      if (!expandTo) {
        return;
      }
      var right, left;
      try {
        left = getLeft(postparsed, expandTo, index2);
        right = getRight(postparsed, expandTo, index2);
      } catch (rootError) {
        if (rootError instanceof XTTemplateError$1) {
          throwExpandNotFound(_objectSpread({
            part,
            rootError,
            postparsed,
            expandTo,
            index: index2
          }, options.error));
        }
        throw rootError;
      }
      return [left, right];
    }
    function expandOne(_ref, part, postparsed, options) {
      var _ref2 = _slicedToArray$1(_ref, 2), left = _ref2[0], right = _ref2[1];
      var index2 = postparsed.indexOf(part);
      var leftParts = postparsed.slice(left, index2);
      var rightParts = postparsed.slice(index2 + 1, right + 1);
      var inner = options.getInner({
        postparse: options.postparse,
        index: index2,
        part,
        leftParts,
        rightParts,
        left,
        right,
        postparsed
      });
      if (!inner.length) {
        inner.expanded = [leftParts, rightParts];
        inner = [inner];
      }
      return {
        left,
        right,
        inner
      };
    }
    function expandToOne(postparsed, options) {
      var errors2 = [];
      if (postparsed.errors) {
        errors2 = postparsed.errors;
        postparsed = postparsed.postparsed;
      }
      var limits = [];
      for (var i2 = 0, len = postparsed.length; i2 < len; i2++) {
        var part = postparsed[i2];
        if (part.type === "placeholder" && part.module === options.moduleName && // The part.subparsed check is used to fix this github issue :
        // https://github.com/open-xml-templating/docxtemplater/issues/671
        !part.subparsed) {
          try {
            var limit = getExpandLimit(part, i2, postparsed, options);
            if (!limit) {
              continue;
            }
            var _limit = _slicedToArray$1(limit, 2), left = _limit[0], right = _limit[1];
            limits.push({
              left,
              right,
              part,
              i: i2,
              leftPart: postparsed[left],
              rightPart: postparsed[right]
            });
          } catch (error) {
            if (error instanceof XTTemplateError$1) {
              errors2.push(error);
            } else {
              throw error;
            }
          }
        }
      }
      limits.sort(function(l1, l2) {
        if (l1.left === l2.left) {
          return l2.part.lIndex < l1.part.lIndex ? 1 : -1;
        }
        return l2.left < l1.left ? 1 : -1;
      });
      var maxRight = -1;
      var offset = 0;
      limits.forEach(function(limit2, i3) {
        var _postparsed;
        maxRight = Math.max(maxRight, i3 > 0 ? limits[i3 - 1].right : 0);
        if (limit2.left < maxRight) {
          return;
        }
        var result;
        try {
          result = expandOne([limit2.left + offset, limit2.right + offset], limit2.part, postparsed, options);
        } catch (error) {
          if (error instanceof XTTemplateError$1) {
            errors2.push(error);
          } else {
            throw error;
          }
        }
        if (!result) {
          return;
        }
        offset += result.inner.length - (result.right + 1 - result.left);
        (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));
      });
      return {
        postparsed,
        errors: errors2
      };
    }
    var traits = {
      expandToOne,
      getExpandToDefault
    };
    var _require$3 = errors, XTInternalError$1 = _require$3.XTInternalError;
    function emptyFun() {
    }
    function identity(i2) {
      return i2;
    }
    var moduleWrapper$1 = function(module2) {
      var defaults2 = {
        set: emptyFun,
        matchers: function matchers() {
          return [];
        },
        parse: emptyFun,
        render: emptyFun,
        getTraits: emptyFun,
        getFileType: emptyFun,
        nullGetter: emptyFun,
        optionsTransformer: identity,
        postrender: identity,
        errorsTransformer: identity,
        getRenderedMap: identity,
        preparse: identity,
        postparse: identity,
        on: emptyFun,
        resolve: emptyFun
      };
      if (Object.keys(defaults2).every(function(key) {
        return !module2[key];
      })) {
        var err = new XTInternalError$1("This module cannot be wrapped, because it doesn't define any of the necessary functions");
        err.properties = {
          id: "module_cannot_be_wrapped",
          explanation: "This module cannot be wrapped, because it doesn't define any of the necessary functions"
        };
        throw err;
      }
      Object.keys(defaults2).forEach(function(key) {
        module2[key] = module2[key] || defaults2[key];
      });
      return module2;
    };
    function _typeof$3(obj) {
      "@babel/helpers - typeof";
      return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$3(obj);
    }
    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
      }
    }
    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties$2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties$2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey$3(arg) {
      var key = _toPrimitive$3(arg, "string");
      return _typeof$3(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive$3(input, hint) {
      if (_typeof$3(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$3(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require$2 = errors, getScopeParserExecutionError = _require$2.getScopeParserExecutionError;
    var _require2$2 = utils$1, last = _require2$2.last;
    var _require3 = docUtils, concatArrays$1 = _require3.concatArrays;
    function find(list, fn2) {
      var length2 = list.length >>> 0;
      var value;
      for (var i2 = 0; i2 < length2; i2++) {
        value = list[i2];
        if (fn2.call(this, value, i2, list)) {
          return value;
        }
      }
      return void 0;
    }
    function _getValue(tag, meta, num) {
      var _this = this;
      var scope = this.scopeList[num];
      if (this.root.finishedResolving) {
        var w2 = this.resolved;
        var _loop = function _loop2() {
          var lIndex = _this.scopeLindex[i2];
          w2 = find(w2, function(r2) {
            return r2.lIndex === lIndex;
          });
          w2 = w2.value[_this.scopePathItem[i2]];
        };
        for (var i2 = this.resolveOffset, len = this.scopePath.length; i2 < len; i2++) {
          _loop();
        }
        return find(w2, function(r2) {
          return meta.part.lIndex === r2.lIndex;
        }).value;
      }
      var result;
      var parser2;
      if (!this.cachedParsers || !meta.part) {
        parser2 = this.parser(tag, {
          scopePath: this.scopePath
        });
      } else if (this.cachedParsers[meta.part.lIndex]) {
        parser2 = this.cachedParsers[meta.part.lIndex];
      } else {
        parser2 = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {
          scopePath: this.scopePath
        });
      }
      try {
        result = parser2.get(scope, this.getContext(meta, num));
      } catch (error) {
        throw getScopeParserExecutionError({
          tag,
          scope,
          error,
          offset: meta.part.offset
        });
      }
      if (result == null && num > 0) {
        return _getValue.call(this, tag, meta, num - 1);
      }
      return result;
    }
    function _getValueAsync(tag, meta, num) {
      var _this2 = this;
      var scope = this.scopeList[num];
      var parser2;
      if (!this.cachedParsers || !meta.part) {
        parser2 = this.parser(tag, {
          scopePath: this.scopePath
        });
      } else if (this.cachedParsers[meta.part.lIndex]) {
        parser2 = this.cachedParsers[meta.part.lIndex];
      } else {
        parser2 = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {
          scopePath: this.scopePath
        });
      }
      return Promise.resolve().then(function() {
        return parser2.get(scope, _this2.getContext(meta, num));
      })["catch"](function(error) {
        throw getScopeParserExecutionError({
          tag,
          scope,
          error,
          offset: meta.part.offset
        });
      }).then(function(result) {
        if (result == null && num > 0) {
          return _getValueAsync.call(_this2, tag, meta, num - 1);
        }
        return result;
      });
    }
    var ScopeManager = /* @__PURE__ */ function() {
      function ScopeManager2(options) {
        _classCallCheck$2(this, ScopeManager2);
        this.root = options.root || this;
        this.resolveOffset = options.resolveOffset || 0;
        this.scopePath = options.scopePath;
        this.scopePathItem = options.scopePathItem;
        this.scopePathLength = options.scopePathLength;
        this.scopeList = options.scopeList;
        this.scopeType = "";
        this.scopeTypes = options.scopeTypes;
        this.scopeLindex = options.scopeLindex;
        this.parser = options.parser;
        this.resolved = options.resolved;
        this.cachedParsers = options.cachedParsers;
      }
      _createClass$2(ScopeManager2, [{
        key: "loopOver",
        value: function loopOver(tag, functor, inverted, meta) {
          return this.loopOverValue(this.getValue(tag, meta), functor, inverted);
        }
      }, {
        key: "functorIfInverted",
        value: function functorIfInverted(inverted, functor, value, i2, length2) {
          if (inverted) {
            functor(value, i2, length2);
          }
          return inverted;
        }
      }, {
        key: "isValueFalsy",
        value: function isValueFalsy(value, type) {
          return value == null || !value || type === "[object Array]" && value.length === 0;
        }
      }, {
        key: "loopOverValue",
        value: function loopOverValue(value, functor, inverted) {
          if (this.root.finishedResolving) {
            inverted = false;
          }
          var type = Object.prototype.toString.call(value);
          if (this.isValueFalsy(value, type)) {
            this.scopeType = false;
            return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);
          }
          if (type === "[object Array]") {
            this.scopeType = "array";
            for (var i2 = 0; i2 < value.length; i2++) {
              this.functorIfInverted(!inverted, functor, value[i2], i2, value.length);
            }
            return true;
          }
          if (type === "[object Object]") {
            this.scopeType = "object";
            return this.functorIfInverted(!inverted, functor, value, 0, 1);
          }
          return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);
        }
      }, {
        key: "getValue",
        value: function getValue2(tag, meta) {
          var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);
          if (typeof result === "function") {
            return result(this.scopeList[this.scopeList.length - 1], this);
          }
          return result;
        }
      }, {
        key: "getValueAsync",
        value: function getValueAsync(tag, meta) {
          var _this3 = this;
          return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function(result) {
            if (typeof result === "function") {
              return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);
            }
            return result;
          });
        }
      }, {
        key: "getContext",
        value: function getContext2(meta, num) {
          return {
            num,
            meta,
            scopeList: this.scopeList,
            resolved: this.resolved,
            scopePath: this.scopePath,
            scopeTypes: this.scopeTypes,
            scopePathItem: this.scopePathItem,
            scopePathLength: this.scopePathLength
          };
        }
      }, {
        key: "createSubScopeManager",
        value: function createSubScopeManager(scope, tag, i2, part, length2) {
          return new ScopeManager2({
            root: this.root,
            resolveOffset: this.resolveOffset,
            resolved: this.resolved,
            parser: this.parser,
            cachedParsers: this.cachedParsers,
            scopeTypes: concatArrays$1([this.scopeTypes, [this.scopeType]]),
            scopeList: concatArrays$1([this.scopeList, [scope]]),
            scopePath: concatArrays$1([this.scopePath, [tag]]),
            scopePathItem: concatArrays$1([this.scopePathItem, [i2]]),
            scopePathLength: concatArrays$1([this.scopePathLength, [length2]]),
            scopeLindex: concatArrays$1([this.scopeLindex, [part.lIndex]])
          });
        }
      }]);
      return ScopeManager2;
    }();
    var scopeManager = function(options) {
      options.scopePath = [];
      options.scopePathItem = [];
      options.scopePathLength = [];
      options.scopeTypes = [];
      options.scopeLindex = [];
      options.scopeList = [options.tags];
      return new ScopeManager(options);
    };
    function replaceErrors(key, value) {
      if (value instanceof Error) {
        return Object.getOwnPropertyNames(value).concat("stack").reduce(function(error, key2) {
          error[key2] = value[key2];
          if (key2 === "stack") {
            error[key2] = value[key2].toString();
          }
          return error;
        }, {});
      }
      return value;
    }
    function logger(error, logging) {
      console.log(JSON.stringify({
        error
      }, replaceErrors, logging === "json" ? 2 : null));
      if (error.properties && error.properties.errors instanceof Array) {
        var errorMessages = error.properties.errors.map(function(error2) {
          return error2.properties.explanation;
        }).join("\n");
        console.log("errorMessages", errorMessages);
      }
    }
    var errorLogger = logger;
    var ctXML$1 = "[Content_Types].xml";
    function collectContentTypes$1(overrides, defaults2, zip) {
      var partNames = {};
      for (var i2 = 0, len = overrides.length; i2 < len; i2++) {
        var override = overrides[i2];
        var contentType = override.getAttribute("ContentType");
        var partName = override.getAttribute("PartName").substr(1);
        partNames[partName] = contentType;
      }
      var _loop = function _loop2() {
        var def = defaults2[_i];
        var contentType2 = def.getAttribute("ContentType");
        var extension = def.getAttribute("Extension");
        zip.file(/./).map(function(_ref) {
          var name = _ref.name;
          if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML$1) {
            partNames[name] = contentType2;
          }
        });
      };
      for (var _i = 0, _len = defaults2.length; _i < _len; _i++) {
        _loop();
      }
      return partNames;
    }
    var collectContentTypes_1 = collectContentTypes$1;
    var docxContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml";
    var docxmContentType = "application/vnd.ms-word.document.macroEnabled.main+xml";
    var dotxContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml";
    var dotmContentType = "application/vnd.ms-word.template.macroEnabledTemplate.main+xml";
    var headerContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml";
    var footnotesContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml";
    var footerContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml";
    var pptxContentType = "application/vnd.openxmlformats-officedocument.presentationml.slide+xml";
    var pptxSlideMaster = "application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml";
    var pptxSlideLayout = "application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml";
    var pptxPresentationContentType = "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml";
    var main = [docxContentType, docxmContentType, dotxContentType, dotmContentType];
    var filetypes$1 = {
      main,
      docx: [headerContentType].concat(main, [footerContentType, footnotesContentType]),
      pptx: [pptxContentType, pptxSlideMaster, pptxSlideLayout, pptxPresentationContentType]
    };
    var filetypes_1 = filetypes$1;
    function _typeof$2(obj) {
      "@babel/helpers - typeof";
      return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$2(obj);
    }
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$1(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
      }
    }
    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties$1(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey$2(arg) {
      var key = _toPrimitive$2(arg, "string");
      return _typeof$2(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive$2(input, hint) {
      if (_typeof$2(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$2(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var wrapper = moduleWrapper$1;
    var filetypes = filetypes_1;
    var coreContentType = "application/vnd.openxmlformats-package.core-properties+xml";
    var appContentType = "application/vnd.openxmlformats-officedocument.extended-properties+xml";
    var customContentType = "application/vnd.openxmlformats-officedocument.custom-properties+xml";
    var settingsContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml";
    var commonContentTypes = [settingsContentType, coreContentType, appContentType, customContentType];
    var Common = /* @__PURE__ */ function() {
      function Common2() {
        _classCallCheck$1(this, Common2);
        this.name = "Common";
      }
      _createClass$1(Common2, [{
        key: "getFileType",
        value: function getFileType(_ref) {
          var doc = _ref.doc;
          var invertedContentTypes = doc.invertedContentTypes;
          if (!invertedContentTypes) {
            return;
          }
          for (var j2 = 0, len2 = commonContentTypes.length; j2 < len2; j2++) {
            var ct = commonContentTypes[j2];
            if (invertedContentTypes[ct]) {
              Array.prototype.push.apply(doc.targets, invertedContentTypes[ct]);
            }
          }
          var keys = ["docx", "pptx"];
          var ftCandidate;
          for (var i2 = 0, len = keys.length; i2 < len; i2++) {
            var contentTypes = filetypes[keys[i2]];
            for (var _j = 0, _len = contentTypes.length; _j < _len; _j++) {
              var _ct = contentTypes[_j];
              if (invertedContentTypes[_ct]) {
                for (var k2 = 0, _len2 = invertedContentTypes[_ct].length; k2 < _len2; k2++) {
                  var target = invertedContentTypes[_ct][k2];
                  if (doc.relsTypes[target] && ["http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument"].indexOf(doc.relsTypes[target]) === -1) {
                    continue;
                  }
                  ftCandidate = keys[i2];
                  if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {
                    doc.textTarget || (doc.textTarget = target);
                  }
                  doc.targets.push(target);
                }
              }
            }
            if (ftCandidate) {
              return ftCandidate;
            }
          }
          return ftCandidate;
        }
      }]);
      return Common2;
    }();
    var common = function() {
      return wrapper(new Common());
    };
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i2) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var _require$1 = errors, getUnclosedTagException = _require$1.getUnclosedTagException, getUnopenedTagException = _require$1.getUnopenedTagException, getDuplicateOpenTagException = _require$1.getDuplicateOpenTagException, getDuplicateCloseTagException = _require$1.getDuplicateCloseTagException, throwMalformedXml = _require$1.throwMalformedXml, throwXmlInvalid = _require$1.throwXmlInvalid, XTTemplateError = _require$1.XTTemplateError;
    var _require2$1 = docUtils, isTextStart = _require2$1.isTextStart, isTextEnd = _require2$1.isTextEnd, wordToUtf8 = _require2$1.wordToUtf8;
    var DELIMITER_NONE = 0, DELIMITER_EQUAL = 1, DELIMITER_START = 2, DELIMITER_END = 3;
    function inRange(range, match2) {
      return range[0] <= match2.offset && match2.offset < range[1];
    }
    function updateInTextTag(part, inTextTag) {
      if (isTextStart(part)) {
        if (inTextTag) {
          throwMalformedXml();
        }
        return true;
      }
      if (isTextEnd(part)) {
        if (!inTextTag) {
          throwMalformedXml();
        }
        return false;
      }
      return inTextTag;
    }
    function getTag(tag) {
      var position2 = "";
      var start = 1;
      var end = tag.indexOf(" ");
      if (tag[tag.length - 2] === "/") {
        position2 = "selfclosing";
        if (end === -1) {
          end = tag.length - 2;
        }
      } else if (tag[1] === "/") {
        start = 2;
        position2 = "end";
        if (end === -1) {
          end = tag.length - 1;
        }
      } else {
        position2 = "start";
        if (end === -1) {
          end = tag.length - 1;
        }
      }
      return {
        tag: tag.slice(start, end),
        position: position2
      };
    }
    function tagMatcher(content, textMatchArray, othersMatchArray) {
      var cursor2 = 0;
      var contentLength = content.length;
      var allMatches = {};
      for (var i2 = 0, len = textMatchArray.length; i2 < len; i2++) {
        allMatches[textMatchArray[i2]] = true;
      }
      for (var _i = 0, _len = othersMatchArray.length; _i < _len; _i++) {
        allMatches[othersMatchArray[_i]] = false;
      }
      var totalMatches = [];
      while (cursor2 < contentLength) {
        cursor2 = content.indexOf("<", cursor2);
        if (cursor2 === -1) {
          break;
        }
        var offset = cursor2;
        var nextOpening = content.indexOf("<", cursor2 + 1);
        cursor2 = content.indexOf(">", cursor2);
        if (cursor2 === -1 || nextOpening !== -1 && cursor2 > nextOpening) {
          throwXmlInvalid(content, offset);
        }
        var tagText = content.slice(offset, cursor2 + 1);
        var _getTag = getTag(tagText), tag = _getTag.tag, position2 = _getTag.position;
        var text = allMatches[tag];
        if (text == null) {
          continue;
        }
        totalMatches.push({
          type: "tag",
          position: position2,
          text,
          offset,
          value: tagText,
          tag
        });
      }
      return totalMatches;
    }
    function getDelimiterErrors(delimiterMatches, fullText) {
      var errors2 = [];
      var inDelimiter = false;
      var lastDelimiterMatch = {
        offset: 0
      };
      var xtag;
      delimiterMatches.forEach(function(delimiterMatch2) {
        xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch2.offset - lastDelimiterMatch.offset);
        if (delimiterMatch2.position === "start" && inDelimiter || delimiterMatch2.position === "end" && !inDelimiter) {
          if (delimiterMatch2.position === "start") {
            if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch2.offset) {
              xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch2.offset - lastDelimiterMatch.offset + lastDelimiterMatch.length + 4);
              errors2.push(getDuplicateOpenTagException({
                xtag,
                offset: lastDelimiterMatch.offset
              }));
            } else {
              errors2.push(getUnclosedTagException({
                xtag: wordToUtf8(xtag),
                offset: lastDelimiterMatch.offset
              }));
            }
            delimiterMatch2.error = true;
          } else {
            if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch2.offset) {
              xtag = fullText.substr(lastDelimiterMatch.offset - 4, delimiterMatch2.offset - lastDelimiterMatch.offset + 4 + lastDelimiterMatch.length);
              errors2.push(getDuplicateCloseTagException({
                xtag,
                offset: lastDelimiterMatch.offset
              }));
            } else {
              errors2.push(getUnopenedTagException({
                xtag,
                offset: delimiterMatch2.offset
              }));
            }
            delimiterMatch2.error = true;
          }
        } else {
          inDelimiter = !inDelimiter;
        }
        lastDelimiterMatch = delimiterMatch2;
      });
      var delimiterMatch = {
        offset: fullText.length
      };
      xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);
      if (inDelimiter) {
        errors2.push(getUnclosedTagException({
          xtag: wordToUtf8(xtag),
          offset: lastDelimiterMatch.offset
        }));
        delimiterMatch.error = true;
      }
      return errors2;
    }
    function compareOffsets(startOffset, endOffset) {
      if (startOffset === -1 && endOffset === -1) {
        return DELIMITER_NONE;
      }
      if (startOffset === endOffset) {
        return DELIMITER_EQUAL;
      }
      if (startOffset === -1 || endOffset === -1) {
        return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;
      }
      return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;
    }
    function splitDelimiters(inside) {
      var newDelimiters = inside.split(" ");
      if (newDelimiters.length !== 2) {
        var err = new XTTemplateError("New Delimiters cannot be parsed");
        err.properties = {
          id: "change_delimiters_invalid",
          explanation: "Cannot parser delimiters"
        };
        throw err;
      }
      var _newDelimiters = _slicedToArray(newDelimiters, 2), start = _newDelimiters[0], end = _newDelimiters[1];
      if (start.length === 0 || end.length === 0) {
        var _err = new XTTemplateError("New Delimiters cannot be parsed");
        _err.properties = {
          id: "change_delimiters_invalid",
          explanation: "Cannot parser delimiters"
        };
        throw _err;
      }
      return [start, end];
    }
    function getAllDelimiterIndexes(fullText, delimiters) {
      var indexes = [];
      var start = delimiters.start, end = delimiters.end;
      var offset = -1;
      var insideTag = false;
      while (true) {
        var startOffset = fullText.indexOf(start, offset + 1);
        var endOffset = fullText.indexOf(end, offset + 1);
        var position2 = null;
        var len = void 0;
        var compareResult = compareOffsets(startOffset, endOffset);
        if (compareResult === DELIMITER_EQUAL) {
          compareResult = insideTag ? DELIMITER_END : DELIMITER_START;
        }
        switch (compareResult) {
          case DELIMITER_NONE:
            return indexes;
          case DELIMITER_END:
            insideTag = false;
            offset = endOffset;
            position2 = "end";
            len = end.length;
            break;
          case DELIMITER_START:
            insideTag = true;
            offset = startOffset;
            position2 = "start";
            len = start.length;
            break;
        }
        if (compareResult === DELIMITER_START && fullText[offset + start.length] === "=") {
          indexes.push({
            offset: startOffset,
            position: "start",
            length: start.length,
            changedelimiter: true
          });
          var nextEqual = fullText.indexOf("=", offset + start.length + 1);
          var nextEndOffset = fullText.indexOf(end, nextEqual + 1);
          indexes.push({
            offset: nextEndOffset,
            position: "end",
            length: end.length,
            changedelimiter: true
          });
          var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);
          var _splitDelimiters = splitDelimiters(_insideTag);
          var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);
          start = _splitDelimiters2[0];
          end = _splitDelimiters2[1];
          offset = nextEndOffset;
          continue;
        }
        indexes.push({
          offset,
          position: position2,
          length: len
        });
      }
    }
    function parseDelimiters(innerContentParts, delimiters) {
      var full = innerContentParts.map(function(p2) {
        return p2.value;
      }).join("");
      var delimiterMatches = getAllDelimiterIndexes(full, delimiters);
      var offset = 0;
      var ranges = innerContentParts.map(function(part) {
        offset += part.value.length;
        return {
          offset: offset - part.value.length,
          lIndex: part.lIndex
        };
      });
      var errors2 = getDelimiterErrors(delimiterMatches, full);
      var cutNext = 0;
      var delimiterIndex = 0;
      var parsed = ranges.map(function(p2, i2) {
        var offset2 = p2.offset;
        var range = [offset2, offset2 + innerContentParts[i2].value.length];
        var partContent = innerContentParts[i2].value;
        var delimitersInOffset = [];
        while (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {
          delimitersInOffset.push(delimiterMatches[delimiterIndex]);
          delimiterIndex++;
        }
        var parts = [];
        var cursor2 = 0;
        if (cutNext > 0) {
          cursor2 = cutNext;
          cutNext = 0;
        }
        delimitersInOffset.forEach(function(delimiterInOffset) {
          var value2 = partContent.substr(cursor2, delimiterInOffset.offset - offset2 - cursor2);
          if (delimiterInOffset.changedelimiter) {
            if (delimiterInOffset.position === "start") {
              if (value2.length > 0) {
                parts.push({
                  type: "content",
                  value: value2
                });
              }
            } else {
              cursor2 = delimiterInOffset.offset - offset2 + delimiterInOffset.length;
            }
            return;
          }
          if (value2.length > 0) {
            parts.push({
              type: "content",
              value: value2
            });
            cursor2 += value2.length;
          }
          var delimiterPart = {
            type: "delimiter",
            position: delimiterInOffset.position,
            offset: cursor2 + offset2
          };
          parts.push(delimiterPart);
          cursor2 = delimiterInOffset.offset - offset2 + delimiterInOffset.length;
        });
        cutNext = cursor2 - partContent.length;
        var value = partContent.substr(cursor2);
        if (value.length > 0) {
          parts.push({
            type: "content",
            value
          });
        }
        return parts;
      }, this);
      return {
        parsed,
        errors: errors2
      };
    }
    function isInsideContent(part) {
      return part.type === "content" && part.position === "insidetag";
    }
    function getContentParts(xmlparsed) {
      return xmlparsed.filter(isInsideContent);
    }
    function decodeContentParts(xmlparsed) {
      var inTextTag = false;
      xmlparsed.forEach(function(part) {
        inTextTag = updateInTextTag(part, inTextTag);
        if (part.type === "content") {
          part.position = inTextTag ? "insidetag" : "outsidetag";
        }
        if (isInsideContent(part)) {
          part.value = part.value.replace(/>/g, "&gt;");
        }
      });
    }
    var lexer = {
      parseDelimiters,
      parse: function parse2(xmlparsed, delimiters) {
        decodeContentParts(xmlparsed);
        var _parseDelimiters = parseDelimiters(getContentParts(xmlparsed), delimiters), delimiterParsed = _parseDelimiters.parsed, errors2 = _parseDelimiters.errors;
        var lexed = [];
        var index2 = 0;
        var lIndex = 0;
        xmlparsed.forEach(function(part) {
          if (isInsideContent(part)) {
            Array.prototype.push.apply(lexed, delimiterParsed[index2].map(function(p2) {
              if (p2.type === "content") {
                p2.position = "insidetag";
              }
              p2.lIndex = lIndex++;
              return p2;
            }));
            index2++;
          } else {
            part.lIndex = lIndex++;
            lexed.push(part);
          }
        });
        return {
          errors: errors2,
          lexed
        };
      },
      xmlparse: function xmlparse(content, xmltags) {
        var matches = tagMatcher(content, xmltags.text, xmltags.other);
        var cursor2 = 0;
        var parsed = matches.reduce(function(parsed2, match2) {
          var value2 = content.substr(cursor2, match2.offset - cursor2);
          if (value2.length > 0) {
            parsed2.push({
              type: "content",
              value: value2
            });
          }
          cursor2 = match2.offset + match2.value.length;
          delete match2.offset;
          parsed2.push(match2);
          return parsed2;
        }, []);
        var value = content.substr(cursor2);
        if (value.length > 0) {
          parsed.push({
            type: "content",
            value
          });
        }
        return parsed;
      }
    };
    var xmlMatcher;
    var hasRequiredXmlMatcher;
    function requireXmlMatcher() {
      if (hasRequiredXmlMatcher)
        return xmlMatcher;
      hasRequiredXmlMatcher = 1;
      var _require4 = docUtils, pregMatchAll2 = _require4.pregMatchAll;
      xmlMatcher = function xmlMatcher2(content, tagsXmlArray) {
        var res = {
          content
        };
        var taj = tagsXmlArray.join("|");
        var regexp = new RegExp("(?:(<(?:".concat(taj, ")[^>]*>)([^<>]*)</(?:").concat(taj, ")>)|(<(?:").concat(taj, ")[^>]*/>)"), "g");
        res.matches = pregMatchAll2(regexp, res.content);
        return res;
      };
      return xmlMatcher;
    }
    var prefixMatcher;
    var hasRequiredPrefixMatcher;
    function requirePrefixMatcher() {
      if (hasRequiredPrefixMatcher)
        return prefixMatcher;
      hasRequiredPrefixMatcher = 1;
      var nbspRegex = new RegExp(String.fromCharCode(160), "g");
      function replaceNbsps(str) {
        return str.replace(nbspRegex, " ");
      }
      function match2(condition, placeHolderContent) {
        if (typeof condition === "string") {
          return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;
        }
        if (condition instanceof RegExp) {
          return condition.test(replaceNbsps(placeHolderContent));
        }
      }
      function getValue2(condition, placeHolderContent) {
        if (typeof condition === "string") {
          return replaceNbsps(placeHolderContent).substr(condition.length);
        }
        if (condition instanceof RegExp) {
          return replaceNbsps(placeHolderContent).match(condition)[1];
        }
      }
      function getValues(condition, placeHolderContent) {
        if (typeof condition === "string") {
          return [placeHolderContent, replaceNbsps(placeHolderContent).substr(condition.length)];
        }
        if (condition instanceof RegExp) {
          return replaceNbsps(placeHolderContent).match(condition);
        }
      }
      prefixMatcher = {
        match: match2,
        getValue: getValue2,
        getValues
      };
      return prefixMatcher;
    }
    var parser_1;
    var hasRequiredParser;
    function requireParser() {
      if (hasRequiredParser)
        return parser_1;
      hasRequiredParser = 1;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function ownKeys2(object2, enumerableOnly) {
        var keys = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          })), keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread3(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = null != arguments[i2] ? arguments[i2] : {};
          i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        key = _toPropertyKey2(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _toPropertyKey2(arg) {
        var key = _toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _slicedToArray2(arr, i2) {
        return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
      }
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit2(arr, i2) {
        var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
        if (null != _i) {
          var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
          try {
            if (_x = (_i = _i.call(arr)).next, 0 === i2) {
              if (Object(_i) !== _i)
                return;
              _n = false;
            } else
              for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
                ;
          } catch (err) {
            _d = true, _e = err;
          } finally {
            try {
              if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
                return;
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
      }
      function _arrayWithHoles2(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray2(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray2(o2, minLen);
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      var _require4 = docUtils, wordToUtf82 = _require4.wordToUtf8;
      var _require22 = requirePrefixMatcher(), match2 = _require22.match, getValue2 = _require22.getValue, getValues = _require22.getValues;
      function getMatchers(modules, options) {
        var matchers = [];
        for (var i2 = 0, l2 = modules.length; i2 < l2; i2++) {
          var _module = modules[i2];
          if (_module.matchers) {
            var mmm = _module.matchers(options);
            if (!(mmm instanceof Array)) {
              throw new Error("module matcher returns a non array");
            }
            matchers.push.apply(matchers, _toConsumableArray2(mmm));
          }
        }
        return matchers;
      }
      function getMatches(matchers, placeHolderContent, options) {
        var matches = [];
        for (var i2 = 0, len = matchers.length; i2 < len; i2++) {
          var matcher = matchers[i2];
          var _matcher = _slicedToArray2(matcher, 2), prefix2 = _matcher[0], _module2 = _matcher[1];
          var properties2 = matcher[2] || {};
          if (options.match(prefix2, placeHolderContent)) {
            var values2 = options.getValues(prefix2, placeHolderContent);
            if (typeof properties2 === "function") {
              properties2 = properties2(values2);
            }
            if (!properties2.value) {
              var _values = _slicedToArray2(values2, 2);
              properties2.value = _values[1];
            }
            matches.push(_objectSpread3({
              type: "placeholder",
              prefix: prefix2,
              module: _module2,
              onMatch: properties2.onMatch,
              priority: properties2.priority
            }, properties2));
          }
        }
        return matches;
      }
      function moduleParse(placeHolderContent, options) {
        var modules = options.modules;
        var startOffset = options.startOffset;
        var endLindex = options.lIndex;
        var moduleParsed;
        options.offset = startOffset;
        options.match = match2;
        options.getValue = getValue2;
        options.getValues = getValues;
        var matchers = getMatchers(modules, options);
        var matches = getMatches(matchers, placeHolderContent, options);
        if (matches.length > 0) {
          var bestMatch = null;
          matches.forEach(function(match3) {
            match3.priority = match3.priority || -match3.value.length;
            if (!bestMatch || match3.priority > bestMatch.priority) {
              bestMatch = match3;
            }
          });
          bestMatch.offset = startOffset;
          delete bestMatch.priority;
          bestMatch.endLindex = endLindex;
          bestMatch.lIndex = endLindex;
          bestMatch.raw = placeHolderContent;
          if (bestMatch.onMatch) {
            bestMatch.onMatch(bestMatch);
          }
          delete bestMatch.onMatch;
          delete bestMatch.prefix;
          return bestMatch;
        }
        for (var i2 = 0, l2 = modules.length; i2 < l2; i2++) {
          var _module3 = modules[i2];
          moduleParsed = _module3.parse(placeHolderContent, options);
          if (moduleParsed) {
            moduleParsed.offset = startOffset;
            moduleParsed.endLindex = endLindex;
            moduleParsed.lIndex = endLindex;
            moduleParsed.raw = placeHolderContent;
            return moduleParsed;
          }
        }
        return {
          type: "placeholder",
          value: placeHolderContent,
          offset: startOffset,
          endLindex,
          lIndex: endLindex
        };
      }
      var parser2 = {
        preparse: function preparse(parsed, modules, options) {
          function preparse2(parsed2, options2) {
            return modules.forEach(function(module2) {
              module2.preparse(parsed2, options2);
            });
          }
          return {
            preparsed: preparse2(parsed, options)
          };
        },
        parse: function parse2(lexed, modules, options) {
          var inPlaceHolder = false;
          var placeHolderContent = "";
          var startOffset;
          var tailParts = [];
          var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];
          return lexed.reduce(function lexedToParsed(parsed, token2) {
            if (token2.type === "delimiter") {
              inPlaceHolder = token2.position === "start";
              if (token2.position === "end") {
                options.parse = function(placeHolderContent2) {
                  return moduleParse(placeHolderContent2, _objectSpread3(_objectSpread3(_objectSpread3({}, options), token2), {}, {
                    startOffset,
                    modules
                  }));
                };
                parsed.push(options.parse(wordToUtf82(placeHolderContent)));
                Array.prototype.push.apply(parsed, tailParts);
                tailParts = [];
              }
              if (token2.position === "start") {
                tailParts = [];
                startOffset = token2.offset;
              }
              placeHolderContent = "";
              return parsed;
            }
            if (!inPlaceHolder) {
              parsed.push(token2);
              return parsed;
            }
            if (token2.type !== "content" || token2.position !== "insidetag") {
              if (droppedTags.indexOf(token2.tag) !== -1) {
                return parsed;
              }
              tailParts.push(token2);
              return parsed;
            }
            placeHolderContent += token2.value;
            return parsed;
          }, []);
        },
        postparse: function postparse(postparsed, modules, options) {
          function getTraits(traitName, postparsed2) {
            return modules.map(function(module2) {
              return module2.getTraits(traitName, postparsed2);
            });
          }
          var errors2 = [];
          function _postparse(postparsed2, options2) {
            return modules.reduce(function(postparsed3, module2) {
              var r2 = module2.postparse(postparsed3, _objectSpread3(_objectSpread3({}, options2), {}, {
                postparse: function postparse2(parsed, opts) {
                  return _postparse(parsed, _objectSpread3(_objectSpread3({}, options2), opts));
                },
                getTraits
              }));
              if (r2 == null) {
                return postparsed3;
              }
              if (r2.errors) {
                Array.prototype.push.apply(errors2, r2.errors);
                return r2.postparsed;
              }
              return r2;
            }, postparsed2);
          }
          return {
            postparsed: _postparse(postparsed, options),
            errors: errors2
          };
        }
      };
      parser_1 = parser2;
      return parser_1;
    }
    var render_1;
    var hasRequiredRender$1;
    function requireRender$1() {
      if (hasRequiredRender$1)
        return render_1;
      hasRequiredRender$1 = 1;
      var _require4 = errors, throwUnimplementedTagType2 = _require4.throwUnimplementedTagType;
      function moduleRender(part, options) {
        var moduleRendered;
        for (var i2 = 0, l2 = options.modules.length; i2 < l2; i2++) {
          var _module = options.modules[i2];
          moduleRendered = _module.render(part, options);
          if (moduleRendered) {
            return moduleRendered;
          }
        }
        return false;
      }
      function render2(options) {
        var baseNullGetter = options.baseNullGetter;
        var compiled = options.compiled, scopeManager2 = options.scopeManager;
        options.nullGetter = function(part, sm) {
          return baseNullGetter(part, sm || scopeManager2);
        };
        var errors2 = [];
        var parts = compiled.map(function(part, i2) {
          options.index = i2;
          var moduleRendered = moduleRender(part, options);
          if (moduleRendered) {
            if (moduleRendered.errors) {
              Array.prototype.push.apply(errors2, moduleRendered.errors);
            }
            return moduleRendered;
          }
          if (part.type === "content" || part.type === "tag") {
            return part;
          }
          throwUnimplementedTagType2(part, i2);
        }).reduce(function(parts2, _ref) {
          var value = _ref.value;
          if (value instanceof Array) {
            for (var i2 = 0, len = value.length; i2 < len; i2++) {
              parts2.push(value[i2]);
            }
          } else if (value) {
            parts2.push(value);
          }
          return parts2;
        }, []);
        return {
          errors: errors2,
          parts
        };
      }
      render_1 = render2;
      return render_1;
    }
    var postrender_1;
    var hasRequiredPostrender;
    function requirePostrender() {
      if (hasRequiredPostrender)
        return postrender_1;
      hasRequiredPostrender = 1;
      function string2buf2(str) {
        var c2, c22, mPos, i2, bufLen = 0;
        var strLen = str.length;
        for (mPos = 0; mPos < strLen; mPos++) {
          c2 = str.charCodeAt(mPos);
          if ((c2 & 64512) === 55296 && mPos + 1 < strLen) {
            c22 = str.charCodeAt(mPos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              mPos++;
            }
          }
          bufLen += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
        }
        var buf = new Uint8Array(bufLen);
        for (i2 = 0, mPos = 0; i2 < bufLen; mPos++) {
          c2 = str.charCodeAt(mPos);
          if ((c2 & 64512) === 55296 && mPos + 1 < strLen) {
            c22 = str.charCodeAt(mPos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              mPos++;
            }
          }
          if (c2 < 128) {
            buf[i2++] = c2;
          } else if (c2 < 2048) {
            buf[i2++] = 192 | c2 >>> 6;
            buf[i2++] = 128 | c2 & 63;
          } else if (c2 < 65536) {
            buf[i2++] = 224 | c2 >>> 12;
            buf[i2++] = 128 | c2 >>> 6 & 63;
            buf[i2++] = 128 | c2 & 63;
          } else {
            buf[i2++] = 240 | c2 >>> 18;
            buf[i2++] = 128 | c2 >>> 12 & 63;
            buf[i2++] = 128 | c2 >>> 6 & 63;
            buf[i2++] = 128 | c2 & 63;
          }
        }
        return buf;
      }
      function postrender(parts, options) {
        for (var i2 = 0, l2 = options.modules.length; i2 < l2; i2++) {
          var _module = options.modules[i2];
          parts = _module.postrender(parts, options);
        }
        var fullLength = 0;
        var newParts = options.joinUncorrupt(parts, options);
        var longStr = "";
        var lenStr = 0;
        var maxCompact = 65536;
        var uintArrays = [];
        for (var _i = 0, len = newParts.length; _i < len; _i++) {
          var part = newParts[_i];
          if (part.length + lenStr > maxCompact) {
            var _arr = string2buf2(longStr);
            fullLength += _arr.length;
            uintArrays.push(_arr);
            longStr = "";
          }
          longStr += part;
          lenStr += part.length;
          delete newParts[_i];
        }
        var arr = string2buf2(longStr);
        fullLength += arr.length;
        uintArrays.push(arr);
        var array = new Uint8Array(fullLength);
        var j2 = 0;
        uintArrays.forEach(function(buf) {
          for (var _i2 = 0; _i2 < buf.length; ++_i2) {
            array[_i2 + j2] = buf[_i2];
          }
          j2 += buf.length;
        });
        return array;
      }
      postrender_1 = postrender;
      return postrender_1;
    }
    var resolve_1;
    var hasRequiredResolve;
    function requireResolve() {
      if (hasRequiredResolve)
        return resolve_1;
      hasRequiredResolve = 1;
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray2(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray2(o2, minLen);
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function moduleResolve(part, options) {
        var moduleResolved;
        for (var i2 = 0, l2 = options.modules.length; i2 < l2; i2++) {
          var _module = options.modules[i2];
          moduleResolved = _module.resolve(part, options);
          if (moduleResolved) {
            return moduleResolved;
          }
        }
        return false;
      }
      function resolve(options) {
        var resolved = [];
        var baseNullGetter = options.baseNullGetter;
        var compiled = options.compiled, scopeManager2 = options.scopeManager;
        options.nullGetter = function(part, sm) {
          return baseNullGetter(part, sm || scopeManager2);
        };
        options.resolved = resolved;
        var errors2 = [];
        return Promise.all(compiled.filter(function(part) {
          return ["content", "tag"].indexOf(part.type) === -1;
        }).reduce(function(promises, part) {
          var moduleResolved = moduleResolve(part, options);
          var result;
          if (moduleResolved) {
            result = moduleResolved.then(function(value) {
              resolved.push({
                tag: part.value,
                lIndex: part.lIndex,
                value
              });
            });
          } else if (part.type === "placeholder") {
            result = scopeManager2.getValueAsync(part.value, {
              part
            }).then(function(value) {
              return value == null ? options.nullGetter(part) : value;
            }).then(function(value) {
              resolved.push({
                tag: part.value,
                lIndex: part.lIndex,
                value
              });
              return value;
            });
          } else {
            return;
          }
          promises.push(result["catch"](function(e2) {
            if (e2 instanceof Array) {
              errors2.push.apply(errors2, _toConsumableArray2(e2));
            } else {
              errors2.push(e2);
            }
          }));
          return promises;
        }, [])).then(function() {
          return {
            errors: errors2,
            resolved
          };
        });
      }
      resolve_1 = resolve;
      return resolve_1;
    }
    var joinUncorrupt_1;
    var hasRequiredJoinUncorrupt;
    function requireJoinUncorrupt() {
      if (hasRequiredJoinUncorrupt)
        return joinUncorrupt_1;
      hasRequiredJoinUncorrupt = 1;
      var _require4 = docUtils, startsWith2 = _require4.startsWith, endsWith2 = _require4.endsWith, isStarting2 = _require4.isStarting, isEnding2 = _require4.isEnding, isWhiteSpace2 = _require4.isWhiteSpace;
      var filetypes2 = filetypes_1;
      function addEmptyParagraphAfterTable(parts) {
        var lastNonEmpty = "";
        for (var i2 = 0, len = parts.length; i2 < len; i2++) {
          var p2 = parts[i2];
          if (isWhiteSpace2(p2)) {
            continue;
          }
          if (endsWith2(lastNonEmpty, "</w:tbl>")) {
            if (!startsWith2(p2, "<w:p") && !startsWith2(p2, "<w:tbl") && !startsWith2(p2, "<w:sectPr")) {
              p2 = "<w:p/>".concat(p2);
            }
          }
          lastNonEmpty = p2;
          parts[i2] = p2;
        }
        return parts;
      }
      function joinUncorrupt(parts, options) {
        var contains = options.fileTypeConfig.tagShouldContain || [];
        var collecting = "";
        var currentlyCollecting = -1;
        if (filetypes2.docx.indexOf(options.contentType) !== -1) {
          parts = addEmptyParagraphAfterTable(parts);
        }
        var startIndex = -1;
        for (var i2 = 0, len = parts.length; i2 < len; i2++) {
          var part = parts[i2];
          for (var j2 = 0, len2 = contains.length; j2 < len2; j2++) {
            var _contains$j = contains[j2], tag = _contains$j.tag, shouldContain = _contains$j.shouldContain, value = _contains$j.value, drop = _contains$j.drop;
            if (currentlyCollecting === j2) {
              if (isEnding2(part, tag)) {
                currentlyCollecting = -1;
                if (drop) {
                  for (var k2 = startIndex; k2 <= i2; k2++) {
                    parts[k2] = "";
                  }
                } else {
                  for (var _k = startIndex; _k < i2; _k++) {
                    parts[_k] = "";
                  }
                  parts[i2] = collecting + value + part;
                }
                break;
              }
              collecting += part;
              for (var _k2 = 0, len3 = shouldContain.length; _k2 < len3; _k2++) {
                var sc2 = shouldContain[_k2];
                if (isStarting2(part, sc2)) {
                  currentlyCollecting = -1;
                  break;
                }
              }
              break;
            }
            if (currentlyCollecting === -1 && isStarting2(part, tag) && // to verify that the part doesn't have multiple tags, such as <w:tc><w:p>
            part.substr(1).indexOf("<") === -1) {
              if (part[part.length - 2] === "/") {
                parts[i2] = "";
                break;
              } else {
                startIndex = i2;
                currentlyCollecting = j2;
                collecting = part;
                break;
              }
            }
          }
        }
        return parts;
      }
      joinUncorrupt_1 = joinUncorrupt;
      return joinUncorrupt_1;
    }
    var xmlTemplater;
    var hasRequiredXmlTemplater;
    function requireXmlTemplater() {
      if (hasRequiredXmlTemplater)
        return xmlTemplater;
      hasRequiredXmlTemplater = 1;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey2(arg) {
        var key = _toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var _require4 = docUtils, wordToUtf82 = _require4.wordToUtf8, convertSpaces2 = _require4.convertSpaces;
      var xmlMatcher2 = requireXmlMatcher();
      var Lexer2 = lexer;
      var Parser = requireParser();
      var _render = requireRender$1();
      var postrender = requirePostrender();
      var resolve = requireResolve();
      var joinUncorrupt = requireJoinUncorrupt();
      function _getFullText(content, tagsXmlArray) {
        var matcher = xmlMatcher2(content, tagsXmlArray);
        var result = matcher.matches.map(function(match2) {
          return match2.array[2];
        });
        return wordToUtf82(convertSpaces2(result.join("")));
      }
      xmlTemplater = /* @__PURE__ */ function() {
        function XmlTemplater(content, options) {
          var _this = this;
          _classCallCheck2(this, XmlTemplater);
          this.cachedParsers = {};
          this.content = content;
          Object.keys(options).forEach(function(key) {
            _this[key] = options[key];
          });
          this.setModules({
            inspect: {
              filePath: options.filePath
            }
          });
        }
        _createClass2(XmlTemplater, [{
          key: "resolveTags",
          value: function resolveTags(tags2) {
            var _this2 = this;
            this.tags = tags2;
            var options = this.getOptions();
            var filePath = this.filePath;
            options.scopeManager = this.scopeManager;
            options.resolve = resolve;
            return resolve(options).then(function(_ref) {
              var resolved = _ref.resolved, errors2 = _ref.errors;
              errors2.forEach(function(error) {
                error.properties = error.properties || {};
                error.properties.file = filePath;
              });
              if (errors2.length !== 0) {
                throw errors2;
              }
              return Promise.all(resolved).then(function(resolved2) {
                options.scopeManager.root.finishedResolving = true;
                options.scopeManager.resolved = resolved2;
                _this2.setModules({
                  inspect: {
                    resolved: resolved2,
                    filePath
                  }
                });
                return resolved2;
              });
            });
          }
        }, {
          key: "getFullText",
          value: function getFullText() {
            return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);
          }
        }, {
          key: "setModules",
          value: function setModules(obj) {
            this.modules.forEach(function(module2) {
              module2.set(obj);
            });
          }
        }, {
          key: "preparse",
          value: function preparse() {
            this.allErrors = [];
            this.xmllexed = Lexer2.xmlparse(this.content, {
              text: this.fileTypeConfig.tagsXmlTextArray,
              other: this.fileTypeConfig.tagsXmlLexedArray
            });
            this.setModules({
              inspect: {
                xmllexed: this.xmllexed
              }
            });
            var _Lexer$parse = Lexer2.parse(this.xmllexed, this.delimiters), lexed = _Lexer$parse.lexed, lexerErrors = _Lexer$parse.errors;
            this.allErrors = this.allErrors.concat(lexerErrors);
            this.lexed = lexed;
            this.setModules({
              inspect: {
                lexed: this.lexed
              }
            });
            var options = this.getOptions();
            Parser.preparse(this.lexed, this.modules, options);
          }
        }, {
          key: "parse",
          value: function parse2() {
            this.setModules({
              inspect: {
                filePath: this.filePath
              }
            });
            var options = this.getOptions();
            this.parsed = Parser.parse(this.lexed, this.modules, options);
            this.setModules({
              inspect: {
                parsed: this.parsed
              }
            });
            var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options), postparsed = _Parser$postparse.postparsed, postparsedErrors = _Parser$postparse.errors;
            this.postparsed = postparsed;
            this.setModules({
              inspect: {
                postparsed: this.postparsed
              }
            });
            this.allErrors = this.allErrors.concat(postparsedErrors);
            this.errorChecker(this.allErrors);
            return this;
          }
        }, {
          key: "errorChecker",
          value: function errorChecker(errors2) {
            var _this3 = this;
            errors2.forEach(function(error) {
              error.properties = error.properties || {};
              error.properties.file = _this3.filePath;
            });
            this.modules.forEach(function(module2) {
              errors2 = module2.errorsTransformer(errors2);
            });
          }
        }, {
          key: "baseNullGetter",
          value: function baseNullGetter(part, sm) {
            var _this4 = this;
            var value = this.modules.reduce(function(value2, module2) {
              if (value2 != null) {
                return value2;
              }
              return module2.nullGetter(part, sm, _this4);
            }, null);
            if (value != null) {
              return value;
            }
            return this.nullGetter(part, sm);
          }
        }, {
          key: "getOptions",
          value: function getOptions() {
            return {
              compiled: this.postparsed,
              cachedParsers: this.cachedParsers,
              tags: this.tags,
              modules: this.modules,
              parser: this.parser,
              contentType: this.contentType,
              relsType: this.relsType,
              baseNullGetter: this.baseNullGetter.bind(this),
              filePath: this.filePath,
              fileTypeConfig: this.fileTypeConfig,
              fileType: this.fileType,
              linebreaks: this.linebreaks
            };
          }
        }, {
          key: "render",
          value: function render2(to) {
            this.filePath = to;
            var options = this.getOptions();
            options.resolved = this.scopeManager.resolved;
            options.scopeManager = this.scopeManager;
            options.render = _render;
            options.joinUncorrupt = joinUncorrupt;
            var _render2 = _render(options), errors2 = _render2.errors, parts = _render2.parts;
            if (errors2.length > 0) {
              this.allErrors = errors2;
              this.errorChecker(errors2);
              return this;
            }
            this.content = postrender(parts, options);
            this.setModules({
              inspect: {
                content: this.content
              }
            });
            return this;
          }
        }]);
        return XmlTemplater;
      }();
      return xmlTemplater;
    }
    var loop;
    var hasRequiredLoop;
    function requireLoop() {
      if (hasRequiredLoop)
        return loop;
      hasRequiredLoop = 1;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function ownKeys2(object2, enumerableOnly) {
        var keys = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          })), keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread3(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = null != arguments[i2] ? arguments[i2] : {};
          i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        key = _toPropertyKey2(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _slicedToArray2(arr, i2) {
        return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
      }
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray2(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray2(o2, minLen);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function _iterableToArrayLimit2(arr, i2) {
        var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
        if (null != _i) {
          var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
          try {
            if (_x = (_i = _i.call(arr)).next, 0 === i2) {
              if (Object(_i) !== _i)
                return;
              _n = false;
            } else
              for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
                ;
          } catch (err) {
            _d = true, _e = err;
          } finally {
            try {
              if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
                return;
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
      }
      function _arrayWithHoles2(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey2(arg) {
        var key = _toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var _require4 = docUtils, chunkBy2 = _require4.chunkBy, last2 = _require4.last, isParagraphStart2 = _require4.isParagraphStart, isModule2 = _require4.isModule, isParagraphEnd2 = _require4.isParagraphEnd, isContent2 = _require4.isContent, startsWith2 = _require4.startsWith, isTagEnd2 = _require4.isTagEnd, isTagStart2 = _require4.isTagStart, getSingleAttribute2 = _require4.getSingleAttribute, setSingleAttribute2 = _require4.setSingleAttribute;
      var filetypes2 = filetypes_1;
      var wrapper2 = moduleWrapper$1;
      var moduleName = "loop";
      function hasContent(parts) {
        return parts.some(function(part) {
          return isContent2(part);
        });
      }
      function getFirstMeaningFulPart(parsed) {
        for (var i2 = 0, len = parsed.length; i2 < len; i2++) {
          if (parsed[i2].type !== "content") {
            return parsed[i2];
          }
        }
        return null;
      }
      function isInsideParagraphLoop(part) {
        var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);
        return firstMeaningfulPart != null && firstMeaningfulPart.tag !== "w:t";
      }
      function getPageBreakIfApplies(part) {
        return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type="page"/></w:r></w:p>' : "";
      }
      function isEnclosedByParagraphs(parsed) {
        return parsed.length && isParagraphStart2(parsed[0]) && isParagraphEnd2(last2(parsed));
      }
      function getOffset2(chunk) {
        return hasContent(chunk) ? 0 : chunk.length;
      }
      function addPageBreakAtEnd(subRendered) {
        var j2 = subRendered.parts.length - 1;
        if (subRendered.parts[j2] === "</w:p>") {
          subRendered.parts.splice(j2, 0, '<w:r><w:br w:type="page"/></w:r>');
        } else {
          subRendered.parts.push('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
        }
      }
      function addPageBreakAtBeginning(subRendered) {
        subRendered.parts.unshift('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
      }
      function isContinuous(parts) {
        return parts.some(function(part) {
          return isTagStart2("w:type", part) && part.value.indexOf("continuous") !== -1;
        });
      }
      function isNextPage(parts) {
        return parts.some(function(part) {
          return isTagStart2("w:type", part) && part.value.indexOf('w:val="nextPage"') !== -1;
        });
      }
      function addSectionBefore(parts, sect) {
        return ["<w:p><w:pPr>".concat(sect.map(function(_ref) {
          var value = _ref.value;
          return value;
        }).join(""), "</w:pPr></w:p>")].concat(parts);
      }
      function addContinuousType(parts) {
        var stop = false;
        var inSectPr = false;
        return parts.reduce(function(result, part) {
          if (stop === false && startsWith2(part, "<w:sectPr")) {
            inSectPr = true;
          }
          if (inSectPr) {
            if (startsWith2(part, "<w:type")) {
              stop = true;
            }
            if (stop === false && startsWith2(part, "</w:sectPr")) {
              result.push('<w:type w:val="continuous"/>');
            }
          }
          result.push(part);
          return result;
        }, []);
      }
      function dropHeaderFooterRefs(parts) {
        return parts.filter(function(text) {
          return !startsWith2(text, "<w:headerReference") && !startsWith2(text, "<w:footerReference");
        });
      }
      function hasPageBreak(chunk) {
        return chunk.some(function(part) {
          return part.tag === "w:br" && part.value.indexOf('w:type="page"') !== -1;
        });
      }
      function hasImage(chunk) {
        return chunk.some(function(_ref2) {
          var tag = _ref2.tag;
          return tag === "w:drawing";
        });
      }
      function getSectPr(chunks) {
        var collectSectPr = false;
        var sectPrs = [];
        chunks.forEach(function(part) {
          if (isTagStart2("w:sectPr", part)) {
            sectPrs.push([]);
            collectSectPr = true;
          }
          if (collectSectPr) {
            sectPrs[sectPrs.length - 1].push(part);
          }
          if (isTagEnd2("w:sectPr", part)) {
            collectSectPr = false;
          }
        });
        return sectPrs;
      }
      function getSectPrHeaderFooterChangeCount(chunks) {
        var collectSectPr = false;
        var sectPrCount = 0;
        chunks.forEach(function(part) {
          if (isTagStart2("w:sectPr", part)) {
            collectSectPr = true;
          }
          if (collectSectPr) {
            if (part.tag === "w:headerReference" || part.tag === "w:footerReference") {
              sectPrCount++;
              collectSectPr = false;
            }
          }
          if (isTagEnd2("w:sectPr", part)) {
            collectSectPr = false;
          }
        });
        return sectPrCount;
      }
      function getLastSectPr(parsed) {
        var sectPr = [];
        var inSectPr = false;
        for (var i2 = parsed.length - 1; i2 >= 0; i2--) {
          var part = parsed[i2];
          if (isTagEnd2("w:sectPr", part)) {
            inSectPr = true;
          }
          if (isTagStart2("w:sectPr", part)) {
            sectPr.unshift(part.value);
            inSectPr = false;
          }
          if (inSectPr) {
            sectPr.unshift(part.value);
          }
          if (isParagraphStart2(part)) {
            if (sectPr.length > 0) {
              return sectPr.join("");
            }
            break;
          }
        }
        return "";
      }
      var LoopModule = /* @__PURE__ */ function() {
        function LoopModule2() {
          _classCallCheck2(this, LoopModule2);
          this.name = "LoopModule";
          this.inXfrm = false;
          this.totalSectPr = 0;
          this.prefix = {
            start: "#",
            end: "/",
            dash: /^-([^\s]+)\s(.+)/,
            inverted: "^"
          };
        }
        _createClass2(LoopModule2, [{
          key: "optionsTransformer",
          value: function optionsTransformer(opts, docxtemplater2) {
            this.docxtemplater = docxtemplater2;
            return opts;
          }
        }, {
          key: "preparse",
          value: function preparse(parsed, _ref3) {
            var contentType = _ref3.contentType;
            if (filetypes2.main.indexOf(contentType) !== -1) {
              this.sects = getSectPr(parsed);
            }
          }
        }, {
          key: "matchers",
          value: function matchers() {
            var module2 = moduleName;
            return [[this.prefix.start, module2, {
              expandTo: "auto",
              location: "start",
              inverted: false
            }], [this.prefix.inverted, module2, {
              expandTo: "auto",
              location: "start",
              inverted: true
            }], [this.prefix.end, module2, {
              location: "end"
            }], [this.prefix.dash, module2, function(_ref4) {
              var _ref5 = _slicedToArray2(_ref4, 3), expandTo = _ref5[1], value = _ref5[2];
              return {
                location: "start",
                inverted: false,
                expandTo,
                value
              };
            }]];
          }
        }, {
          key: "getTraits",
          value: function getTraits(traitName, parsed) {
            if (traitName !== "expandPair") {
              return;
            }
            return parsed.reduce(function(tags2, part, offset) {
              if (isModule2(part, moduleName) && part.subparsed == null) {
                tags2.push({
                  part,
                  offset
                });
              }
              return tags2;
            }, []);
          }
        }, {
          key: "postparse",
          value: function postparse(parsed, _ref6) {
            var basePart = _ref6.basePart;
            if (basePart && this.docxtemplater.fileType === "docx" && parsed.length > 0) {
              basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);
              this.totalSectPr += basePart.sectPrCount;
              var sects = this.sects;
              sects.some(function(sect, index2) {
                if (basePart.lIndex < sect[0].lIndex) {
                  if (index2 + 1 < sects.length && isContinuous(sects[index2 + 1])) {
                    basePart.addContinuousType = true;
                  }
                  return true;
                }
                if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {
                  if (isNextPage(sects[index2])) {
                    basePart.addNextPage = {
                      index: index2
                    };
                  }
                  return true;
                }
              });
              basePart.lastParagrapSectPr = getLastSectPr(parsed);
            }
            if (!basePart || basePart.expandTo !== "auto" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {
              return parsed;
            }
            basePart.paragraphLoop = true;
            var level = 0;
            var chunks = chunkBy2(parsed, function(p2) {
              if (isParagraphStart2(p2)) {
                level++;
                if (level === 1) {
                  return "start";
                }
              }
              if (isParagraphEnd2(p2)) {
                level--;
                if (level === 0) {
                  return "end";
                }
              }
              return null;
            });
            var firstChunk = chunks[0];
            var lastChunk = last2(chunks);
            var firstOffset = getOffset2(firstChunk);
            var lastOffset = getOffset2(lastChunk);
            basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);
            basePart.hasPageBreak = hasPageBreak(lastChunk);
            if (hasImage(firstChunk)) {
              firstOffset = 0;
            }
            if (hasImage(lastChunk)) {
              lastOffset = 0;
            }
            return parsed.slice(firstOffset, parsed.length - lastOffset);
          }
        }, {
          key: "resolve",
          value: function resolve(part, options) {
            if (!isModule2(part, moduleName)) {
              return null;
            }
            var sm = options.scopeManager;
            var promisedValue = sm.getValueAsync(part.value, {
              part
            });
            var promises = [];
            function loopOver(scope, i2, length2) {
              var scopeManager2 = sm.createSubScopeManager(scope, part.value, i2, part, length2);
              promises.push(options.resolve({
                filePath: options.filePath,
                modules: options.modules,
                baseNullGetter: options.baseNullGetter,
                resolve: options.resolve,
                compiled: part.subparsed,
                tags: {},
                scopeManager: scopeManager2
              }));
            }
            var errorList = [];
            return promisedValue.then(function(values2) {
              return new Promise(function(resolve2) {
                if (values2 instanceof Array) {
                  Promise.all(values2).then(resolve2);
                } else {
                  resolve2(values2);
                }
              }).then(function(values3) {
                sm.loopOverValue(values3, loopOver, part.inverted);
                return Promise.all(promises).then(function(r2) {
                  return r2.map(function(_ref7) {
                    var resolved = _ref7.resolved, errors2 = _ref7.errors;
                    errorList.push.apply(errorList, _toConsumableArray2(errors2));
                    return resolved;
                  });
                }).then(function(value) {
                  if (errorList.length > 0) {
                    throw errorList;
                  }
                  return value;
                });
              });
            });
          }
          // eslint-disable-next-line complexity
        }, {
          key: "render",
          value: function render2(part, options) {
            if (part.tag === "p:xfrm") {
              this.inXfrm = part.position === "start";
            }
            if (part.tag === "a:ext" && this.inXfrm) {
              this.lastExt = part;
              return part;
            }
            if (!isModule2(part, moduleName)) {
              return null;
            }
            var totalValue = [];
            var errors2 = [];
            var heightOffset = 0;
            var self2 = this;
            var firstTag = part.subparsed[0];
            var tagHeight = 0;
            if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === "a:tr") {
              tagHeight = +getSingleAttribute2(firstTag.value, "h");
            }
            heightOffset -= tagHeight;
            var a16RowIdOffset = 0;
            var insideParagraphLoop = isInsideParagraphLoop(part);
            function loopOver(scope, i2, length2) {
              heightOffset += tagHeight;
              var scopeManager2 = options.scopeManager.createSubScopeManager(scope, part.value, i2, part, length2);
              part.subparsed.forEach(function(pp) {
                if (isTagStart2("a16:rowId", pp)) {
                  var val = +getSingleAttribute2(pp.value, "val") + a16RowIdOffset;
                  a16RowIdOffset = 1;
                  pp.value = setSingleAttribute2(pp.value, "val", val);
                }
              });
              var subRendered = options.render(_objectSpread3(_objectSpread3({}, options), {}, {
                compiled: part.subparsed,
                tags: {},
                scopeManager: scopeManager2
              }));
              if (part.hasPageBreak && i2 === length2 - 1 && insideParagraphLoop) {
                addPageBreakAtEnd(subRendered);
              }
              var isNotFirst = scopeManager2.scopePathItem.some(function(i3) {
                return i3 !== 0;
              });
              if (isNotFirst) {
                if (part.sectPrCount === 1) {
                  subRendered.parts = dropHeaderFooterRefs(subRendered.parts);
                }
                if (part.addContinuousType) {
                  subRendered.parts = addContinuousType(subRendered.parts);
                }
              } else if (part.addNextPage) {
                subRendered.parts = addSectionBefore(subRendered.parts, self2.sects[part.addNextPage.index]);
              }
              if (part.addNextPage) {
                addPageBreakAtEnd(subRendered);
              }
              if (part.hasPageBreakBeginning && insideParagraphLoop) {
                addPageBreakAtBeginning(subRendered);
              }
              for (var _i2 = 0, len = subRendered.parts.length; _i2 < len; _i2++) {
                totalValue.push(subRendered.parts[_i2]);
              }
              Array.prototype.push.apply(errors2, subRendered.errors);
            }
            var result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {
              part
            });
            if (result === false) {
              if (part.lastParagrapSectPr) {
                if (part.paragraphLoop) {
                  return {
                    value: "<w:p><w:pPr>".concat(part.lastParagrapSectPr, "</w:pPr></w:p>")
                  };
                }
                return {
                  value: "</w:t></w:r></w:p><w:p><w:pPr>".concat(part.lastParagrapSectPr, "</w:pPr><w:r><w:t>")
                };
              }
              return {
                value: getPageBreakIfApplies(part) || "",
                errors: errors2
              };
            }
            if (heightOffset !== 0) {
              var cy = +getSingleAttribute2(this.lastExt.value, "cy");
              this.lastExt.value = setSingleAttribute2(this.lastExt.value, "cy", cy + heightOffset);
            }
            return {
              value: options.joinUncorrupt(totalValue, _objectSpread3(_objectSpread3({}, options), {}, {
                basePart: part
              })),
              errors: errors2
            };
          }
        }]);
        return LoopModule2;
      }();
      loop = function() {
        return wrapper2(new LoopModule());
      };
      return loop;
    }
    var spacePreserve;
    var hasRequiredSpacePreserve;
    function requireSpacePreserve() {
      if (hasRequiredSpacePreserve)
        return spacePreserve;
      hasRequiredSpacePreserve = 1;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey2(arg) {
        var key = _toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var wrapper2 = moduleWrapper$1;
      var _require4 = docUtils, isTextStart2 = _require4.isTextStart, isTextEnd2 = _require4.isTextEnd, endsWith2 = _require4.endsWith, startsWith2 = _require4.startsWith;
      var wTpreserve = '<w:t xml:space="preserve">';
      var wTpreservelen = wTpreserve.length;
      var wtEnd = "</w:t>";
      var wtEndlen = wtEnd.length;
      function isWtStart(part) {
        return isTextStart2(part) && part.tag === "w:t";
      }
      function addXMLPreserve(chunk, index2) {
        var tag = chunk[index2].value;
        if (chunk[index2 + 1].value === "</w:t>") {
          return tag;
        }
        if (tag.indexOf('xml:space="preserve"') !== -1) {
          return tag;
        }
        return tag.substr(0, tag.length - 1) + ' xml:space="preserve">';
      }
      function isInsideLoop(meta, chunk) {
        return meta && meta.basePart && chunk.length > 1;
      }
      var SpacePreserve = /* @__PURE__ */ function() {
        function SpacePreserve2() {
          _classCallCheck2(this, SpacePreserve2);
          this.name = "SpacePreserveModule";
        }
        _createClass2(SpacePreserve2, [{
          key: "clone",
          value: function clone() {
            return new SpacePreserve2();
          }
        }, {
          key: "postparse",
          value: function postparse(postparsed, meta) {
            var chunk = [], inTextTag = false, endLindex = 0, lastTextTag = 0;
            function isStartingPlaceHolder(part, chunk2) {
              return part.type === "placeholder" && chunk2.length > 1;
            }
            var result = postparsed.reduce(function(postparsed2, part) {
              if (isWtStart(part)) {
                inTextTag = true;
                lastTextTag = chunk.length;
              }
              if (!inTextTag) {
                postparsed2.push(part);
                return postparsed2;
              }
              chunk.push(part);
              if (isInsideLoop(meta, chunk)) {
                endLindex = meta.basePart.endLindex;
                chunk[0].value = addXMLPreserve(chunk, 0);
              }
              if (isStartingPlaceHolder(part, chunk)) {
                chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);
                endLindex = part.endLindex;
              }
              if (isTextEnd2(part) && part.lIndex > endLindex) {
                if (endLindex !== 0) {
                  chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);
                }
                Array.prototype.push.apply(postparsed2, chunk);
                chunk = [];
                inTextTag = false;
                endLindex = 0;
                lastTextTag = 0;
              }
              return postparsed2;
            }, []);
            Array.prototype.push.apply(result, chunk);
            return result;
          }
        }, {
          key: "postrender",
          value: function postrender(parts) {
            var lastNonEmpty = "";
            var lastNonEmptyIndex = 0;
            for (var i2 = 0, len = parts.length; i2 < len; i2++) {
              var index2 = i2;
              var p2 = parts[i2];
              if (p2 === "") {
                continue;
              }
              if (endsWith2(lastNonEmpty, wTpreserve) && startsWith2(p2, wtEnd)) {
                parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + "<w:t/>";
                p2 = p2.substr(wtEndlen);
              }
              lastNonEmpty = p2;
              lastNonEmptyIndex = index2;
              parts[i2] = p2;
            }
            return parts;
          }
        }]);
        return SpacePreserve2;
      }();
      spacePreserve = function() {
        return wrapper2(new SpacePreserve());
      };
      return spacePreserve;
    }
    var rawxml;
    var hasRequiredRawxml;
    function requireRawxml() {
      if (hasRequiredRawxml)
        return rawxml;
      hasRequiredRawxml = 1;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey2(arg) {
        var key = _toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var traits$1 = traits;
      var _require4 = docUtils, isContent2 = _require4.isContent;
      var _require22 = errors, throwRawTagShouldBeOnlyTextInParagraph2 = _require22.throwRawTagShouldBeOnlyTextInParagraph, getInvalidRawXMLValueException2 = _require22.getInvalidRawXMLValueException;
      var moduleName = "rawxml";
      var wrapper2 = moduleWrapper$1;
      function getInner(_ref) {
        var part = _ref.part, left = _ref.left, right = _ref.right, postparsed = _ref.postparsed, index2 = _ref.index;
        var paragraphParts = postparsed.slice(left + 1, right);
        paragraphParts.forEach(function(p2, i2) {
          if (i2 === index2 - left - 1) {
            return;
          }
          if (isContent2(p2)) {
            throwRawTagShouldBeOnlyTextInParagraph2({
              paragraphParts,
              part
            });
          }
        });
        return part;
      }
      var RawXmlModule = /* @__PURE__ */ function() {
        function RawXmlModule2() {
          _classCallCheck2(this, RawXmlModule2);
          this.name = "RawXmlModule";
          this.prefix = "@";
        }
        _createClass2(RawXmlModule2, [{
          key: "optionsTransformer",
          value: function optionsTransformer(options, docxtemplater2) {
            this.fileTypeConfig = docxtemplater2.fileTypeConfig;
            return options;
          }
        }, {
          key: "matchers",
          value: function matchers() {
            return [[this.prefix, moduleName]];
          }
        }, {
          key: "postparse",
          value: function postparse(postparsed) {
            return traits$1.expandToOne(postparsed, {
              moduleName,
              getInner,
              expandTo: this.fileTypeConfig.tagRawXml,
              error: {
                message: "Raw tag not in paragraph",
                id: "raw_tag_outerxml_invalid",
                explanation: function explanation(part) {
                  return 'The tag "'.concat(part.value, '" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.');
                }
              }
            });
          }
        }, {
          key: "render",
          value: function render2(part, options) {
            if (part.module !== moduleName) {
              return null;
            }
            var value;
            var errors2 = [];
            try {
              value = options.scopeManager.getValue(part.value, {
                part
              });
              if (value == null) {
                value = options.nullGetter(part);
              }
            } catch (e2) {
              errors2.push(e2);
              return {
                errors: errors2
              };
            }
            value = value ? value : "";
            if (typeof value === "string") {
              return {
                value
              };
            }
            return {
              errors: [getInvalidRawXMLValueException2({
                tag: part.value,
                value,
                offset: part.offset
              })]
            };
          }
        }]);
        return RawXmlModule2;
      }();
      rawxml = function() {
        return wrapper2(new RawXmlModule());
      };
      return rawxml;
    }
    var mergeSort;
    var hasRequiredMergeSort;
    function requireMergeSort() {
      if (hasRequiredMergeSort)
        return mergeSort;
      hasRequiredMergeSort = 1;
      function getMinFromArrays(arrays, state) {
        var minIndex = -1;
        for (var i2 = 0, l2 = arrays.length; i2 < l2; i2++) {
          if (state[i2] >= arrays[i2].length) {
            continue;
          }
          if (minIndex === -1 || arrays[i2][state[i2]].offset < arrays[minIndex][state[minIndex]].offset) {
            minIndex = i2;
          }
        }
        return minIndex;
      }
      mergeSort = function(arrays) {
        var totalLength = arrays.reduce(function(sum, array) {
          return sum + array.length;
        }, 0);
        arrays = arrays.filter(function(array) {
          return array.length > 0;
        });
        var resultArray = new Array(totalLength);
        var state = arrays.map(function() {
          return 0;
        });
        for (var i2 = 0; i2 < totalLength; i2++) {
          var arrayIndex = getMinFromArrays(arrays, state);
          resultArray[i2] = arrays[arrayIndex][state[arrayIndex]];
          state[arrayIndex]++;
        }
        return resultArray;
      };
      return mergeSort;
    }
    var expandPairTrait;
    var hasRequiredExpandPairTrait;
    function requireExpandPairTrait() {
      if (hasRequiredExpandPairTrait)
        return expandPairTrait;
      hasRequiredExpandPairTrait = 1;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey2(arg) {
        var key = _toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var traitName = "expandPair";
      var mergeSort2 = requireMergeSort();
      var _require4 = docUtils, getLeft2 = _require4.getLeft, getRight2 = _require4.getRight;
      var wrapper2 = moduleWrapper$1;
      var _require22 = traits, getExpandToDefault2 = _require22.getExpandToDefault;
      var _require32 = errors, getUnmatchedLoopException2 = _require32.getUnmatchedLoopException, getClosingTagNotMatchOpeningTag2 = _require32.getClosingTagNotMatchOpeningTag, getUnbalancedLoopException2 = _require32.getUnbalancedLoopException;
      function getOpenCountChange(part) {
        switch (part.location) {
          case "start":
            return 1;
          case "end":
            return -1;
        }
      }
      function match2(start, end) {
        return start != null && end != null && (start.part.location === "start" && end.part.location === "end" && start.part.value === end.part.value || end.part.value === "");
      }
      function transformer(traits2) {
        var i2 = 0;
        var errors2 = [];
        while (i2 < traits2.length) {
          var part = traits2[i2].part;
          if (part.location === "end") {
            if (i2 === 0) {
              traits2.splice(0, 1);
              errors2.push(getUnmatchedLoopException2(part));
              return {
                traits: traits2,
                errors: errors2
              };
            }
            var endIndex = i2;
            var startIndex = i2 - 1;
            var offseter = 1;
            if (match2(traits2[startIndex], traits2[endIndex])) {
              traits2.splice(endIndex, 1);
              traits2.splice(startIndex, 1);
              return {
                errors: errors2,
                traits: traits2
              };
            }
            while (offseter < 50) {
              var startCandidate = traits2[startIndex - offseter];
              var endCandidate = traits2[endIndex + offseter];
              if (match2(startCandidate, traits2[endIndex])) {
                traits2.splice(endIndex, 1);
                traits2.splice(startIndex - offseter, 1);
                return {
                  errors: errors2,
                  traits: traits2
                };
              }
              if (match2(traits2[startIndex], endCandidate)) {
                traits2.splice(endIndex + offseter, 1);
                traits2.splice(startIndex, 1);
                return {
                  errors: errors2,
                  traits: traits2
                };
              }
              offseter++;
            }
            errors2.push(getClosingTagNotMatchOpeningTag2({
              tags: [traits2[startIndex].part, traits2[endIndex].part]
            }));
            traits2.splice(endIndex, 1);
            traits2.splice(startIndex, 1);
            return {
              traits: traits2,
              errors: errors2
            };
          }
          i2++;
        }
        traits2.forEach(function(_ref) {
          var part2 = _ref.part;
          errors2.push(getUnmatchedLoopException2(part2));
        });
        return {
          traits: [],
          errors: errors2
        };
      }
      function getPairs(traits2) {
        var levelTraits = {};
        var errors2 = [];
        var pairs = [];
        var transformedTraits = [];
        for (var i2 = 0; i2 < traits2.length; i2++) {
          transformedTraits.push(traits2[i2]);
        }
        while (transformedTraits.length > 0) {
          var result = transformer(transformedTraits);
          errors2 = errors2.concat(result.errors);
          transformedTraits = result.traits;
        }
        if (errors2.length > 0) {
          return {
            pairs,
            errors: errors2
          };
        }
        var countOpen = 0;
        for (var _i = 0; _i < traits2.length; _i++) {
          var currentTrait = traits2[_i];
          var part = currentTrait.part;
          var change = getOpenCountChange(part);
          countOpen += change;
          if (change === 1) {
            levelTraits[countOpen] = currentTrait;
          } else {
            var startTrait = levelTraits[countOpen + 1];
            if (countOpen === 0) {
              pairs = pairs.concat([[startTrait, currentTrait]]);
            }
          }
          countOpen = countOpen >= 0 ? countOpen : 0;
        }
        return {
          pairs,
          errors: errors2
        };
      }
      var ExpandPairTrait = /* @__PURE__ */ function() {
        function ExpandPairTrait2() {
          _classCallCheck2(this, ExpandPairTrait2);
          this.name = "ExpandPairTrait";
        }
        _createClass2(ExpandPairTrait2, [{
          key: "clone",
          value: function clone() {
            return new ExpandPairTrait2();
          }
        }, {
          key: "optionsTransformer",
          value: function optionsTransformer(options, docxtemplater2) {
            this.expandTags = docxtemplater2.fileTypeConfig.expandTags.concat(docxtemplater2.options.paragraphLoop ? docxtemplater2.fileTypeConfig.onParagraphLoop : []);
            return options;
          }
        }, {
          key: "postparse",
          value: function postparse(postparsed, _ref2) {
            var _this = this;
            var getTraits = _ref2.getTraits, _postparse = _ref2.postparse;
            var traits2 = getTraits(traitName, postparsed);
            traits2 = traits2.map(function(trait) {
              return trait || [];
            });
            traits2 = mergeSort2(traits2);
            var _getPairs = getPairs(traits2), pairs = _getPairs.pairs, errors2 = _getPairs.errors;
            var lastRight = 0;
            var lastPair = null;
            var expandedPairs = pairs.map(function(pair) {
              var expandTo = pair[0].part.expandTo;
              if (expandTo === "auto") {
                var result = getExpandToDefault2(postparsed, pair, _this.expandTags);
                if (result.error) {
                  errors2.push(result.error);
                }
                expandTo = result.value;
              }
              if (!expandTo) {
                var _left = pair[0].offset;
                var _right = pair[1].offset;
                if (_left < lastRight) {
                  errors2.push(getUnbalancedLoopException2(pair, lastPair));
                }
                lastPair = pair;
                lastRight = _right;
                return [_left, _right];
              }
              var left, right;
              try {
                left = getLeft2(postparsed, expandTo, pair[0].offset);
              } catch (e2) {
                errors2.push(e2);
              }
              try {
                right = getRight2(postparsed, expandTo, pair[1].offset);
              } catch (e2) {
                errors2.push(e2);
              }
              if (left < lastRight) {
                errors2.push(getUnbalancedLoopException2(pair, lastPair));
              }
              lastRight = right;
              lastPair = pair;
              return [left, right];
            });
            if (errors2.length > 0) {
              return {
                postparsed,
                errors: errors2
              };
            }
            var currentPairIndex = 0;
            var innerParts;
            var newParsed = postparsed.reduce(function(newParsed2, part, i2) {
              var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i2 && i2 <= expandedPairs[currentPairIndex][1];
              var pair = pairs[currentPairIndex];
              var expandedPair = expandedPairs[currentPairIndex];
              if (!inPair) {
                newParsed2.push(part);
                return newParsed2;
              }
              if (expandedPair[0] === i2) {
                innerParts = [];
              }
              if (pair[0].offset !== i2 && pair[1].offset !== i2) {
                innerParts.push(part);
              }
              if (expandedPair[1] === i2) {
                var basePart = postparsed[pair[0].offset];
                basePart.subparsed = _postparse(innerParts, {
                  basePart
                });
                basePart.endLindex = pair[1].part.lIndex;
                delete basePart.location;
                delete basePart.expandTo;
                newParsed2.push(basePart);
                currentPairIndex++;
              }
              return newParsed2;
            }, []);
            return {
              postparsed: newParsed,
              errors: errors2
            };
          }
        }]);
        return ExpandPairTrait2;
      }();
      expandPairTrait = function() {
        return wrapper2(new ExpandPairTrait());
      };
      return expandPairTrait;
    }
    var render;
    var hasRequiredRender;
    function requireRender() {
      if (hasRequiredRender)
        return render;
      hasRequiredRender = 1;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey2(arg) {
        var key = _toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var wrapper2 = moduleWrapper$1;
      var _require4 = errors, getScopeCompilationError2 = _require4.getScopeCompilationError;
      var _require22 = docUtils, utf8ToWord2 = _require22.utf8ToWord, hasCorruptCharacters2 = _require22.hasCorruptCharacters;
      var _require32 = errors, getCorruptCharactersException2 = _require32.getCorruptCharactersException;
      var ftprefix = {
        docx: "w",
        pptx: "a"
      };
      var Render = /* @__PURE__ */ function() {
        function Render2() {
          _classCallCheck2(this, Render2);
          this.name = "Render";
          this.recordRun = false;
          this.recordedRun = [];
        }
        _createClass2(Render2, [{
          key: "optionsTransformer",
          value: function optionsTransformer(options, docxtemplater2) {
            this.parser = docxtemplater2.parser;
            this.fileType = docxtemplater2.fileType;
            return options;
          }
        }, {
          key: "set",
          value: function set(obj) {
            if (obj.compiled) {
              this.compiled = obj.compiled;
            }
            if (obj.data != null) {
              this.data = obj.data;
            }
          }
        }, {
          key: "getRenderedMap",
          value: function getRenderedMap(mapper) {
            var _this = this;
            return Object.keys(this.compiled).reduce(function(mapper2, from2) {
              mapper2[from2] = {
                from: from2,
                data: _this.data
              };
              return mapper2;
            }, mapper);
          }
        }, {
          key: "postparse",
          value: function postparse(postparsed, options) {
            var _this2 = this;
            var errors2 = [];
            postparsed.forEach(function(p2) {
              if (p2.type === "placeholder") {
                var tag = p2.value;
                try {
                  options.cachedParsers[p2.lIndex] = _this2.parser(tag, {
                    tag: p2
                  });
                } catch (rootError) {
                  errors2.push(getScopeCompilationError2({
                    tag,
                    rootError,
                    offset: p2.offset
                  }));
                }
              }
            });
            return {
              postparsed,
              errors: errors2
            };
          }
        }, {
          key: "render",
          value: function render2(part, _ref) {
            var scopeManager2 = _ref.scopeManager, linebreaks = _ref.linebreaks, nullGetter = _ref.nullGetter;
            if (linebreaks) {
              this.recordRuns(part);
            }
            if (part.type !== "placeholder" || part.module) {
              return;
            }
            var value;
            try {
              value = scopeManager2.getValue(part.value, {
                part
              });
            } catch (e2) {
              return {
                errors: [e2]
              };
            }
            if (value == null) {
              value = nullGetter(part);
            }
            if (hasCorruptCharacters2(value)) {
              return {
                errors: [getCorruptCharactersException2({
                  tag: part.value,
                  value,
                  offset: part.offset
                })]
              };
            }
            return {
              value: linebreaks && typeof value === "string" ? this.renderLineBreaks(value) : utf8ToWord2(value)
            };
          }
        }, {
          key: "recordRuns",
          value: function recordRuns(part) {
            if (part.tag === "".concat(ftprefix[this.fileType], ":r")) {
              this.recordedRun = [];
            } else if (part.tag === "".concat(ftprefix[this.fileType], ":rPr")) {
              if (part.position === "start") {
                this.recordRun = true;
                this.recordedRun = [part.value];
              }
              if (part.position === "end" || part.position === "selfclosing") {
                this.recordedRun.push(part.value);
                this.recordRun = false;
              }
            } else if (this.recordRun) {
              this.recordedRun.push(part.value);
            }
          }
        }, {
          key: "renderLineBreaks",
          value: function renderLineBreaks(value) {
            var _this3 = this;
            var p2 = ftprefix[this.fileType];
            var br = this.fileType === "docx" ? "<w:r><w:br/></w:r>" : "<a:br/>";
            var lines = value.split("\n");
            var runprops = this.recordedRun.join("");
            return lines.map(function(line2) {
              return utf8ToWord2(line2);
            }).reduce(function(result, line2, i2) {
              result.push(line2);
              if (i2 < lines.length - 1) {
                result.push("</".concat(p2, ":t></").concat(p2, ":r>").concat(br, "<").concat(p2, ":r>").concat(runprops, "<").concat(p2, ":t").concat(_this3.fileType === "docx" ? ' xml:space="preserve"' : "", ">"));
              }
              return result;
            }, []);
          }
        }]);
        return Render2;
      }();
      render = function() {
        return wrapper2(new Render());
      };
      return render;
    }
    var fileTypeConfig;
    var hasRequiredFileTypeConfig;
    function requireFileTypeConfig() {
      if (hasRequiredFileTypeConfig)
        return fileTypeConfig;
      hasRequiredFileTypeConfig = 1;
      var loopModule = requireLoop();
      var spacePreserveModule = requireSpacePreserve();
      var rawXmlModule = requireRawxml();
      var expandPairTrait2 = requireExpandPairTrait();
      var render2 = requireRender();
      function DocXFileTypeConfig() {
        return {
          getTemplatedFiles: function getTemplatedFiles() {
            return [];
          },
          textPath: function textPath(doc) {
            return doc.textTarget;
          },
          tagsXmlTextArray: ["Company", "HyperlinkBase", "Manager", "cp:category", "cp:keywords", "dc:creator", "dc:description", "dc:subject", "dc:title", "cp:contentStatus", "w:t", "m:t", "vt:lpstr", "vt:lpwstr"],
          tagsXmlLexedArray: ["w:proofState", "w:tc", "w:tr", "w:tbl", "w:body", "w:document", "w:p", "w:r", "w:br", "w:rPr", "w:pPr", "w:spacing", "w:sdtContent", "w:drawing", "w:sectPr", "w:type", "w:headerReference", "w:footerReference", "w:bookmarkStart", "w:bookmarkEnd", "w:commentRangeStart", "w:commentRangeEnd", "w:commentReference"],
          droppedTagsInsidePlaceholder: ["w:p", "w:br", "w:bookmarkStart", "w:bookmarkEnd"],
          expandTags: [{
            contains: "w:tc",
            expand: "w:tr"
          }],
          onParagraphLoop: [{
            contains: "w:p",
            expand: "w:p",
            onlyTextInTag: true
          }],
          tagRawXml: "w:p",
          baseModules: [loopModule, spacePreserveModule, expandPairTrait2, rawXmlModule, render2],
          tagShouldContain: [{
            tag: "w:tbl",
            shouldContain: ["w:tr"],
            drop: true
          }, {
            tag: "w:tc",
            shouldContain: ["w:p"],
            value: "<w:p></w:p>"
          }, {
            tag: "w:sdtContent",
            shouldContain: ["w:p", "w:r", "w:commentRangeStart"],
            value: "<w:p></w:p>"
          }]
        };
      }
      function PptXFileTypeConfig() {
        return {
          getTemplatedFiles: function getTemplatedFiles() {
            return [];
          },
          textPath: function textPath(doc) {
            return doc.textTarget;
          },
          tagsXmlTextArray: ["Company", "HyperlinkBase", "Manager", "cp:category", "cp:keywords", "dc:creator", "dc:description", "dc:subject", "dc:title", "a:t", "m:t", "vt:lpstr", "vt:lpwstr"],
          tagsXmlLexedArray: ["p:sp", "a:tc", "a:tr", "a:tbl", "a:p", "a:r", "a:rPr", "p:txBody", "a:txBody", "a:off", "a:ext", "p:graphicFrame", "p:xfrm", "a16:rowId", "a:endParaRPr"],
          droppedTagsInsidePlaceholder: ["a:p", "a:endParaRPr"],
          expandTags: [{
            contains: "a:tc",
            expand: "a:tr"
          }],
          onParagraphLoop: [{
            contains: "a:p",
            expand: "a:p",
            onlyTextInTag: true
          }],
          tagRawXml: "p:sp",
          baseModules: [loopModule, expandPairTrait2, rawXmlModule, render2],
          tagShouldContain: [{
            tag: "a:tbl",
            shouldContain: ["a:tr"],
            drop: true
          }, {
            tag: "p:txBody",
            shouldContain: ["a:p"],
            value: "<a:p></a:p>"
          }, {
            tag: "a:txBody",
            shouldContain: ["a:p"],
            value: "<a:p></a:p>"
          }]
        };
      }
      fileTypeConfig = {
        docx: DocXFileTypeConfig,
        pptx: PptXFileTypeConfig
      };
      return fileTypeConfig;
    }
    var _excluded = ["modules"];
    function _typeof$1(obj) {
      "@babel/helpers - typeof";
      return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$1(obj);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey$1(arg) {
      var key = _toPrimitive$1(arg, "string");
      return _typeof$1(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive$1(input, hint) {
      if (_typeof$1(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$1(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var DocUtils = docUtils;
    DocUtils.traits = traits;
    DocUtils.moduleWrapper = moduleWrapper$1;
    var createScope = scopeManager;
    var _require = errors, throwMultiError = _require.throwMultiError, throwResolveBeforeCompile = _require.throwResolveBeforeCompile, throwRenderInvalidTemplate = _require.throwRenderInvalidTemplate, throwRenderTwice = _require.throwRenderTwice;
    var logErrors = errorLogger;
    var collectContentTypes = collectContentTypes_1;
    var ctXML = "[Content_Types].xml";
    var relsFile = "_rels/.rels";
    var commonModule = common;
    var Lexer = lexer;
    var defaults = DocUtils.defaults, str2xml = DocUtils.str2xml, xml2str = DocUtils.xml2str, moduleWrapper = DocUtils.moduleWrapper, concatArrays = DocUtils.concatArrays, uniq = DocUtils.uniq, stableSort = DocUtils.stableSort;
    var _require2 = errors, XTInternalError = _require2.XTInternalError, throwFileTypeNotIdentified = _require2.throwFileTypeNotIdentified, throwFileTypeNotHandled = _require2.throwFileTypeNotHandled, throwApiVersionError = _require2.throwApiVersionError;
    var currentModuleApiVersion = [3, 36, 0];
    function dropUnsupportedFileTypesModules(dx) {
      dx.modules = dx.modules.filter(function(module2) {
        if (module2.supportedFileTypes) {
          if (!Array.isArray(module2.supportedFileTypes)) {
            throw new Error("The supportedFileTypes field of the module must be an array");
          }
          var isSupportedModule = module2.supportedFileTypes.indexOf(dx.fileType) !== -1;
          if (!isSupportedModule) {
            module2.on("detached");
          }
          return isSupportedModule;
        }
        return true;
      });
    }
    var Docxtemplater = /* @__PURE__ */ function() {
      function Docxtemplater2(zip) {
        var _this = this;
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$modules = _ref.modules, modules = _ref$modules === void 0 ? [] : _ref$modules, options = _objectWithoutProperties(_ref, _excluded);
        _classCallCheck(this, Docxtemplater2);
        if (!Array.isArray(modules)) {
          throw new Error("The modules argument of docxtemplater's constructor must be an array");
        }
        this.targets = [];
        this.rendered = false;
        this.scopeManagers = {};
        this.compiled = {};
        this.modules = [commonModule()];
        this.setOptions(options);
        modules.forEach(function(module2) {
          _this.attachModule(module2);
        });
        if (arguments.length > 0) {
          if (!zip || !zip.files || typeof zip.file !== "function") {
            throw new Error("The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)");
          }
          this.loadZip(zip);
          dropUnsupportedFileTypesModules(this);
          this.compile();
          this.v4Constructor = true;
        }
      }
      _createClass(Docxtemplater2, [{
        key: "verifyApiVersion",
        value: function verifyApiVersion(neededVersion) {
          neededVersion = neededVersion.split(".").map(function(i2) {
            return parseInt(i2, 10);
          });
          if (neededVersion.length !== 3) {
            throwApiVersionError("neededVersion is not a valid version", {
              neededVersion,
              explanation: "the neededVersion must be an array of length 3"
            });
          }
          if (neededVersion[0] !== currentModuleApiVersion[0]) {
            throwApiVersionError("The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater", {
              neededVersion,
              currentModuleApiVersion,
              explanation: "moduleAPIVersionMismatch : needed=".concat(neededVersion.join("."), ", current=").concat(currentModuleApiVersion.join("."))
            });
          }
          if (neededVersion[1] > currentModuleApiVersion[1]) {
            throwApiVersionError("The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater", {
              neededVersion,
              currentModuleApiVersion,
              explanation: "moduleAPIVersionMismatch : needed=".concat(neededVersion.join("."), ", current=").concat(currentModuleApiVersion.join("."))
            });
          }
          if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {
            throwApiVersionError("The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater", {
              neededVersion,
              currentModuleApiVersion,
              explanation: "moduleAPIVersionMismatch : needed=".concat(neededVersion.join("."), ", current=").concat(currentModuleApiVersion.join("."))
            });
          }
          return true;
        }
      }, {
        key: "setModules",
        value: function setModules(obj) {
          this.modules.forEach(function(module2) {
            module2.set(obj);
          });
        }
      }, {
        key: "sendEvent",
        value: function sendEvent(eventName) {
          this.modules.forEach(function(module2) {
            module2.on(eventName);
          });
        }
      }, {
        key: "attachModule",
        value: function attachModule(module2) {
          if (this.v4Constructor) {
            throw new XTInternalError("attachModule() should not be called manually when using the v4 constructor");
          }
          var moduleType = _typeof$1(module2);
          if (moduleType === "function") {
            throw new XTInternalError("Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.");
          }
          if (!module2 || moduleType !== "object") {
            throw new XTInternalError("Cannot attachModule with a falsy value");
          }
          if (module2.requiredAPIVersion) {
            this.verifyApiVersion(module2.requiredAPIVersion);
          }
          if (module2.attached === true) {
            if (typeof module2.clone === "function") {
              module2 = module2.clone();
            } else {
              throw new Error('Cannot attach a module that was already attached : "'.concat(module2.name, '". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater'));
            }
          }
          module2.attached = true;
          var wrappedModule = moduleWrapper(module2);
          this.modules.push(wrappedModule);
          wrappedModule.on("attached");
          if (this.fileType) {
            dropUnsupportedFileTypesModules(this);
          }
          return this;
        }
      }, {
        key: "setOptions",
        value: function setOptions(options) {
          var _this2 = this;
          if (this.v4Constructor) {
            throw new Error("setOptions() should not be called manually when using the v4 constructor");
          }
          if (!options) {
            throw new Error("setOptions should be called with an object as first parameter");
          }
          this.options = {};
          Object.keys(defaults).forEach(function(key) {
            var defaultValue = defaults[key];
            _this2.options[key] = options[key] != null ? options[key] : defaultValue;
            _this2[key] = _this2.options[key];
          });
          this.delimiters.start = DocUtils.utf8ToWord(this.delimiters.start);
          this.delimiters.end = DocUtils.utf8ToWord(this.delimiters.end);
          return this;
        }
      }, {
        key: "loadZip",
        value: function loadZip(zip) {
          if (this.v4Constructor) {
            throw new Error("loadZip() should not be called manually when using the v4 constructor");
          }
          if (zip.loadAsync) {
            throw new XTInternalError("Docxtemplater doesn't handle JSZip version >=3, please use pizzip");
          }
          this.zip = zip;
          this.updateFileTypeConfig();
          this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function(moduleFunction) {
            return moduleFunction();
          }), this.modules]);
          dropUnsupportedFileTypesModules(this);
          return this;
        }
      }, {
        key: "precompileFile",
        value: function precompileFile(fileName) {
          var currentFile = this.createTemplateClass(fileName);
          currentFile.preparse();
          this.compiled[fileName] = currentFile;
        }
      }, {
        key: "compileFile",
        value: function compileFile(fileName) {
          this.compiled[fileName].parse();
        }
      }, {
        key: "getScopeManager",
        value: function getScopeManager(to, currentFile, tags2) {
          if (!this.scopeManagers[to]) {
            this.scopeManagers[to] = createScope({
              tags: tags2,
              parser: this.parser,
              cachedParsers: currentFile.cachedParsers
            });
          }
          return this.scopeManagers[to];
        }
      }, {
        key: "resolveData",
        value: function resolveData(data) {
          var _this3 = this;
          var errors2 = [];
          if (!Object.keys(this.compiled).length) {
            throwResolveBeforeCompile();
          }
          return Promise.resolve(data).then(function(data2) {
            _this3.setData(data2);
            _this3.setModules({
              data: _this3.data,
              Lexer
            });
            _this3.mapper = _this3.modules.reduce(function(value, module2) {
              return module2.getRenderedMap(value);
            }, {});
            return Promise.all(Object.keys(_this3.mapper).map(function(to) {
              var _this3$mapper$to = _this3.mapper[to], from2 = _this3$mapper$to.from, data3 = _this3$mapper$to.data;
              return Promise.resolve(data3).then(function(data4) {
                var currentFile = _this3.compiled[from2];
                currentFile.filePath = to;
                currentFile.scopeManager = _this3.getScopeManager(to, currentFile, data4);
                return currentFile.resolveTags(data4).then(function(result) {
                  currentFile.scopeManager.finishedResolving = true;
                  return result;
                }, function(errs) {
                  Array.prototype.push.apply(errors2, errs);
                });
              });
            })).then(function(resolved) {
              if (errors2.length !== 0) {
                if (_this3.options.errorLogging) {
                  logErrors(errors2, _this3.options.errorLogging);
                }
                throwMultiError(errors2);
              }
              return concatArrays(resolved);
            });
          });
        }
      }, {
        key: "reorderModules",
        value: function reorderModules() {
          this.modules = stableSort(this.modules, function(m1, m2) {
            return (m2.priority || 0) - (m1.priority || 0);
          });
        }
      }, {
        key: "compile",
        value: function compile2() {
          var _this4 = this;
          this.updateFileTypeConfig();
          this.reorderModules();
          if (Object.keys(this.compiled).length) {
            return this;
          }
          this.options = this.modules.reduce(function(options, module2) {
            return module2.optionsTransformer(options, _this4);
          }, this.options);
          this.options.xmlFileNames = uniq(this.options.xmlFileNames);
          this.xmlDocuments = this.options.xmlFileNames.reduce(function(xmlDocuments, fileName) {
            var content = _this4.zip.files[fileName].asText();
            xmlDocuments[fileName] = str2xml(content);
            return xmlDocuments;
          }, {});
          this.setModules({
            zip: this.zip,
            xmlDocuments: this.xmlDocuments
          });
          this.getTemplatedFiles();
          this.templatedFiles.forEach(function(fileName) {
            if (_this4.zip.files[fileName] != null) {
              _this4.precompileFile(fileName);
            }
          });
          this.templatedFiles.forEach(function(fileName) {
            if (_this4.zip.files[fileName] != null) {
              _this4.compileFile(fileName);
            }
          });
          this.setModules({
            compiled: this.compiled
          });
          verifyErrors(this);
          return this;
        }
      }, {
        key: "getRelsTypes",
        value: function getRelsTypes() {
          var rootRels = this.zip.files[relsFile];
          var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;
          var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName("Relationship") : [];
          var relsTypes = {};
          for (var i2 = 0, len = rootRelationships.length; i2 < len; i2++) {
            var r2 = rootRelationships[i2];
            relsTypes[r2.getAttribute("Target")] = r2.getAttribute("Type");
          }
          return relsTypes;
        }
      }, {
        key: "getContentTypes",
        value: function getContentTypes() {
          var contentTypes = this.zip.files[ctXML];
          var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;
          var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName("Override") : null;
          var defaults2 = contentTypeXml ? contentTypeXml.getElementsByTagName("Default") : null;
          return {
            overrides,
            defaults: defaults2,
            contentTypes,
            contentTypeXml
          };
        }
      }, {
        key: "updateFileTypeConfig",
        value: function updateFileTypeConfig() {
          var _this5 = this;
          var fileType;
          if (this.zip.files.mimetype) {
            fileType = "odt";
          }
          this.relsTypes = this.getRelsTypes();
          var _this$getContentTypes = this.getContentTypes(), overrides = _this$getContentTypes.overrides, defaults2 = _this$getContentTypes.defaults, contentTypes = _this$getContentTypes.contentTypes, contentTypeXml = _this$getContentTypes.contentTypeXml;
          if (contentTypeXml) {
            this.filesContentTypes = collectContentTypes(overrides, defaults2, this.zip);
            this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);
            this.setModules({
              contentTypes: this.contentTypes,
              invertedContentTypes: this.invertedContentTypes
            });
          }
          this.modules.forEach(function(module2) {
            fileType = module2.getFileType({
              zip: _this5.zip,
              contentTypes,
              contentTypeXml,
              overrides,
              defaults: defaults2,
              doc: _this5
            }) || fileType;
          });
          if (fileType === "odt") {
            throwFileTypeNotHandled(fileType);
          }
          if (!fileType) {
            throwFileTypeNotIdentified();
          }
          this.fileType = fileType;
          dropUnsupportedFileTypesModules(this);
          this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig || Docxtemplater2.FileTypeConfig[this.fileType]();
          return this;
        }
      }, {
        key: "renderAsync",
        value: function renderAsync(data) {
          var _this6 = this;
          return this.resolveData(data).then(function() {
            return _this6.render();
          });
        }
      }, {
        key: "render",
        value: function render2(data) {
          var _this7 = this;
          if (this.rendered) {
            throwRenderTwice();
          }
          this.rendered = true;
          this.compile();
          if (this.errors.length > 0) {
            throwRenderInvalidTemplate();
          }
          if (data) {
            this.setData(data);
          }
          this.setModules({
            data: this.data,
            Lexer
          });
          this.mapper = this.mapper || this.modules.reduce(function(value, module2) {
            return module2.getRenderedMap(value);
          }, {});
          Object.keys(this.mapper).forEach(function(to) {
            var _this7$mapper$to = _this7.mapper[to], from2 = _this7$mapper$to.from, data2 = _this7$mapper$to.data;
            var currentFile = _this7.compiled[from2];
            currentFile.scopeManager = _this7.getScopeManager(to, currentFile, data2);
            currentFile.render(to);
            _this7.zip.file(to, currentFile.content, {
              createFolders: true
            });
          });
          verifyErrors(this);
          this.sendEvent("syncing-zip");
          this.syncZip();
          return this;
        }
      }, {
        key: "syncZip",
        value: function syncZip() {
          var _this8 = this;
          Object.keys(this.xmlDocuments).forEach(function(fileName) {
            _this8.zip.remove(fileName);
            var content = xml2str(_this8.xmlDocuments[fileName]);
            return _this8.zip.file(fileName, content, {
              createFolders: true
            });
          });
        }
      }, {
        key: "setData",
        value: function setData(data) {
          this.data = data;
          return this;
        }
      }, {
        key: "getZip",
        value: function getZip() {
          return this.zip;
        }
      }, {
        key: "createTemplateClass",
        value: function createTemplateClass(path) {
          var content = this.zip.files[path].asText();
          return this.createTemplateClassFromContent(content, path);
        }
      }, {
        key: "createTemplateClassFromContent",
        value: function createTemplateClassFromContent(content, filePath) {
          var _this9 = this;
          var xmltOptions = {
            filePath,
            contentType: this.filesContentTypes[filePath],
            relsType: this.relsTypes[filePath]
          };
          Object.keys(defaults).concat(["filesContentTypes", "fileTypeConfig", "fileType", "modules"]).forEach(function(key) {
            xmltOptions[key] = _this9[key];
          });
          return new Docxtemplater2.XmlTemplater(content, xmltOptions);
        }
      }, {
        key: "getFullText",
        value: function getFullText(path) {
          return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();
        }
      }, {
        key: "getTemplatedFiles",
        value: function getTemplatedFiles() {
          var _this10 = this;
          this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);
          this.targets.forEach(function(target) {
            _this10.templatedFiles.push(target);
          });
          this.templatedFiles = uniq(this.templatedFiles);
          return this.templatedFiles;
        }
      }]);
      return Docxtemplater2;
    }();
    function verifyErrors(doc) {
      var compiled = doc.compiled;
      doc.errors = concatArrays(Object.keys(compiled).map(function(name) {
        return compiled[name].allErrors;
      }));
      if (doc.errors.length !== 0) {
        if (doc.options.errorLogging) {
          logErrors(doc.errors, doc.options.errorLogging);
        }
        throwMultiError(doc.errors);
      }
    }
    Docxtemplater.DocUtils = DocUtils;
    Docxtemplater.Errors = errors;
    Docxtemplater.XmlTemplater = requireXmlTemplater();
    Docxtemplater.FileTypeConfig = requireFileTypeConfig();
    Docxtemplater.XmlMatcher = requireXmlMatcher();
    var docxtemplater = Docxtemplater;
    const Docxtemplater$1 = /* @__PURE__ */ getDefaultExportFromCjs(docxtemplater);
    const PizZipUtils$1 = {};
    PizZipUtils$1._getBinaryFromXHR = function(xhr) {
      return xhr.response || xhr.responseText;
    };
    function createStandardXHR() {
      try {
        return new window.XMLHttpRequest();
      } catch (e2) {
      }
    }
    function createActiveXHR() {
      try {
        return new window.ActiveXObject("Microsoft.XMLHTTP");
      } catch (e2) {
      }
    }
    const createXHR = window.ActiveXObject ? (
      /* Microsoft failed to properly
       * implement the XMLHttpRequest in IE7 (can't request local files),
       * so we use the ActiveXObject when it is available
       * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
       * we need a fallback.
       */
      function() {
        return createStandardXHR() || createActiveXHR();
      }
    ) : (
      // For all other browsers, use the standard XMLHttpRequest object
      createStandardXHR
    );
    PizZipUtils$1.getBinaryContent = function(path, callback) {
      try {
        const xhr = createXHR();
        xhr.open("GET", path, true);
        if ("responseType" in xhr) {
          xhr.responseType = "arraybuffer";
        }
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }
        xhr.onreadystatechange = function(evt) {
          let file2, err;
          if (xhr.readyState === 4) {
            if (xhr.status === 200 || xhr.status === 0) {
              file2 = null;
              err = null;
              try {
                file2 = PizZipUtils$1._getBinaryFromXHR(xhr);
              } catch (e2) {
                err = new Error(e2);
              }
              callback(err, file2);
            } else {
              callback(
                new Error(
                  "Ajax error for " + path + " : " + this.status + " " + this.statusText
                ),
                null
              );
            }
          }
        };
        xhr.send();
      } catch (e2) {
        callback(new Error(e2), null);
      }
    };
    var es6 = PizZipUtils$1;
    var utils = es6;
    const PizZipUtils = /* @__PURE__ */ getDefaultExportFromCjs(utils);
    function n(n2) {
      for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
        t2[e2 - 1] = arguments[e2];
      throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
        return "'" + n3 + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function r(n2) {
      return !!n2 && !!n2[Q];
    }
    function t(n2) {
      var r2;
      return !!n2 && (function(n3) {
        if (!n3 || "object" != typeof n3)
          return false;
        var r3 = Object.getPrototypeOf(n3);
        if (null === r3)
          return true;
        var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
        return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
      }(n2) || Array.isArray(n2) || !!n2[L] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L]) || s(n2) || v(n2));
    }
    function i(n2, r2, t2) {
      void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
        t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
      }) : n2.forEach(function(t3, e2) {
        return r2(e2, t3, n2);
      });
    }
    function o(n2) {
      var r2 = n2[Q];
      return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
    }
    function u(n2, r2) {
      return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
    }
    function a(n2, r2) {
      return 2 === o(n2) ? n2.get(r2) : n2[r2];
    }
    function f(n2, r2, t2) {
      var e2 = o(n2);
      2 === e2 ? n2.set(r2, t2) : 3 === e2 ? n2.add(t2) : n2[r2] = t2;
    }
    function c(n2, r2) {
      return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
    }
    function s(n2) {
      return X && n2 instanceof Map;
    }
    function v(n2) {
      return q && n2 instanceof Set;
    }
    function p(n2) {
      return n2.o || n2.t;
    }
    function l(n2) {
      if (Array.isArray(n2))
        return Array.prototype.slice.call(n2);
      var r2 = rn(n2);
      delete r2[Q];
      for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
        var i2 = t2[e2], o2 = r2[i2];
        false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
      }
      return Object.create(Object.getPrototypeOf(n2), r2);
    }
    function d(n2, e2) {
      return void 0 === e2 && (e2 = false), y(n2) || r(n2) || !t(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e2 && i(n2, function(n3, r2) {
        return d(r2, true);
      }, true)), n2;
    }
    function h() {
      n(2);
    }
    function y(n2) {
      return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
    }
    function b(r2) {
      var t2 = tn[r2];
      return t2 || n(18, r2), t2;
    }
    function m(n2, r2) {
      tn[n2] || (tn[n2] = r2);
    }
    function _() {
      return U;
    }
    function j(n2, r2) {
      r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
    }
    function g(n2) {
      O(n2), n2.p.forEach(S), n2.p = null;
    }
    function O(n2) {
      n2 === U && (U = n2.l);
    }
    function w(n2) {
      return U = { p: [], l: U, h: n2, m: true, _: 0 };
    }
    function S(n2) {
      var r2 = n2[Q];
      0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
    }
    function P(r2, e2) {
      e2._ = e2.p.length;
      var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
      return e2.h.O || b("ES5").S(e2, r2, o2), o2 ? (i2[Q].P && (g(e2), n(4)), t(r2) && (r2 = M(e2, r2), e2.l || x(e2, r2)), e2.u && b("Patches").M(i2[Q].t, r2, e2.u, e2.s)) : r2 = M(e2, i2, []), g(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H ? r2 : void 0;
    }
    function M(n2, r2, t2) {
      if (y(r2))
        return r2;
      var e2 = r2[Q];
      if (!e2)
        return i(r2, function(i2, o3) {
          return A(n2, e2, r2, i2, o3, t2);
        }, true), r2;
      if (e2.A !== n2)
        return r2;
      if (!e2.P)
        return x(n2, e2.t, true), e2.t;
      if (!e2.I) {
        e2.I = true, e2.A._--;
        var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l(e2.k) : e2.o, u2 = o2, a2 = false;
        3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, function(r3, i2) {
          return A(n2, e2, o2, r3, i2, t2, a2);
        }), x(n2, o2, false), t2 && n2.u && b("Patches").N(e2, t2, n2.u, n2.s);
      }
      return e2.o;
    }
    function A(e2, i2, o2, a2, c2, s2, v2) {
      if (r(c2)) {
        var p2 = M(e2, c2, s2 && i2 && 3 !== i2.i && !u(i2.R, a2) ? s2.concat(a2) : void 0);
        if (f(o2, a2, p2), !r(p2))
          return;
        e2.m = false;
      } else
        v2 && o2.add(c2);
      if (t(c2) && !y(c2)) {
        if (!e2.h.D && e2._ < 1)
          return;
        M(e2, c2), i2 && i2.A.l || x(e2, c2);
      }
    }
    function x(n2, r2, t2) {
      void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d(r2, t2);
    }
    function z(n2, r2) {
      var t2 = n2[Q];
      return (t2 ? p(t2) : n2)[r2];
    }
    function I(n2, r2) {
      if (r2 in n2)
        for (var t2 = Object.getPrototypeOf(n2); t2; ) {
          var e2 = Object.getOwnPropertyDescriptor(t2, r2);
          if (e2)
            return e2;
          t2 = Object.getPrototypeOf(t2);
        }
    }
    function k(n2) {
      n2.P || (n2.P = true, n2.l && k(n2.l));
    }
    function E(n2) {
      n2.o || (n2.o = l(n2.t));
    }
    function N(n2, r2, t2) {
      var e2 = s(r2) ? b("MapSet").F(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
        var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en;
        t3 && (i2 = [e3], o2 = on);
        var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
        return e3.k = f2, e3.j = a2, f2;
      }(r2, t2) : b("ES5").J(r2, t2);
      return (t2 ? t2.A : _()).p.push(e2), e2;
    }
    function R(e2) {
      return r(e2) || n(22, e2), function n2(r2) {
        if (!t(r2))
          return r2;
        var e3, u2 = r2[Q], c2 = o(r2);
        if (u2) {
          if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
            return u2.t;
          u2.I = true, e3 = D(r2, c2), u2.I = false;
        } else
          e3 = D(r2, c2);
        return i(e3, function(r3, t2) {
          u2 && a(u2.t, r3) === t2 || f(e3, r3, n2(t2));
        }), 3 === c2 ? new Set(e3) : e3;
      }(e2);
    }
    function D(n2, r2) {
      switch (r2) {
        case 2:
          return new Map(n2);
        case 3:
          return Array.from(n2);
      }
      return l(n2);
    }
    function F() {
      function t2(n2, r2) {
        var t3 = s2[n2];
        return t3 ? t3.enumerable = r2 : s2[n2] = t3 = { configurable: true, enumerable: r2, get: function() {
          var r3 = this[Q];
          return en.get(r3, n2);
        }, set: function(r3) {
          var t4 = this[Q];
          en.set(t4, n2, r3);
        } }, t3;
      }
      function e2(n2) {
        for (var r2 = n2.length - 1; r2 >= 0; r2--) {
          var t3 = n2[r2][Q];
          if (!t3.P)
            switch (t3.i) {
              case 5:
                a2(t3) && k(t3);
                break;
              case 4:
                o2(t3) && k(t3);
            }
        }
      }
      function o2(n2) {
        for (var r2 = n2.t, t3 = n2.k, e3 = nn(t3), i2 = e3.length - 1; i2 >= 0; i2--) {
          var o3 = e3[i2];
          if (o3 !== Q) {
            var a3 = r2[o3];
            if (void 0 === a3 && !u(r2, o3))
              return true;
            var f2 = t3[o3], s3 = f2 && f2[Q];
            if (s3 ? s3.t !== a3 : !c(f2, a3))
              return true;
          }
        }
        var v2 = !!r2[Q];
        return e3.length !== nn(r2).length + (v2 ? 0 : 1);
      }
      function a2(n2) {
        var r2 = n2.k;
        if (r2.length !== n2.t.length)
          return true;
        var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
        if (t3 && !t3.get)
          return true;
        for (var e3 = 0; e3 < r2.length; e3++)
          if (!r2.hasOwnProperty(e3))
            return true;
        return false;
      }
      var s2 = {};
      m("ES5", { J: function(n2, r2) {
        var e3 = Array.isArray(n2), i2 = function(n3, r3) {
          if (n3) {
            for (var e4 = Array(r3.length), i3 = 0; i3 < r3.length; i3++)
              Object.defineProperty(e4, "" + i3, t2(i3, true));
            return e4;
          }
          var o4 = rn(r3);
          delete o4[Q];
          for (var u2 = nn(o4), a3 = 0; a3 < u2.length; a3++) {
            var f2 = u2[a3];
            o4[f2] = t2(f2, n3 || !!o4[f2].enumerable);
          }
          return Object.create(Object.getPrototypeOf(r3), o4);
        }(e3, n2), o3 = { i: e3 ? 5 : 4, A: r2 ? r2.A : _(), P: false, I: false, R: {}, l: r2, t: n2, k: i2, o: null, g: false, C: false };
        return Object.defineProperty(i2, Q, { value: o3, writable: true }), i2;
      }, S: function(n2, t3, o3) {
        o3 ? r(t3) && t3[Q].A === n2 && e2(n2.p) : (n2.u && function n3(r2) {
          if (r2 && "object" == typeof r2) {
            var t4 = r2[Q];
            if (t4) {
              var e3 = t4.t, o4 = t4.k, f2 = t4.R, c2 = t4.i;
              if (4 === c2)
                i(o4, function(r3) {
                  r3 !== Q && (void 0 !== e3[r3] || u(e3, r3) ? f2[r3] || n3(o4[r3]) : (f2[r3] = true, k(t4)));
                }), i(e3, function(n4) {
                  void 0 !== o4[n4] || u(o4, n4) || (f2[n4] = false, k(t4));
                });
              else if (5 === c2) {
                if (a2(t4) && (k(t4), f2.length = true), o4.length < e3.length)
                  for (var s3 = o4.length; s3 < e3.length; s3++)
                    f2[s3] = false;
                else
                  for (var v2 = e3.length; v2 < o4.length; v2++)
                    f2[v2] = true;
                for (var p2 = Math.min(o4.length, e3.length), l2 = 0; l2 < p2; l2++)
                  o4.hasOwnProperty(l2) || (f2[l2] = true), void 0 === f2[l2] && n3(o4[l2]);
              }
            }
          }
        }(n2.p[0]), e2(n2.p));
      }, K: function(n2) {
        return 4 === n2.i ? o2(n2) : a2(n2);
      } });
    }
    var G, U, W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X = "undefined" != typeof Map, q = "undefined" != typeof Set, B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G), L = W ? Symbol.for("immer-draftable") : "__$immer_draftable", Q = W ? Symbol.for("immer-state") : "__$immer_state", Z = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
      return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
    } : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n2) {
      var r2 = {};
      return nn(n2).forEach(function(t2) {
        r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
      }), r2;
    }, tn = {}, en = { get: function(n2, r2) {
      if (r2 === Q)
        return n2;
      var e2 = p(n2);
      if (!u(e2, r2))
        return function(n3, r3, t2) {
          var e3, i3 = I(r3, t2);
          return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
        }(n2, e2, r2);
      var i2 = e2[r2];
      return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
    }, has: function(n2, r2) {
      return r2 in p(n2);
    }, ownKeys: function(n2) {
      return Reflect.ownKeys(p(n2));
    }, set: function(n2, r2, t2) {
      var e2 = I(p(n2), r2);
      if (null == e2 ? void 0 : e2.set)
        return e2.set.call(n2.k, t2), true;
      if (!n2.P) {
        var i2 = z(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
        if (o2 && o2.t === t2)
          return n2.o[r2] = t2, n2.R[r2] = false, true;
        if (c(t2, i2) && (void 0 !== t2 || u(n2.t, r2)))
          return true;
        E(n2), k(n2);
      }
      return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
    }, deleteProperty: function(n2, r2) {
      return void 0 !== z(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
    }, getOwnPropertyDescriptor: function(n2, r2) {
      var t2 = p(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
      return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
    }, defineProperty: function() {
      n(11);
    }, getPrototypeOf: function(n2) {
      return Object.getPrototypeOf(n2.t);
    }, setPrototypeOf: function() {
      n(12);
    } }, on = {};
    i(en, function(n2, r2) {
      on[n2] = function() {
        return arguments[0] = arguments[0][0], r2.apply(this, arguments);
      };
    }), on.deleteProperty = function(r2, t2) {
      return on.set.call(this, r2, t2, void 0);
    }, on.set = function(r2, t2, e2) {
      return en.set.call(this, r2[0], t2, e2, r2[0]);
    };
    var un = function() {
      function e2(r2) {
        var e3 = this;
        this.O = B, this.D = true, this.produce = function(r3, i3, o2) {
          if ("function" == typeof r3 && "function" != typeof i3) {
            var u2 = i3;
            i3 = r3;
            var a2 = e3;
            return function(n2) {
              var r4 = this;
              void 0 === n2 && (n2 = u2);
              for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
                e4[o3 - 1] = arguments[o3];
              return a2.produce(n2, function(n3) {
                var t3;
                return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
              });
            };
          }
          var f2;
          if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
            var c2 = w(e3), s2 = N(e3, r3, void 0), v2 = true;
            try {
              f2 = i3(s2), v2 = false;
            } finally {
              v2 ? g(c2) : O(c2);
            }
            return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
              return j(c2, o2), P(n2, c2);
            }, function(n2) {
              throw g(c2), n2;
            }) : (j(c2, o2), P(f2, c2));
          }
          if (!r3 || "object" != typeof r3) {
            if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e3.D && d(f2, true), o2) {
              var p2 = [], l2 = [];
              b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
            }
            return f2;
          }
          n(21, r3);
        }, this.produceWithPatches = function(n2, r3) {
          if ("function" == typeof n2)
            return function(r4) {
              for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
                i4[o3 - 1] = arguments[o3];
              return e3.produceWithPatches(r4, function(r5) {
                return n2.apply(void 0, [r5].concat(i4));
              });
            };
          var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
            t2 = n3, i3 = r4;
          });
          return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
            return [n3, t2, i3];
          }) : [o2, t2, i3];
        }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
      }
      var i2 = e2.prototype;
      return i2.createDraft = function(e3) {
        t(e3) || n(8), r(e3) && (e3 = R(e3));
        var i3 = w(this), o2 = N(this, e3, void 0);
        return o2[Q].C = true, O(i3), o2;
      }, i2.finishDraft = function(r2, t2) {
        var e3 = r2 && r2[Q];
        var i3 = e3.A;
        return j(i3, t2), P(void 0, i3);
      }, i2.setAutoFreeze = function(n2) {
        this.D = n2;
      }, i2.setUseProxies = function(r2) {
        r2 && !B && n(20), this.O = r2;
      }, i2.applyPatches = function(n2, t2) {
        var e3;
        for (e3 = t2.length - 1; e3 >= 0; e3--) {
          var i3 = t2[e3];
          if (0 === i3.path.length && "replace" === i3.op) {
            n2 = i3.value;
            break;
          }
        }
        e3 > -1 && (t2 = t2.slice(e3 + 1));
        var o2 = b("Patches").$;
        return r(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
          return o2(n3, t2);
        });
      }, e2;
    }(), an = new un(), fn = an.produce;
    an.produceWithPatches.bind(an);
    an.setAutoFreeze.bind(an);
    an.setUseProxies.bind(an);
    an.applyPatches.bind(an);
    an.createDraft.bind(an);
    an.finishDraft.bind(an);
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function formatProdErrorMessage(code) {
      return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
    }
    var $$observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    var randomString = function randomString2() {
      return Math.random().toString(36).substring(7).split("").join(".");
    };
    var ActionTypes = {
      INIT: "@@redux/INIT" + randomString(),
      REPLACE: "@@redux/REPLACE" + randomString(),
      PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
      }
    };
    function isPlainObject$1(obj) {
      if (typeof obj !== "object" || obj === null)
        return false;
      var proto = obj;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(obj) === proto;
    }
    function createStore(reducer, preloadedState, enhancer) {
      var _ref2;
      if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(formatProdErrorMessage(0));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
      }
      if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
          throw new Error(formatProdErrorMessage(1));
        }
        return enhancer(createStore)(reducer, preloadedState);
      }
      if (typeof reducer !== "function") {
        throw new Error(formatProdErrorMessage(2));
      }
      var currentReducer = reducer;
      var currentState = preloadedState;
      var currentListeners = [];
      var nextListeners = currentListeners;
      var isDispatching = false;
      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = currentListeners.slice();
        }
      }
      function getState() {
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(3));
        }
        return currentState;
      }
      function subscribe(listener) {
        if (typeof listener !== "function") {
          throw new Error(formatProdErrorMessage(4));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(5));
        }
        var isSubscribed = true;
        ensureCanMutateNextListeners();
        nextListeners.push(listener);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }
          if (isDispatching) {
            throw new Error(formatProdErrorMessage(6));
          }
          isSubscribed = false;
          ensureCanMutateNextListeners();
          var index2 = nextListeners.indexOf(listener);
          nextListeners.splice(index2, 1);
          currentListeners = null;
        };
      }
      function dispatch(action) {
        if (!isPlainObject$1(action)) {
          throw new Error(formatProdErrorMessage(7));
        }
        if (typeof action.type === "undefined") {
          throw new Error(formatProdErrorMessage(8));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(9));
        }
        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }
        var listeners = currentListeners = nextListeners;
        for (var i2 = 0; i2 < listeners.length; i2++) {
          var listener = listeners[i2];
          listener();
        }
        return action;
      }
      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
          throw new Error(formatProdErrorMessage(10));
        }
        currentReducer = nextReducer;
        dispatch({
          type: ActionTypes.REPLACE
        });
      }
      function observable() {
        var _ref;
        var outerSubscribe = subscribe;
        return _ref = {
          /**
           * The minimal observable subscription method.
           * @param {Object} observer Any object that can be used as an observer.
           * The observer object should have a `next` method.
           * @returns {subscription} An object with an `unsubscribe` method that can
           * be used to unsubscribe the observable from the store, and prevent further
           * emission of values from the observable.
           */
          subscribe: function subscribe2(observer) {
            if (typeof observer !== "object" || observer === null) {
              throw new Error(formatProdErrorMessage(11));
            }
            function observeState() {
              if (observer.next) {
                observer.next(getState());
              }
            }
            observeState();
            var unsubscribe = outerSubscribe(observeState);
            return {
              unsubscribe
            };
          }
        }, _ref[$$observable] = function() {
          return this;
        }, _ref;
      }
      dispatch({
        type: ActionTypes.INIT
      });
      return _ref2 = {
        dispatch,
        subscribe,
        getState,
        replaceReducer
      }, _ref2[$$observable] = observable, _ref2;
    }
    function assertReducerShape(reducers) {
      Object.keys(reducers).forEach(function(key) {
        var reducer = reducers[key];
        var initialState2 = reducer(void 0, {
          type: ActionTypes.INIT
        });
        if (typeof initialState2 === "undefined") {
          throw new Error(formatProdErrorMessage(12));
        }
        if (typeof reducer(void 0, {
          type: ActionTypes.PROBE_UNKNOWN_ACTION()
        }) === "undefined") {
          throw new Error(formatProdErrorMessage(13));
        }
      });
    }
    function combineReducers(reducers) {
      var reducerKeys = Object.keys(reducers);
      var finalReducers = {};
      for (var i2 = 0; i2 < reducerKeys.length; i2++) {
        var key = reducerKeys[i2];
        if (typeof reducers[key] === "function") {
          finalReducers[key] = reducers[key];
        }
      }
      var finalReducerKeys = Object.keys(finalReducers);
      var shapeAssertionError;
      try {
        assertReducerShape(finalReducers);
      } catch (e2) {
        shapeAssertionError = e2;
      }
      return function combination(state, action) {
        if (state === void 0) {
          state = {};
        }
        if (shapeAssertionError) {
          throw shapeAssertionError;
        }
        var hasChanged = false;
        var nextState = {};
        for (var _i = 0; _i < finalReducerKeys.length; _i++) {
          var _key = finalReducerKeys[_i];
          var reducer = finalReducers[_key];
          var previousStateForKey = state[_key];
          var nextStateForKey = reducer(previousStateForKey, action);
          if (typeof nextStateForKey === "undefined") {
            action && action.type;
            throw new Error(formatProdErrorMessage(14));
          }
          nextState[_key] = nextStateForKey;
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
      };
    }
    function compose() {
      for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
        funcs[_key] = arguments[_key];
      }
      if (funcs.length === 0) {
        return function(arg) {
          return arg;
        };
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce(function(a2, b2) {
        return function() {
          return a2(b2.apply(void 0, arguments));
        };
      });
    }
    function applyMiddleware() {
      for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        middlewares[_key] = arguments[_key];
      }
      return function(createStore2) {
        return function() {
          var store2 = createStore2.apply(void 0, arguments);
          var _dispatch = function dispatch() {
            throw new Error(formatProdErrorMessage(15));
          };
          var middlewareAPI = {
            getState: store2.getState,
            dispatch: function dispatch() {
              return _dispatch.apply(void 0, arguments);
            }
          };
          var chain = middlewares.map(function(middleware2) {
            return middleware2(middlewareAPI);
          });
          _dispatch = compose.apply(void 0, chain)(store2.dispatch);
          return _objectSpread2(_objectSpread2({}, store2), {}, {
            dispatch: _dispatch
          });
        };
      };
    }
    function createThunkMiddleware(extraArgument) {
      var middleware2 = function middleware3(_ref) {
        var dispatch = _ref.dispatch, getState = _ref.getState;
        return function(next2) {
          return function(action) {
            if (typeof action === "function") {
              return action(dispatch, getState, extraArgument);
            }
            return next2(action);
          };
        };
      };
      return middleware2;
    }
    var thunk = createThunkMiddleware();
    thunk.withExtraArgument = createThunkMiddleware;
    const thunkMiddleware = thunk;
    var __extends = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __generator = globalThis && globalThis.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y2, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2) {
      for (var i2 = 0, il2 = from2.length, j2 = to.length; i2 < il2; i2++, j2++)
        to[j2] = from2[i2];
      return to;
    };
    var __defProp2 = Object.defineProperty;
    var __defProps2 = Object.defineProperties;
    var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = function(obj, key, value) {
      return key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    };
    var __spreadValues2 = function(a2, b2) {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp2.call(b2, prop))
          __defNormalProp2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols2)
        for (var _i = 0, _c = __getOwnPropSymbols2(b2); _i < _c.length; _i++) {
          var prop = _c[_i];
          if (__propIsEnum2.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps2 = function(a2, b2) {
      return __defProps2(a2, __getOwnPropDescs2(b2));
    };
    var __async2 = function(__this, __arguments, generator) {
      return new Promise(function(resolve, reject) {
        var fulfilled = function(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var rejected = function(value) {
          try {
            step(generator.throw(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var step = function(x2) {
          return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
        };
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
      if (arguments.length === 0)
        return void 0;
      if (typeof arguments[0] === "object")
        return compose;
      return compose.apply(null, arguments);
    };
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null)
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null)
        return true;
      var baseProto = proto;
      while (Object.getPrototypeOf(baseProto) !== null) {
        baseProto = Object.getPrototypeOf(baseProto);
      }
      return proto === baseProto;
    }
    var MiddlewareArray = (
      /** @class */
      function(_super) {
        __extends(MiddlewareArray2, _super);
        function MiddlewareArray2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, args) || this;
          Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
          return _this;
        }
        Object.defineProperty(MiddlewareArray2, Symbol.species, {
          get: function() {
            return MiddlewareArray2;
          },
          enumerable: false,
          configurable: true
        });
        MiddlewareArray2.prototype.concat = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          return _super.prototype.concat.apply(this, arr);
        };
        MiddlewareArray2.prototype.prepend = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          if (arr.length === 1 && Array.isArray(arr[0])) {
            return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr[0].concat(this))))();
          }
          return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr.concat(this))))();
        };
        return MiddlewareArray2;
      }(Array)
    );
    var EnhancerArray = (
      /** @class */
      function(_super) {
        __extends(EnhancerArray2, _super);
        function EnhancerArray2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, args) || this;
          Object.setPrototypeOf(_this, EnhancerArray2.prototype);
          return _this;
        }
        Object.defineProperty(EnhancerArray2, Symbol.species, {
          get: function() {
            return EnhancerArray2;
          },
          enumerable: false,
          configurable: true
        });
        EnhancerArray2.prototype.concat = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          return _super.prototype.concat.apply(this, arr);
        };
        EnhancerArray2.prototype.prepend = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          if (arr.length === 1 && Array.isArray(arr[0])) {
            return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr[0].concat(this))))();
          }
          return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr.concat(this))))();
        };
        return EnhancerArray2;
      }(Array)
    );
    function freezeDraftable(val) {
      return t(val) ? fn(val, function() {
      }) : val;
    }
    function isBoolean(x2) {
      return typeof x2 === "boolean";
    }
    function curryGetDefaultMiddleware() {
      return function curriedGetDefaultMiddleware(options) {
        return getDefaultMiddleware(options);
      };
    }
    function getDefaultMiddleware(options) {
      if (options === void 0) {
        options = {};
      }
      var _c = options.thunk, thunk2 = _c === void 0 ? true : _c;
      options.immutableCheck;
      options.serializableCheck;
      var middlewareArray = new MiddlewareArray();
      if (thunk2) {
        if (isBoolean(thunk2)) {
          middlewareArray.push(thunkMiddleware);
        } else {
          middlewareArray.push(thunkMiddleware.withExtraArgument(thunk2.extraArgument));
        }
      }
      return middlewareArray;
    }
    var IS_PRODUCTION = true;
    function configureStore(options) {
      var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
      var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware2 = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
      var rootReducer;
      if (typeof reducer === "function") {
        rootReducer = reducer;
      } else if (isPlainObject(reducer)) {
        rootReducer = combineReducers(reducer);
      } else {
        throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
      }
      var finalMiddleware = middleware2;
      if (typeof finalMiddleware === "function") {
        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
      }
      var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
      var finalCompose = compose;
      if (devTools) {
        finalCompose = composeWithDevTools(__spreadValues2({
          trace: !IS_PRODUCTION
        }, typeof devTools === "object" && devTools));
      }
      var defaultEnhancers = new EnhancerArray(middlewareEnhancer);
      var storeEnhancers = defaultEnhancers;
      if (Array.isArray(enhancers)) {
        storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
      } else if (typeof enhancers === "function") {
        storeEnhancers = enhancers(defaultEnhancers);
      }
      var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
      return createStore(rootReducer, preloadedState, composedEnhancer);
    }
    function createAction(type, prepareAction) {
      function actionCreator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (prepareAction) {
          var prepared = prepareAction.apply(void 0, args);
          if (!prepared) {
            throw new Error("prepareAction did not return an object");
          }
          return __spreadValues2(__spreadValues2({
            type,
            payload: prepared.payload
          }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
        }
        return { type, payload: args[0] };
      }
      actionCreator.toString = function() {
        return "" + type;
      };
      actionCreator.type = type;
      actionCreator.match = function(action) {
        return action.type === type;
      };
      return actionCreator;
    }
    function executeReducerBuilderCallback(builderCallback) {
      var actionsMap = {};
      var actionMatchers = [];
      var defaultCaseReducer;
      var builder2 = {
        addCase: function(typeOrActionCreator, reducer) {
          var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (type in actionsMap) {
            throw new Error("addCase cannot be called with two reducers for the same action type");
          }
          actionsMap[type] = reducer;
          return builder2;
        },
        addMatcher: function(matcher, reducer) {
          actionMatchers.push({ matcher, reducer });
          return builder2;
        },
        addDefaultCase: function(reducer) {
          defaultCaseReducer = reducer;
          return builder2;
        }
      };
      builderCallback(builder2);
      return [actionsMap, actionMatchers, defaultCaseReducer];
    }
    function isStateFunction(x2) {
      return typeof x2 === "function";
    }
    function createReducer(initialState2, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
      if (actionMatchers === void 0) {
        actionMatchers = [];
      }
      var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
      var getInitialState;
      if (isStateFunction(initialState2)) {
        getInitialState = function() {
          return freezeDraftable(initialState2());
        };
      } else {
        var frozenInitialState_1 = freezeDraftable(initialState2);
        getInitialState = function() {
          return frozenInitialState_1;
        };
      }
      function reducer(state, action) {
        if (state === void 0) {
          state = getInitialState();
        }
        var caseReducers = __spreadArray([
          actionsMap[action.type]
        ], finalActionMatchers.filter(function(_c2) {
          var matcher = _c2.matcher;
          return matcher(action);
        }).map(function(_c2) {
          var reducer2 = _c2.reducer;
          return reducer2;
        }));
        if (caseReducers.filter(function(cr) {
          return !!cr;
        }).length === 0) {
          caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce(function(previousState, caseReducer) {
          if (caseReducer) {
            if (r(previousState)) {
              var draft = previousState;
              var result = caseReducer(draft, action);
              if (result === void 0) {
                return previousState;
              }
              return result;
            } else if (!t(previousState)) {
              var result = caseReducer(previousState, action);
              if (result === void 0) {
                if (previousState === null) {
                  return previousState;
                }
                throw Error("A case reducer on a non-draftable value must not return undefined");
              }
              return result;
            } else {
              return fn(previousState, function(draft2) {
                return caseReducer(draft2, action);
              });
            }
          }
          return previousState;
        }, state);
      }
      reducer.getInitialState = getInitialState;
      return reducer;
    }
    function getType2(slice2, actionKey) {
      return slice2 + "/" + actionKey;
    }
    function createSlice(options) {
      var name = options.name;
      if (!name) {
        throw new Error("`name` is a required option for createSlice");
      }
      if (typeof process !== "undefined" && false) {
        if (options.initialState === void 0) {
          console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
        }
      }
      var initialState2 = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
      var reducers = options.reducers || {};
      var reducerNames = Object.keys(reducers);
      var sliceCaseReducersByName = {};
      var sliceCaseReducersByType = {};
      var actionCreators = {};
      reducerNames.forEach(function(reducerName) {
        var maybeReducerWithPrepare = reducers[reducerName];
        var type = getType2(name, reducerName);
        var caseReducer;
        var prepareCallback;
        if ("reducer" in maybeReducerWithPrepare) {
          caseReducer = maybeReducerWithPrepare.reducer;
          prepareCallback = maybeReducerWithPrepare.prepare;
        } else {
          caseReducer = maybeReducerWithPrepare;
        }
        sliceCaseReducersByName[reducerName] = caseReducer;
        sliceCaseReducersByType[type] = caseReducer;
        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
      });
      function buildReducer() {
        var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
        var finalCaseReducers = __spreadValues2(__spreadValues2({}, extraReducers), sliceCaseReducersByType);
        return createReducer(initialState2, function(builder2) {
          for (var key in finalCaseReducers) {
            builder2.addCase(key, finalCaseReducers[key]);
          }
          for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
            var m2 = actionMatchers_1[_i];
            builder2.addMatcher(m2.matcher, m2.reducer);
          }
          if (defaultCaseReducer) {
            builder2.addDefaultCase(defaultCaseReducer);
          }
        });
      }
      var _reducer;
      return {
        name,
        reducer: function(state, action) {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer(state, action);
        },
        actions: actionCreators,
        caseReducers: sliceCaseReducersByName,
        getInitialState: function() {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer.getInitialState();
        }
      };
    }
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var nanoid = function(size) {
      if (size === void 0) {
        size = 21;
      }
      var id2 = "";
      var i2 = size;
      while (i2--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    };
    var commonProperties = [
      "name",
      "message",
      "stack",
      "code"
    ];
    var RejectWithValue = (
      /** @class */
      function() {
        function RejectWithValue2(payload, meta) {
          this.payload = payload;
          this.meta = meta;
        }
        return RejectWithValue2;
      }()
    );
    var FulfillWithMeta = (
      /** @class */
      function() {
        function FulfillWithMeta2(payload, meta) {
          this.payload = payload;
          this.meta = meta;
        }
        return FulfillWithMeta2;
      }()
    );
    var miniSerializeError = function(value) {
      if (typeof value === "object" && value !== null) {
        var simpleError = {};
        for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
          var property = commonProperties_1[_i];
          if (typeof value[property] === "string") {
            simpleError[property] = value[property];
          }
        }
        return simpleError;
      }
      return { message: String(value) };
    };
    (function() {
      function createAsyncThunk2(typePrefix, payloadCreator, options) {
        var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
          return {
            payload,
            meta: __spreadProps2(__spreadValues2({}, meta || {}), {
              arg,
              requestId,
              requestStatus: "fulfilled"
            })
          };
        });
        var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
          return {
            payload: void 0,
            meta: __spreadProps2(__spreadValues2({}, meta || {}), {
              arg,
              requestId,
              requestStatus: "pending"
            })
          };
        });
        var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
          return {
            payload,
            error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
            meta: __spreadProps2(__spreadValues2({}, meta || {}), {
              arg,
              requestId,
              rejectedWithValue: !!payload,
              requestStatus: "rejected",
              aborted: (error == null ? void 0 : error.name) === "AbortError",
              condition: (error == null ? void 0 : error.name) === "ConditionError"
            })
          };
        });
        var AC = typeof AbortController !== "undefined" ? AbortController : (
          /** @class */
          function() {
            function class_1() {
              this.signal = {
                aborted: false,
                addEventListener: function() {
                },
                dispatchEvent: function() {
                  return false;
                },
                onabort: function() {
                },
                removeEventListener: function() {
                },
                reason: void 0,
                throwIfAborted: function() {
                }
              };
            }
            class_1.prototype.abort = function() {
            };
            return class_1;
          }()
        );
        function actionCreator(arg) {
          return function(dispatch, getState, extra) {
            var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
            var abortController = new AC();
            var abortReason;
            function abort(reason) {
              abortReason = reason;
              abortController.abort();
            }
            var promise2 = function() {
              return __async2(this, null, function() {
                var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
                return __generator(this, function(_c) {
                  switch (_c.label) {
                    case 0:
                      _c.trys.push([0, 4, , 5]);
                      conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState, extra });
                      if (!isThenable(conditionResult))
                        return [3, 2];
                      return [4, conditionResult];
                    case 1:
                      conditionResult = _c.sent();
                      _c.label = 2;
                    case 2:
                      if (conditionResult === false || abortController.signal.aborted) {
                        throw {
                          name: "ConditionError",
                          message: "Aborted due to condition callback returning false."
                        };
                      }
                      abortedPromise = new Promise(function(_2, reject) {
                        return abortController.signal.addEventListener("abort", function() {
                          return reject({
                            name: "AbortError",
                            message: abortReason || "Aborted"
                          });
                        });
                      });
                      dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId, arg }, { getState, extra })));
                      return [4, Promise.race([
                        abortedPromise,
                        Promise.resolve(payloadCreator(arg, {
                          dispatch,
                          getState,
                          extra,
                          requestId,
                          signal: abortController.signal,
                          abort,
                          rejectWithValue: function(value, meta) {
                            return new RejectWithValue(value, meta);
                          },
                          fulfillWithValue: function(value, meta) {
                            return new FulfillWithMeta(value, meta);
                          }
                        })).then(function(result) {
                          if (result instanceof RejectWithValue) {
                            throw result;
                          }
                          if (result instanceof FulfillWithMeta) {
                            return fulfilled(result.payload, requestId, arg, result.meta);
                          }
                          return fulfilled(result, requestId, arg);
                        })
                      ])];
                    case 3:
                      finalAction = _c.sent();
                      return [3, 5];
                    case 4:
                      err_1 = _c.sent();
                      finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                      return [3, 5];
                    case 5:
                      skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                      if (!skipDispatch) {
                        dispatch(finalAction);
                      }
                      return [2, finalAction];
                  }
                });
              });
            }();
            return Object.assign(promise2, {
              abort,
              requestId,
              arg,
              unwrap: function() {
                return promise2.then(unwrapResult);
              }
            });
          };
        }
        return Object.assign(actionCreator, {
          pending,
          rejected,
          fulfilled,
          typePrefix
        });
      }
      createAsyncThunk2.withTypes = function() {
        return createAsyncThunk2;
      };
      return createAsyncThunk2;
    })();
    function unwrapResult(action) {
      if (action.meta && action.meta.rejectedWithValue) {
        throw action.payload;
      }
      if (action.error) {
        throw action.error;
      }
      return action.payload;
    }
    function isThenable(value) {
      return value !== null && typeof value === "object" && typeof value.then === "function";
    }
    var alm = "listenerMiddleware";
    createAction(alm + "/add");
    createAction(alm + "/removeAll");
    createAction(alm + "/remove");
    var promise;
    typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
      return (promise || (promise = Promise.resolve())).then(cb2).catch(function(err) {
        return setTimeout(function() {
          throw err;
        }, 0);
      });
    };
    F();
    const initialState$3 = {
      error: "",
      templateError: null,
      loading: false
    };
    const appSlice = createSlice({
      name: "appSlice",
      initialState: initialState$3,
      reducers: {
        setError: (state, action) => {
          state.error = action.payload;
        },
        setErrorTemplate: (state, action) => {
          state.templateError = action.payload;
        },
        setLoading: (state, action) => {
          state.loading = action.payload;
        }
      }
    });
    const { setError, setLoading, setErrorTemplate } = appSlice.actions;
    const appReducer = appSlice.reducer;
    const file = "/calendar-app/assets/raport-7451dbf2.docx";
    const WORKS = {
      komiss: "Комиссионный",
      strel: "Стрелочный",
      volnovod: "Волновод",
      rabochka: "Рабочая комиссия"
    };
    function loadFile(url, callback) {
      PizZipUtils.getBinaryContent(url, callback);
    }
    const handleFileDownload = (rowId, rows, dispatch) => __async(exports, null, function* () {
      const filteredRows = rows.filter((el2) => el2.rowId === rowId);
      function formatDate(isoDate) {
        const dateObj = new Date(isoDate);
        dateObj.setDate(dateObj.getDate() + 1);
        const day = dateObj.getUTCDate().toString().padStart(2, "0");
        const month = (dateObj.getUTCMonth() + 1).toString().padStart(2, "0");
        const year = dateObj.getUTCFullYear();
        return `${day}.${month}.${year}`;
      }
      const dateForDocument = {
        name: filteredRows[0].name,
        hasKomiss: filteredRows[0].task === WORKS.komiss,
        hasStrel: filteredRows[0].task === WORKS.strel,
        hasVolnovod: filteredRows[0].task === WORKS.volnovod,
        hasRabochka: filteredRows[0].task === WORKS.rabochka,
        task: filteredRows[0].task,
        location: filteredRows[0].location,
        date: formatDate(filteredRows[0].date)
      };
      try {
        loadFile(file, function(error, content) {
          if (error) {
            throw error;
          }
          const zip = new PizZip$1(content);
          const templateDoc = new Docxtemplater$1(zip, {
            paragraphLoop: true,
            linebreaks: true
          });
          templateDoc.render(dateForDocument);
          const generatedDoc = templateDoc.getZip().generate({
            type: "blob",
            mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            compression: "DEFLATE"
          });
          FileSaver_minExports.saveAs(generatedDoc, `raport${filteredRows[0].task}.docx`);
        });
      } catch (error) {
        const e2 = error;
        dispatch(setErrorTemplate(e2));
        console.log("Error: " + error);
      }
    });
    const initialState$2 = {
      rows: []
    };
    const tableSlice = createSlice({
      name: "selectedDate",
      initialState: initialState$2,
      reducers: {
        getRowsData: (state) => {
          state.rows = JSON.parse(localStorage.getItem("rowsData") || "[]");
        },
        addRowsData: (state, action) => {
          state.rows.push(action.payload);
        },
        changeRowsData: (state, action) => {
          const _a = action.payload, { rowId } = _a, updatedData = __objRest(_a, ["rowId"]);
          const rowIndex = state.rows.findIndex((row) => row.rowId === rowId);
          if (rowIndex !== -1) {
            state.rows[rowIndex] = __spreadValues(__spreadValues({}, state.rows[rowIndex]), updatedData);
          }
        },
        removeRowsData: (state, action) => {
          state.rows = state.rows.filter((row) => row.rowId !== action.payload);
        }
      }
    });
    const {
      addRowsData,
      getRowsData,
      removeRowsData,
      changeRowsData
    } = tableSlice.actions;
    const addRowsDataTC = (newRow) => (dispatch) => __async(exports, null, function* () {
      dispatch(setLoading(true));
      try {
        dispatch(addRowsData(newRow));
        const existingData = JSON.parse(localStorage.getItem("rowsData") || "[]");
        const newData = [...existingData, newRow];
        localStorage.setItem("rowsData", JSON.stringify(newData));
        dispatch(setLoading(false));
      } catch (e2) {
        const error = e2;
        dispatch(setError(error));
      }
    });
    const changeRowsDataTC = (updateRow) => (dispatch, getState) => __async(exports, null, function* () {
      dispatch(setLoading(true));
      try {
        dispatch(changeRowsData(updateRow));
        const updatedRows = getState().tableDate.rows;
        localStorage.setItem("rowsData", JSON.stringify(updatedRows));
        dispatch(setLoading(false));
      } catch (e2) {
        const error = e2;
        dispatch(setError(error));
      }
    });
    const removeRowsDataTC = (rowId) => (dispatch) => __async(exports, null, function* () {
      dispatch(setLoading(true));
      try {
        dispatch(removeRowsData(rowId));
        const existingData = JSON.parse(localStorage.getItem("rowsData") || "[]");
        const newData = existingData.filter((row) => row.rowId !== rowId);
        localStorage.setItem("rowsData", JSON.stringify(newData));
        dispatch(setLoading(false));
      } catch (e2) {
        const error = e2;
        dispatch(setError(error));
      }
    });
    const tableReducer = tableSlice.reducer;
    const useAppDispatch = () => useDispatch();
    const useAppSelector = useSelector;
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
    const byteToHex = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    let _nodeId;
    let _clockseq;
    let _lastMSecs = 0;
    let _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i2 = buf && offset || 0;
      const b2 = buf || new Array(16);
      options = options || {};
      let node2 = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node2 == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || rng)();
        if (node2 == null) {
          node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b2[i2++] = tl2 >>> 24 & 255;
      b2[i2++] = tl2 >>> 16 & 255;
      b2[i2++] = tl2 >>> 8 & 255;
      b2[i2++] = tl2 & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b2[i2++] = tmh >>> 8 & 255;
      b2[i2++] = tmh & 255;
      b2[i2++] = tmh >>> 24 & 15 | 16;
      b2[i2++] = tmh >>> 16 & 255;
      b2[i2++] = clockseq >>> 8 | 128;
      b2[i2++] = clockseq & 255;
      for (let n2 = 0; n2 < 6; ++n2) {
        b2[i2 + n2] = node2[n2];
      }
      return buf || unsafeStringify(b2);
    }
    const style = {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: 400,
      bgcolor: "background.paper",
      border: "2px solid #000",
      boxShadow: 24,
      p: 4
    };
    const BasicModalWindow = ({ open: open2, setOpen, children }) => {
      const handleClose = () => setOpen(false);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal$1,
        {
          open: open2,
          onClose: handleClose,
          "aria-labelledby": "modal-modal-title",
          "aria-describedby": "modal-modal-description",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: style, children })
        }
      ) });
    };
    const tableRowsArray = [
      {
        id: 1,
        title: "Ф.И.О",
        width: 100,
        align: "right"
      },
      {
        id: 2,
        title: "Работы",
        width: 120,
        align: "right"
      },
      {
        id: 3,
        title: "Станция/Перегон",
        width: 120,
        align: "right"
      },
      {
        id: 4,
        title: "Действия",
        width: 120,
        align: "center"
      }
    ];
    const tasksArray = [
      { task: "Комиссионный" },
      { task: "Стрелочный" },
      { task: "Волновод" },
      { task: "Рабочая комиссия" }
    ];
    const initialState$1 = {
      task: "",
      selectedTask: ""
    };
    const dateForUsersSlice = createSlice({
      name: "dateForUser",
      initialState: initialState$1,
      reducers: {
        setTasks: (state, action) => {
          state.task = action.payload;
        },
        setSelectedTasks: (state, action) => {
          state.selectedTask = action.payload;
        }
      }
    });
    const { setTasks, setSelectedTasks } = dateForUsersSlice.actions;
    const dateForUsersReducer = dateForUsersSlice.reducer;
    const GroupSelect = () => {
      const task = useAppSelector((state) => state.dateUsers.task);
      const dispatch = useAppDispatch();
      const handleTaskSelect = (task2) => {
        dispatch(setSelectedTasks(task2));
      };
      const handleChange = (event) => {
        dispatch(setTasks(event.target.value));
        handleTaskSelect(event.target.value);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, { variant: "standard", sx: { m: 1, minWidth: 120 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "demo-simple-select-standard-label", children: "Работы" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Select$1,
          {
            labelId: "demo-simple-select-standard-label",
            id: "demo-simple-select-standard",
            value: task,
            onChange: handleChange,
            label: "Работы",
            children: tasksArray.map(
              (jobs, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: jobs.task, children: jobs.task }, index2)
            )
          }
        )
      ] }) });
    };
    const ModalActionWindow = ({
      open: open2,
      setOpen,
      rowIdToChange,
      selectedDateObject,
      rows
    }) => {
      const selectedTask = useAppSelector((state) => state.dateUsers.selectedTask);
      const [name, setName] = reactExports.useState("");
      const [location2, setLocation] = reactExports.useState("");
      const modalTitle = rowIdToChange ? "Изменить" : "Добавить";
      const dispatch = useAppDispatch();
      const handleClose = () => setOpen(false);
      const handleModalAction = () => {
        const rowData = {
          name,
          task: selectedTask,
          location: location2,
          date: selectedDateObject.toISOString(),
          rowId: rowIdToChange || v1()
        };
        if (rowIdToChange) {
          dispatch(changeRowsDataTC(rowData));
        } else {
          dispatch(addRowsDataTC(rowData));
        }
        handleClose();
      };
      reactExports.useEffect(() => {
        if (rowIdToChange) {
          const selectedRow = rows == null ? void 0 : rows.find((row) => row.rowId === rowIdToChange);
          if (selectedRow) {
            setName(selectedRow.name);
            setLocation(selectedRow.location);
          }
        }
      }, [rowIdToChange, rows]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BasicModalWindow, { open: open2, setOpen, children: [
        modalTitle,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { id: "modal-modal-description1", variant: "h6", component: "h2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField$1,
          {
            id: "name-input",
            label: "Ф.И.О",
            variant: "standard",
            value: name,
            onChange: (e2) => setName(e2.currentTarget.value)
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { id: "modal-modal-description2", sx: { mt: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupSelect, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { id: "modal-modal-", sx: { mt: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField$1,
          {
            id: "location-input",
            label: "Станция/Перегон",
            variant: "standard",
            value: location2,
            onChange: (e2) => setLocation(e2.currentTarget.value)
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: handleModalAction, disabled: false, sx: { mt: 2 }, children: modalTitle })
      ] }) });
    };
    const GroupButton = ({ rowId }) => {
      const rows = useAppSelector((state) => state.tableDate.rows);
      const selectedDate = useAppSelector((state) => state.selectedDate.selectedDate);
      const selectedDateObject = selectedDate ? dayjs(selectedDate) : null;
      const { open: open2, setOpen, handleOpen } = useModalWindow();
      const dispatch = useAppDispatch();
      const removeClickHandler = (rowId2) => {
        dispatch(removeRowsDataTC(rowId2));
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonGroup$1, { variant: "contained", "aria-label": "outlined primary button group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: () => handleFileDownload(rowId, rows, dispatch), children: "Печать" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: handleOpen, children: "Изменить" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: () => removeClickHandler(rowId), children: "Удалить" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ModalActionWindow,
          {
            open: open2,
            setOpen,
            rowIdToChange: rowId,
            selectedDateObject,
            rows
          }
        )
      ] });
    };
    const TableItem = ({ row, rowId }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TableRow$1,
        {
          sx: { "&:last-child td, &:last-child th": { border: 0 } },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { component: "th", scope: "row", children: row.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { align: "right", children: row.task }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { align: "right", children: row.location }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { align: "right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupButton, { rowId }) })
          ]
        },
        row.name
      );
    };
    const TableComponent = () => {
      const selectedDate = useAppSelector((state) => state.selectedDate.selectedDate);
      const rows = useAppSelector((state) => state.tableDate.rows);
      const filteredRows = selectedDate ? rows.filter((row) => row.date === selectedDate) : rows;
      const dispatch = useAppDispatch();
      reactExports.useEffect(() => {
        dispatch(getRowsData());
      }, [dispatch]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Paper$1, { sx: { width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer$1, { sx: { maxHeight: 320 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, { sx: { minWidth: 650 }, stickyHeader: true, "aria-label": "simple table", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow$1, { children: tableRowsArray.map(
          (tableRow) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableCell$1,
            {
              align: tableRow.align,
              style: { minWidth: tableRow.width },
              children: tableRow.title
            },
            tableRow.id
          )
        ) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, { children: filteredRows.map((row) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableItem, { row, rowId: row.rowId }, row.rowId)) })
      ] }) }) });
    };
    const initialState = {
      selectedDate: null
    };
    const calendarSlice = createSlice({
      name: "selectedDate",
      initialState,
      reducers: {
        getDate: (state, action) => {
          state.selectedDate = action.payload;
        }
      }
    });
    const { getDate } = calendarSlice.actions;
    const calendarReducer = calendarSlice.reducer;
    const CalendarPage = () => {
      const selectedDate = useAppSelector((state) => state.selectedDate.selectedDate);
      const selectedDateObject = selectedDate ? dayjs(selectedDate) : null;
      const rows = useAppSelector((state) => state.tableDate.rows);
      const { open: open2, setOpen, handleOpen } = useModalWindow();
      const dispatch = useAppDispatch();
      const handleDateChange = (date) => {
        dispatch(getDate(date ? date.toISOString() : null));
      };
      const datesWithRows = rows.map((row) => new Date(row.date));
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LocalizationProvider, { dateAdapter: AdapterDayjs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          StaticDatePicker,
          {
            orientation: "landscape",
            value: selectedDateObject,
            onChange: handleDateChange,
            slots: {
              day: CustomDaySlot
            },
            slotProps: {
              day: {
                datesWithRows
              }
            }
          }
        ) }),
        selectedDateObject && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: handleOpen, children: "Добавить событие" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableComponent, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ModalActionWindow, { open: open2, setOpen, selectedDateObject })
      ] });
    };
    const CustomDaySlot = (props) => {
      const _a = props, { datesWithRows, day, outsideCurrentMonth } = _a, other = __objRest(_a, ["datesWithRows", "day", "outsideCurrentMonth"]);
      const hasRowsForSelectedDate = datesWithRows && datesWithRows.some((date) => date.getTime() === day.toDate().getTime());
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Badge$1,
        {
          overlap: "circular",
          badgeContent: hasRowsForSelectedDate ? "💪" : void 0,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDay, __spreadProps(__spreadValues({}, other), { outsideCurrentMonth, day }))
        },
        props.day.toString()
      );
    };
    const ErrorAlert = ({ error }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack$1, { sx: { width: "100%" }, spacing: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert$1, { severity: "warning", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle$1, { children: error.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "Message - ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: error.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "Explanation - ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: error.properties.explanation })
        ] })
      ] }) });
    };
    const AppContainer = () => {
      const templateError = useAppSelector((state) => state.app.templateError);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { sx: { flexGrow: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar$1, { position: "static", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h6", component: "div", sx: { flexGrow: 1 }, children: "Hello!" }) }) }),
        templateError && templateError.properties.errors.map((error, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorAlert, { error }) }, index2)),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CalendarPage, {})
      ] });
    };
    function App() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppContainer, {}) });
    }
    const store = configureStore({
      reducer: {
        app: appReducer,
        tableDate: tableReducer,
        selectedDate: calendarReducer,
        dateUsers: dateForUsersReducer
      }
    });
    const index = "";
    client.createRoot(document.getElementById("root")).render(
      // <React.StrictMode>
      /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
      // </React.StrictMode>,
    );
  }
});
export default require_index_001();
